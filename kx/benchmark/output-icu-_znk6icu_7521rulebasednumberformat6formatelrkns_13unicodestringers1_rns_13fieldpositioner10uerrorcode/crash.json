{
    "samples": [

    {
        "benchmark": "output-icu-_znk6icu_7521rulebasednumberformat6formatelrkns_13unicodestringers1_rns_13fieldpositioner10uerrorcode",
        "sample": "01",
        "status": "Done",
        "compiles": "True",
        "crashes": "False",
        "crash_reason": "NO_SEMANTIC_ERR",
        "bug": "True",
        "coverage": "3.14",
        "coverage_diff": "0.0013254877671105606",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include \"unicode/unistr.h\"\\n#include \"unicode/rbnf.h\"\\n#include \"unicode/fieldpos.h\"\\n#include \"unicode/utypes.h\"\\n\\nusing namespace icu_76;\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\\n    FuzzedDataProvider stream(data, size);\\n\\n    // Create a RuleBasedNumberFormat object\\n    UErrorCode status = U_ZERO_ERROR;\\n    RuleBasedNumberFormat rbnf(URBNF_SPELLOUT, Locale::getEnglish(), status);\\n    if (U_FAILURE(status)) {\\n        return 0;\\n    }\\n\\n    // Generate fuzzed inputs\\n    int64_t number = stream.ConsumeIntegral<int64_t>();\\n    UnicodeString ustr1 = UnicodeString::fromUTF8(stream.ConsumeRandomLengthString());\\n    UnicodeString ustr2;\\n    FieldPosition pos(stream.ConsumeIntegral<int32_t>());\\n    UErrorCode errorCode = U_ZERO_ERROR;\\n\\n    // Call the function to fuzz\\n    rbnf.format(number, ustr1, ustr2, pos, errorCode);\\n\\n    return 0;\\n}",
        "model": ""
    },

    {
        "benchmark": "output-icu-_znk6icu_7521rulebasednumberformat6formatelrkns_13unicodestringers1_rns_13fieldpositioner10uerrorcode",
        "sample": "02",
        "status": "Done",
        "compiles": "True",
        "crashes": "False",
        "crash_reason": "NO_SEMANTIC_ERR",
        "bug": "True",
        "coverage": "2.91",
        "coverage_diff": "0.001362650975534221",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include <unicode/unistr.h>\\n#include <unicode/rbnf.h>\\n#include <unicode/fieldpos.h>\\n#include <unicode/utypes.h>\\n#include <unicode/locid.h>\\n#include <unicode/parseerr.h>\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\\n  FuzzedDataProvider stream(data, size);\\n\\n  // Generate input parameters\\n  int64_t number = stream.ConsumeIntegral<int64_t>();\\n  std::string str1 = stream.ConsumeRandomLengthString();\\n  std::string str2 = stream.ConsumeRandomLengthString();\\n  UErrorCode status = U_ZERO_ERROR;\\n\\n  icu::UnicodeString ustr1(str1.c_str(), \"UTF-8\");\\n  icu::UnicodeString ustr2(str2.c_str(), \"UTF-8\");\\n  icu::FieldPosition fieldPosition;\\n\\n  // Create an instance of RuleBasedNumberFormat\\n  icu::Locale locale = icu::Locale::getDefault();\\n  icu::RuleBasedNumberFormat rbnf(icu::URBNF_SPELLOUT, locale, status);\\n\\n  // Call the function to be fuzzed\\n  rbnf.format(number, ustr1, ustr2, fieldPosition, status);\\n\\n  return 0;\\n}",
        "model": ""
    }

    ]
}