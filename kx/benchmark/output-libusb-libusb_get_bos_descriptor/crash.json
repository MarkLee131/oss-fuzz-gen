{
    "samples": [

    {
        "benchmark": "output-libusb-libusb_get_bos_descriptor",
        "sample": "01",
        "status": "Done",
        "compiles": "True",
        "crashes": "False",
        "crash_reason": "NO_SEMANTIC_ERR",
        "bug": "True",
        "coverage": "12.43",
        "coverage_diff": "0.2724046140195209",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include <libusb.h>\\n#include <vector>\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\\n    FuzzedDataProvider stream(data, size);\\n\\n    // Initialize libusb context\\n    libusb_context* ctx = nullptr;\\n    if (libusb_init(&ctx) != 0) {\\n        return 0;\\n    }\\n\\n    // Get the list of USB devices\\n    libusb_device** dev_list = nullptr;\\n    ssize_t dev_count = libusb_get_device_list(ctx, &dev_list);\\n    if (dev_count < 0) {\\n        libusb_exit(ctx);\\n        return 0;\\n    }\\n\\n    // Select a device from the list\\n    libusb_device* dev = nullptr;\\n    if (dev_count > 0) {\\n        size_t index = stream.ConsumeIntegralInRange<size_t>(0, dev_count - 1);\\n        dev = dev_list[index];\\n    }\\n\\n    // Open the selected device\\n    libusb_device_handle* handle = nullptr;\\n    if (dev != nullptr) {\\n        if (libusb_open(dev, &handle) != 0) {\\n            libusb_free_device_list(dev_list, 1);\\n            libusb_exit(ctx);\\n            return 0;\\n        }\\n    }\\n\\n    // Free the device list\\n    libusb_free_device_list(dev_list, 1);\\n\\n    // Prepare the libusb_bos_descriptor pointer\\n    libusb_bos_descriptor* bos_desc = nullptr;\\n\\n    // Call the target function if the handle is valid\\n    if (handle != nullptr) {\\n        libusb_get_bos_descriptor(handle, &bos_desc);\\n    }\\n\\n    // Free the BOS descriptor if it was allocated\\n    if (bos_desc != nullptr) {\\n        libusb_free_bos_descriptor(bos_desc);\\n    }\\n\\n    // Close the device handle and exit libusb context\\n    if (handle != nullptr) {\\n        libusb_close(handle);\\n    }\\n    libusb_exit(ctx);\\n\\n    return 0;\\n}",
        "model": ""
    },

    {
        "benchmark": "output-libusb-libusb_get_bos_descriptor",
        "sample": "02",
        "status": "Done",
        "compiles": "True",
        "crashes": "False",
        "crash_reason": "NO_SEMANTIC_ERR",
        "bug": "True",
        "coverage": "7.01",
        "coverage_diff": "0.1661047027506655",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include <libusb.h>\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\\n  FuzzedDataProvider stream(data, size);\\n\\n  // Initialize libusb\\n  libusb_context* ctx = nullptr;\\n  if (libusb_init(&ctx) != 0) {\\n    return 0;\\n  }\\n\\n  // Generate random Vendor ID and Product ID\\n  uint16_t vid = stream.ConsumeIntegral<uint16_t>();\\n  uint16_t pid = stream.ConsumeIntegral<uint16_t>();\\n\\n  // Create a dummy libusb_device_handle\\n  libusb_device_handle* handle = libusb_open_device_with_vid_pid(ctx, vid, pid);\\n  if (handle == nullptr) {\\n    libusb_exit(ctx);\\n    return 0;\\n  }\\n\\n  // Prepare the output parameter\\n  libusb_bos_descriptor* bos_desc = nullptr;\\n\\n  // Call the function to be fuzzed with valid input\\n  int result = libusb_get_bos_descriptor(handle, &bos_desc);\\n\\n  // Free the bos descriptor if it was allocated\\n  if (bos_desc) {\\n    libusb_free_bos_descriptor(bos_desc);\\n  }\\n\\n  // Close the device handle and exit libusb\\n  libusb_close(handle);\\n  libusb_exit(ctx);\\n\\n  return 0;\\n}",
        "model": ""
    }

    ]
}