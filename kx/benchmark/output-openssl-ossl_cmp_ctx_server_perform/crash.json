{
    "samples": [

    {
        "benchmark": "output-openssl-ossl_cmp_ctx_server_perform",
        "sample": "01",
        "status": "Done",
        "compiles": "True",
        "crashes": "False",
        "crash_reason": "NO_COV_INCREASE",
        "bug": "False",
        "coverage": "0.00",
        "coverage_diff": "0.0",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include <openssl/cmp.h>\\n#include <openssl/ossl_typ.h>\\n#include <openssl/crypto.h>\\n#include <vector>\\n#include <cstring>\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\\n    FuzzedDataProvider stream(data, size);\\n\\n    // Initialize OpenSSL library\\n    OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CONFIG, NULL);\\n\\n    // Create and initialize OSSL_CMP_CTX object\\n    OSSL_CMP_CTX *ctx = OSSL_CMP_CTX_new(NULL, NULL);\\n    if (ctx == nullptr) {\\n        return 0;\\n    }\\n\\n    // Create and initialize OSSL_CMP_MSG object\\n    std::vector<uint8_t> msg_data = stream.ConsumeBytes<uint8_t>(stream.ConsumeIntegralInRange<size_t>(1, size));\\n    if (msg_data.empty()) {\\n        OSSL_CMP_CTX_free(ctx);\\n        return 0;\\n    }\\n\\n    const unsigned char *msg_ptr = msg_data.data();\\n    OSSL_CMP_MSG *msg = d2i_OSSL_CMP_MSG(NULL, &msg_ptr, msg_data.size());\\n    if (msg == nullptr) {\\n        OSSL_CMP_CTX_free(ctx);\\n        return 0;\\n    }\\n\\n    // Set a basic configuration for the context to ensure the function under test is invoked properly\\n    OSSL_CMP_CTX_set_option(ctx, OSSL_CMP_OPT_IMPLICIT_CONFIRM, 1);\\n\\n    // Call the function to be fuzzed\\n    OSSL_CMP_MSG *result = OSSL_CMP_CTX_server_perform(ctx, msg);\\n\\n    // Clean up\\n    OSSL_CMP_MSG_free(result);\\n    OSSL_CMP_MSG_free(msg);\\n    OSSL_CMP_CTX_free(ctx);\\n\\n    return 0;\\n}\\n\\nextern \"C\" int main(int argc, char **argv) {\\n    // The main function is needed to link the fuzzer properly\\n    return 0;\\n}",
        "model": ""
    },

    {
        "benchmark": "output-openssl-ossl_cmp_ctx_server_perform",
        "sample": "02",
        "status": "Done",
        "compiles": "False",
        "crashes": "False",
        "crash_reason": "-",
        "bug": "True",
        "coverage": "0.00",
        "coverage_diff": "0.0",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include <openssl/cmp.h>\\n#include <openssl/ossl_typ.h>\\n#include <vector>\\n#include <openssl/evp.h> // Include necessary OpenSSL headers for OSSL_LIB_CTX\\n#include <openssl/x509.h> // Include necessary OpenSSL headers for OSSL_CMP_MSG\\n\\nextern \"C\" {\\n    int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\\n        FuzzedDataProvider stream(data, size);\\n\\n        // Create and initialize OSSL_LIB_CTX\\n        OSSL_LIB_CTX *libctx = OSSL_LIB_CTX_new();\\n        if (libctx == nullptr) {\\n            return 0;\\n        }\\n\\n        // Create and initialize OSSL_CMP_CTX\\n        OSSL_CMP_CTX *ctx = OSSL_CMP_CTX_new(libctx, nullptr);\\n        if (ctx == nullptr) {\\n            OSSL_LIB_CTX_free(libctx);\\n            return 0;\\n        }\\n\\n        // Create and initialize OSSL_CMP_MSG\\n        std::vector<uint8_t> msg_data = stream.ConsumeBytes<uint8_t>(stream.ConsumeIntegralInRange<size_t>(1, size));\\n        const unsigned char *msg_data_ptr = msg_data.data();\\n        OSSL_CMP_MSG *msg = d2i_OSSL_CMP_MSG(nullptr, &msg_data_ptr, msg_data.size());\\n        if (msg == nullptr) {\\n            OSSL_CMP_CTX_free(ctx);\\n            OSSL_LIB_CTX_free(libctx);\\n            return 0;\\n        }\\n\\n        // Set some context parameters to ensure meaningful input\\n        OSSL_CMP_CTX_set_option(ctx, OSSL_CMP_OPT_MSG_TIMEOUT, stream.ConsumeIntegralInRange<int>(1, 1000));\\n        OSSL_CMP_CTX_set1_server(ctx, stream.ConsumeRandomLengthString(100).c_str());\\n\\n        // Call the function to fuzz\\n        OSSL_CMP_MSG *result = OSSL_CMP_CTX_server_perform(ctx, msg);\\n\\n        // Clean up\\n        OSSL_CMP_MSG_free(result);\\n        OSSL_CMP_MSG_free(msg);\\n        OSSL_CMP_CTX_free(ctx);\\n        OSSL_LIB_CTX_free(libctx);\\n\\n        return 0;\\n    }\\n}",
        "model": ""
    }

    ]
}