{
    "samples": [

    {
        "benchmark": "output-immer-_zn5immer6detail4rbts23slice_right_mut_visitorins1_4nodeiins_13memory_policyins_11heap_policyins_8cpp_heape",
        "sample": "01",
        "status": "Done",
        "compiles": "False",
        "crashes": "False",
        "crash_reason": "-",
        "bug": "True",
        "coverage": "0.00",
        "coverage_diff": "0.0",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include <immer/detail/rbts/node.hpp>\\n#include <immer/detail/rbts/visitor.hpp>\\n#include <immer/memory_policy.hpp>\\n#include <immer/cpp_heap.hpp>\\n#include <immer/unsafe_refcount_policy.hpp>\\n#include <immer/no_lock_policy.hpp>\\n#include <immer/no_transience_policy.hpp>\\n#include <tuple>\\n\\nusing namespace immer::detail::rbts;\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\\n    FuzzedDataProvider stream(data, size);\\n\\n    // Create a memory policy type\\n    using memory_policy_t = immer::memory_policy<\\n        immer::heap_policy<immer::cpp_heap>,\\n        immer::unsafe_refcount_policy,\\n        immer::no_lock_policy,\\n        immer::no_transience_policy,\\n        false,\\n        true>;\\n\\n    // Create node types\\n    using node_t = node<int, memory_policy_t, 2u, 2u>;\\n    using sub_node_t = node<int, memory_policy_t, 3u, 3u>;\\n\\n    // Create regular_pos and regular_sub_pos types\\n    using regular_pos_t = typename node_t::regular_pos_t;\\n    using regular_sub_pos_t = typename sub_node_t::regular_sub_pos_t;\\n\\n    // Create and initialize parameters\\n    regular_sub_pos_t regular_sub_pos;\\n    size_t size_param = stream.ConsumeIntegral<size_t>();\\n    void* edit_param = reinterpret_cast<void*>(stream.ConsumeIntegral<uintptr_t>());\\n\\n    // Create a slice_right_mut_visitor instance\\n    using visitor_t = slice_right_mut_visitor<node_t, true, true>;\\n    visitor_t visitor;\\n\\n    // Call the function to fuzz\\n    auto result = visitor.visit_regular(regular_sub_pos, size_param, edit_param);\\n\\n    // Use the result to avoid unused variable warning\\n    (void)result;\\n\\n    return 0;\\n}",
        "model": ""
    },

    {
        "benchmark": "output-immer-_zn5immer6detail4rbts23slice_right_mut_visitorins1_4nodeiins_13memory_policyins_11heap_policyins_8cpp_heape",
        "sample": "02",
        "status": "Done",
        "compiles": "False",
        "crashes": "False",
        "crash_reason": "-",
        "bug": "True",
        "coverage": "0.00",
        "coverage_diff": "0.0",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include <tuple>\\n#include \"immer/detail/rbts/node.hpp\"\\n#include \"immer/detail/rbts/visitor.hpp\"\\n#include \"immer/memory_policy.hpp\"\\n#include \"immer/heap/free_list_heap.hpp\" // Corrected include for heap policy\\n\\nusing namespace immer::detail::rbts;\\nusing namespace std;\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\\n    FuzzedDataProvider stream(data, size);\\n\\n    // Create and initialize parameters\\n    using node_t = node<int, immer::memory_policy<immer::heap_policy<immer::free_list_heap<>>, immer::unsafe_refcount_policy, immer::no_lock_policy, immer::no_transience_policy, true, true>, 3U, 3U>;\\n    regular_sub_pos<node_t> regularSubPos;\\n    size_t sizeParam = stream.ConsumeIntegral<size_t>();\\n    auto editParam = reinterpret_cast<typename node_t::edit_t>(stream.ConsumeIntegral<uintptr_t>());\\n\\n    // Call the function to fuzz\\n    auto result = slice_right_mut_visitor<node<int, immer::memory_policy<immer::heap_policy<immer::free_list_heap<>>, immer::unsafe_refcount_policy, immer::no_lock_policy, immer::no_transience_policy, false, true>, 2u, 2u>, true, true>::visit_regular(regularSubPos, sizeParam, editParam);\\n\\n    return 0;\\n}",
        "model": ""
    }

    ]
}