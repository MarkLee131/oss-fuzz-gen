{
    "samples": [

    {
        "benchmark": "output-eigen-_zn5eigen9transposeins_5blockins_6matrixinst3__17complexideelin1elin1eli0elin1elin1eeelin1eli1elb1eeee6resi",
        "sample": "01",
        "status": "Done",
        "compiles": "True",
        "crashes": "True",
        "crash_reason": "FP_NEAR_INIT_CRASH",
        "bug": "False",
        "coverage": "0.00",
        "coverage_diff": "0.0",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include <Eigen/Dense>\\n#include <complex>\\n#include <iostream>\\n\\nusing namespace Eigen;\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\\n  FuzzedDataProvider stream(data, size);\\n\\n  // Create a Transpose object to pass as the first argument\\n  Matrix<int, Dynamic, Dynamic> matrix = Matrix<int, Dynamic, Dynamic>::Random(3, 3);\\n  Transpose<Matrix<int, Dynamic, Dynamic>> transpose_matrix(matrix);\\n\\n  // Generate Index arguments\\n  Index rows = stream.ConsumeIntegralInRange<Index>(1, 3); // Ensure valid range for rows\\n  Index cols = stream.ConsumeIntegralInRange<Index>(1, 3); // Ensure valid range for cols\\n\\n  // Create a Block object to perform resize on\\n  Matrix<std::complex<double>, Dynamic, Dynamic> complex_matrix = \\n      Matrix<std::complex<double>, Dynamic, Dynamic>::Random(3, 3);\\n  Block<Matrix<std::complex<double>, Dynamic, Dynamic>> block = \\n      complex_matrix.block(0, 0, 3, 1);\\n  Transpose<Block<Matrix<std::complex<double>, Dynamic, Dynamic>>> transpose_block(block);\\n\\n  // Call the resize function on the transpose_block object\\n  try {\\n    // Ensure that the resize dimensions are within the bounds of the original matrix\\n    if (rows * cols <= block.size()) {\\n      transpose_block.resize(rows, cols);\\n    }\\n  } catch (const std::exception &e) {\\n    std::cerr << \"Exception caught: \" << e.what() << std::endl;\\n    return 0;\\n  }\\n\\n  return 0;\\n}",
        "model": ""
    },

    {
        "benchmark": "output-eigen-_zn5eigen9transposeins_5blockins_6matrixinst3__17complexideelin1elin1eli0elin1elin1eeelin1eli1elb1eeee6resi",
        "sample": "02",
        "status": "Done",
        "compiles": "True",
        "crashes": "True",
        "crash_reason": "NO_SEMANTIC_ERR",
        "bug": "True",
        "coverage": "50.83",
        "coverage_diff": "0.006427915518824609",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include <Eigen/Dense>\\n#include <complex>\\n#include <cassert>\\n\\nusing namespace Eigen;\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\\n    FuzzedDataProvider stream(data, size);\\n\\n    // Generate the dimensions for the matrices\\n    Index rows = stream.ConsumeIntegralInRange<Index>(1, 100);\\n    Index cols = stream.ConsumeIntegralInRange<Index>(1, 100);\\n\\n    // Create a matrix of complex numbers\\n    Matrix<std::complex<double>, Dynamic, Dynamic> complex_matrix(rows, cols);\\n    for (Index i = 0; i < rows; ++i) {\\n        for (Index j = 0; j < cols; ++j) {\\n            complex_matrix(i, j) = std::complex<double>(stream.ConsumeFloatingPoint<double>(), stream.ConsumeFloatingPoint<double>());\\n        }\\n    }\\n\\n    // Create a block of the complex matrix\\n    auto block = complex_matrix.block(0, 0, rows, 1);\\n\\n    // Create a transpose of the block\\n    auto transpose_block = block.transpose();\\n\\n    // Create a transpose of an integer matrix\\n    Matrix<int, Dynamic, Dynamic> int_matrix(rows, cols);\\n    auto transpose_int_matrix = int_matrix.transpose();\\n\\n    // Resize the transpose block\\n    Index new_rows = stream.ConsumeIntegralInRange<Index>(1, rows);\\n    Index new_cols = stream.ConsumeIntegralInRange<Index>(1, cols);\\n\\n    // Ensure the new dimensions are valid for resizing\\n    assert(new_rows > 0 && new_cols > 0);\\n\\n    // Call the function to fuzz\\n    if (new_rows * new_cols == rows * 1) {\\n        // Only resize if the new dimensions have the same number of elements as the original block\\n        transpose_block.resize(new_rows, new_cols);\\n    }\\n\\n    return 0;\\n}",
        "model": ""
    }

    ]
}