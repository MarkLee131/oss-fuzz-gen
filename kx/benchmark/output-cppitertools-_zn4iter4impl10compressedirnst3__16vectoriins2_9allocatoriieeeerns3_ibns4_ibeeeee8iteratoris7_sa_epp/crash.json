{
    "samples": [

    {
        "benchmark": "output-cppitertools-_zn4iter4impl10compressedirnst3__16vectoriins2_9allocatoriieeeerns3_ibns4_ibeeeee8iteratoris7_sa_epp",
        "sample": "01",
        "status": "Done",
        "compiles": "False",
        "crashes": "False",
        "crash_reason": "-",
        "bug": "True",
        "coverage": "0.00",
        "coverage_diff": "0.0",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include <vector>\\n#include <cstddef>\\n#include <cstdint>\\n\\nnamespace iter {\\nnamespace impl {\\ntemplate <typename IntVector, typename BoolVector>\\nclass Compressed {\\npublic:\\n  class Iterator {\\n  public:\\n    Iterator(IntVector& int_vec, BoolVector& bool_vec)\\n        : int_vec_(int_vec), bool_vec_(bool_vec), index_(0) {}\\n\\n    Iterator& operator++() {\\n      ++index_;\\n      return *this;\\n    }\\n\\n  private:\\n    IntVector& int_vec_;\\n    BoolVector& bool_vec_;\\n    size_t index_;\\n  };\\n};\\n} // namespace impl\\n} // namespace iter\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\\n  FuzzedDataProvider stream(data, size);\\n\\n  // Create vectors with random sizes and fill them with random values\\n  size_t int_vec_size = stream.ConsumeIntegralInRange<size_t>(0, 100);\\n  size_t bool_vec_size = stream.ConsumeIntegralInRange<size_t>(0, 100);\\n\\n  std::vector<int> int_vec(int_vec_size);\\n  for (size_t i = 0; i < int_vec_size; ++i) {\\n    int_vec[i] = stream.ConsumeIntegral<int>();\\n  }\\n\\n  std::vector<bool> bool_vec(bool_vec_size);\\n  for (size_t i = 0; i < bool_vec_size; ++i) {\\n    bool_vec[i] = stream.ConsumeBool();\\n  }\\n\\n  iter::impl::Compressed<std::vector<int>, std::vector<bool>>::Iterator iter(int_vec, bool_vec);\\n\\n  // Call the function to fuzz\\n  ++iter;\\n\\n  return 0;\\n}",
        "model": ""
    },

    {
        "benchmark": "output-cppitertools-_zn4iter4impl10compressedirnst3__16vectoriins2_9allocatoriieeeerns3_ibns4_ibeeeee8iteratoris7_sa_epp",
        "sample": "02",
        "status": "Done",
        "compiles": "False",
        "crashes": "False",
        "crash_reason": "-",
        "bug": "True",
        "coverage": "0.00",
        "coverage_diff": "0.0",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include <cstddef>\\n#include <cstdint>\\n#include <vector>\\n\\nnamespace iter {\\nnamespace impl {\\ntemplate <typename IntVector, typename BoolVector>\\nclass Compressed {\\npublic:\\n    class Iterator {\\n    public:\\n        Iterator(IntVector& int_vec, BoolVector& bool_vec) : int_vec_(int_vec), bool_vec_(bool_vec), index_(0) {}\\n\\n        Iterator& operator++() {\\n            // Simulate incrementing the iterator\\n            if (index_ < int_vec_.size()) {\\n                ++index_;\\n            }\\n            return *this;\\n        }\\n\\n    private:\\n        IntVector& int_vec_;\\n        BoolVector& bool_vec_;\\n        size_t index_;\\n    };\\n};\\n}  // namespace impl\\n}  // namespace iter\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\\n    FuzzedDataProvider stream(data, size);\\n\\n    // Create vectors for the test\\n    std::vector<int> int_vec = stream.ConsumeIntegralVector<int>(stream.ConsumeIntegralInRange<size_t>(0, 100));\\n    std::vector<bool> bool_vec;\\n    for (size_t i = 0; i < int_vec.size(); ++i) {\\n        bool_vec.push_back(stream.ConsumeBool());\\n    }\\n\\n    // Create an iterator\\n    iter::impl::Compressed<std::vector<int>, std::vector<bool>>::Iterator iterator(int_vec, bool_vec);\\n\\n    // Call the operator++ function multiple times to simulate usage\\n    for (size_t i = 0; i < int_vec.size(); ++i) {\\n        iterator.operator++();  // Explicitly call the operator++ function\\n    }\\n\\n    return 0;\\n}",
        "model": ""
    }

    ]
}