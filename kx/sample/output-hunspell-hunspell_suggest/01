<!doctype html>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Experiment results</title>
<style>
* {
    box-sizing: border-box;
}

html {
    line-height: 1.15;
}

body {
    font-family: sans-serif;
    font-size: 16px;
}

table {
    border-collapse: collapse;
    border-spacing: 0;
}

td, th {
    border-right: 1px #dedede solid;
    border-bottom: 1px #dedede solid;
    padding: 5px;
    text-align: left;
}
td:first-child, th:first-child {
    border-left: 1px #dedede solid;
}
th {
    border-top: 1px #dedede solid;
}

tbody tr:nth-child(odd) {
    background-color: #f4f5ff;
}
</style>
<body>
    LLM:

<h1>output-hunspell-hunspell_suggest / 01</h1>
Bug: True
<br>
Crash reason: NO_SEMANTIC_ERR
<br>
<br>




<h3>Final code</h3>

<pre>
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;hunspell/hunspell.h&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstdlib&gt;

extern &#34;C&#34; {
    Hunhandle* Hunspell_create(const char* affpath, const char* dpath);
    void Hunspell_destroy(Hunhandle* pHunspell);
    int Hunspell_suggest(Hunhandle* pHunspell, char*** slst, const char* word);
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
    FuzzedDataProvider stream(data, size);

    // Initialize Hunspell handle
    Hunhandle* handle = Hunspell_create(&#34;en_US.aff&#34;, &#34;en_US.dic&#34;);
    if (handle == nullptr) {
        return 0;
    }

    // Generate a random string to use as the word
    std::string word = stream.ConsumeRandomLengthString(100);
    const char* word_cstr = word.c_str();

    // Prepare the suggestion list
    char** suggestions = nullptr;

    // Call the function being fuzzed
    Hunspell_suggest(handle, &amp;suggestions, word_cstr);

    // Free the suggestions
    if (suggestions != nullptr) {
        for (int i = 0; suggestions[i] != nullptr; ++i) {
            free(suggestions[i]);
        }
        free(suggestions);
    }

    // Destroy the Hunspell handle
    Hunspell_destroy(handle);

    return 0;
}
</pre>


<h3>Fixer prompt #1</h3>
<pre>

Given the following C++ fuzz harness and its build error message, fix the code to make it build for fuzzing.

If there is undeclared identifier or unknown type name error, fix it by finding and including the related libraries.

Note that some code may need to be wrapped with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; as their source is C program.

MUST RETURN THE FULL CODE, INCLUDING UNCHANGED PARTS.
EXTREMELY IMPORTANT: AVOID USING &lt;code&gt;goto&lt;/code&gt;. If you have to write code using &lt;code&gt;goto&lt;/code&gt;, you MUST MUST also declare all variables BEFORE the &lt;code&gt;goto&lt;/code&gt;. Never introduce new variables after the &lt;code&gt;goto&lt;/code&gt;.

Below is the code needs to be built:
&lt;code&gt;
&lt;solution&gt;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;hunspell/hunspell.h&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

extern &#34;C&#34; int Hunspell_suggest(Hunhandle *, char ***, const char *);

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
    FuzzedDataProvider stream(data, size);

    // Initialize Hunspell handle
    Hunhandle* handle = Hunspell_create(&#34;en_US.aff&#34;, &#34;en_US.dic&#34;);
    if (handle == nullptr) {
        return 0;
    }

    // Generate a random string to use as the word
    std::string word = stream.ConsumeRandomLengthString(100);
    const char* word_cstr = word.c_str();

    // Prepare the suggestion list
    char** suggestions = nullptr;

    // Call the function being fuzzed
    Hunspell_suggest(handle, &amp;suggestions, word_cstr);

    // Free the suggestions
    if (suggestions != nullptr) {
        for (int i = 0; suggestions[i] != nullptr; ++i) {
            free(suggestions[i]);
        }
        free(suggestions);
    }

    // Destroy the Hunspell handle
    Hunspell_destroy(handle);

    return 0;
}
&lt;/code&gt;

The code has the following build issues:
&lt;error&gt;
./src/tools/fuzzer.cxx:1:1: error: expected unqualified-id
    1 | &lt;solution&gt;
      | ^
&lt;/error&gt;

Fix code:
1. Consider possible solutions for the issues listed above.
2. Choose a solution that can maximize fuzzing result, which is utilizing the function under test and feeding it not null input.
3. Apply the solutions to the original code.
It&#39;s important to show the complete code, not only the fixed line.
&lt;solution&gt;
</pre>



<h3>Code #1</h3>

<pre>
Here is the fixed code that should build correctly for fuzzing:

```cpp
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;hunspell/hunspell.h&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstdlib&gt;

extern &#34;C&#34; {
    Hunhandle* Hunspell_create(const char* affpath, const char* dpath);
    void Hunspell_destroy(Hunhandle* pHunspell);
    int Hunspell_suggest(Hunhandle* pHunspell, char*** slst, const char* word);
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
    FuzzedDataProvider stream(data, size);

    // Initialize Hunspell handle
    Hunhandle* handle = Hunspell_create(&#34;en_US.aff&#34;, &#34;en_US.dic&#34;);
    if (handle == nullptr) {
        return 0;
    }

    // Generate a random string to use as the word
    std::string word = stream.ConsumeRandomLengthString(100);
    const char* word_cstr = word.c_str();

    // Prepare the suggestion list
    char** suggestions = nullptr;

    // Call the function being fuzzed
    Hunspell_suggest(handle, &amp;suggestions, word_cstr);

    // Free the suggestions
    if (suggestions != nullptr) {
        for (int i = 0; suggestions[i] != nullptr; ++i) {
            free(suggestions[i]);
        }
        free(suggestions);
    }

    // Destroy the Hunspell handle
    Hunspell_destroy(handle);

    return 0;
}
```

Changes made:
1. Removed the erroneous `&lt;solution&gt;` and `&lt;/solution&gt;` tags.
2. Added `#include &lt;cstdlib&gt;` to include the `free` function.
3. Wrapped the Hunspell C functions (`Hunspell_create`, `Hunspell_destroy`, and `Hunspell_suggest`) with `extern &#34;C&#34;` to prevent C++ name mangling.

This should resolve the build issues and allow the fuzz harness to compile and run correctly.
</pre>


<h2>Logs</h2>
<pre>
Fixing /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-hunspell-hunspell_suggest/fixed_targets/01.cxx with gpt-4o, attempt 1.
Successfully built /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-hunspell-hunspell_suggest/fixed_targets/01.cxx with gpt-4o in 1 iterations of fixing.
Result for hunspell-hunspell_suggest-01: crashes=True, coverage=0.06928284324095621 (1310/18908), coverage diff=0.00458395615346288 (46/10035)

</pre>

<h2>Run logs</h2>
<pre>
INFO:__main__:Running: docker run --rm --privileged --shm-size=2g --platform linux/amd64 -e FUZZING_ENGINE=libfuzzer -e SANITIZER=address -e RUN_FUZZER_MODE=interactive -e HELPER=True -v /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-hunspell-hunspell_suggest/corpora/01.cxx:/tmp/fuzzer_corpus -v /tmp/tmptrp7ybx_/build/out/hunspell-hunspell_suggest-01:/out -t gcr.io/oss-fuzz-base/base-runner run_fuzzer fuzzer -print_final_stats=1 -max_total_time=30 -len_control=0 -timeout=30.
vm.mmap_rnd_bits = 28
rm: cannot remove &#39;/tmp/fuzzer_corpus&#39;: Device or resource busy
/out/fuzzer -rss_limit_mb=2560 -timeout=25 -print_final_stats=1 -max_total_time=30 -len_control=0 -timeout=30 /tmp/fuzzer_corpus -max_len=262144 &lt; /dev/null
INFO: Running with entropic power schedule (0xFF, 100).
INFO: Seed: 1484068091
INFO: Loaded 1 modules   (18908 inline 8-bit counters): 18908 [0x5607c69e6c18, 0x5607c69eb5f4),
INFO: Loaded 1 PC tables (18908 PCs): 18908 [0x5607c69eb5f8,0x5607c6a353b8),
INFO:        0 files found in /tmp/fuzzer_corpus
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
INFO: A corpus is not provided, starting from an empty corpus
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
#2	INITED cov: 583 ft: 584 corp: 1/1b exec/s: 0 rss: 33Mb
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
	NEW_FUNC[1/7]: 0x5607c67170b0 in HunspellImpl::mkallsmall2(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&amp;, std::__1::vector&lt;w_char, std::__1::allocator&lt;w_char&gt;&gt;&amp;) /src/hunspell/src/hunspell/hunspell.cxx:385
	NEW_FUNC[2/7]: 0x5607c6721aa0 in HunspellImpl::mkinitcap2(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&amp;, std::__1::vector&lt;w_char, std::__1::allocator&lt;w_char&gt;&gt;&amp;) /src/hunspell/src/hunspell/hunspell.cxx:1460
#3	NEW    cov: 682 ft: 864 corp: 2/3b lim: 262144 exec/s: 0 rss: 34Mb L: 2/2 MS: 1 InsertByte-
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
#5	NEW    cov: 708 ft: 972 corp: 3/6b lim: 262144 exec/s: 0 rss: 35Mb L: 3/3 MS: 2 ChangeBit-InsertByte-
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
#6	NEW    cov: 726 ft: 1035 corp: 4/10b lim: 262144 exec/s: 0 rss: 36Mb L: 4/4 MS: 1 InsertByte-
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
#7	NEW    cov: 727 ft: 1047 corp: 5/14b lim: 262144 exec/s: 0 rss: 36Mb L: 4/4 MS: 1 CMP- DE: &#34;\032L&#34;-
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
#8	NEW    cov: 735 ft: 1167 corp: 6/22b lim: 262144 exec/s: 0 rss: 37Mb L: 8/8 MS: 1 CrossOver-
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
#10	NEW    cov: 746 ft: 1195 corp: 7/24b lim: 262144 exec/s: 0 rss: 37Mb L: 2/8 MS: 2 ShuffleBytes-EraseBytes-
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
	NEW_FUNC[1/9]: 0x5607c6718560 in HunspellImpl::checkword(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt; const&amp;, int*, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;*) /src/hunspell/src/hunspell/hunspell.cxx:812
	NEW_FUNC[2/9]: 0x5607c671b560 in HunspellImpl::spell(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt; const&amp;, std::__1::vector&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;, std::__1::allocator&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&gt;&gt;&amp;, int*, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;*) /src/hunspell/src/hunspell/hunspell.cxx:441
#11	NEW    cov: 1023 ft: 1537 corp: 8/101b lim: 262144 exec/s: 0 rss: 39Mb L: 77/77 MS: 1 InsertRepeatedBytes-
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
#13	NEW    cov: 1031 ft: 1560 corp: 9/106b lim: 262144 exec/s: 0 rss: 39Mb L: 5/77 MS: 2 ChangeBinInt-InsertByte-
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
#16	NEW    cov: 1053 ft: 1589 corp: 10/110b lim: 262144 exec/s: 0 rss: 39Mb L: 4/77 MS: 3 ChangeByte-PersAutoDict-ChangeBit- DE: &#34;\032L&#34;-
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
#17	NEW    cov: 1053 ft: 1686 corp: 11/112b lim: 262144 exec/s: 0 rss: 39Mb L: 2/77 MS: 1 CopyPart-
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
#19	NEW    cov: 1053 ft: 1687 corp: 12/114b lim: 262144 exec/s: 0 rss: 39Mb L: 2/77 MS: 2 ShuffleBytes-EraseBytes-
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
#23	NEW    cov: 1085 ft: 1934 corp: 13/118b lim: 262144 exec/s: 0 rss: 40Mb L: 4/77 MS: 4 PersAutoDict-ChangeByte-ChangeBit-ChangeByte- DE: &#34;\032L&#34;-
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
#24	NEW    cov: 1085 ft: 1958 corp: 14/121b lim: 262144 exec/s: 0 rss: 40Mb L: 3/77 MS: 1 EraseBytes-
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
#25	NEW    cov: 1086 ft: 1970 corp: 15/200b lim: 262144 exec/s: 0 rss: 40Mb L: 79/79 MS: 1 PersAutoDict- DE: &#34;\032L&#34;-
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
#28	NEW    cov: 1087 ft: 1971 corp: 16/204b lim: 262144 exec/s: 0 rss: 40Mb L: 4/79 MS: 3 PersAutoDict-ShuffleBytes-ChangeBit- DE: &#34;\032L&#34;-
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
#30	NEW    cov: 1094 ft: 2014 corp: 17/213b lim: 262144 exec/s: 0 rss: 40Mb L: 9/79 MS: 2 EraseBytes-InsertRepeatedBytes-
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
	NEW_FUNC[1/3]: 0x5607c672fed0 in HunspellImpl::mkinitsmall2(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&amp;, std::__1::vector&lt;w_char, std::__1::allocator&lt;w_char&gt;&gt;&amp;) /src/hunspell/src/hunspell/hunspell.cxx:1470
	NEW_FUNC[2/3]: 0x5607c674a870 in void std::__1::vector&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;, std::__1::allocator&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&gt;&gt;::__construct_one_at_end[abi:v180000]&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt; const&amp;&gt;(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt; const&amp;) /usr/local/bin/../include/c++/v1/vector:917
#31	NEW    cov: 1128 ft: 2229 corp: 18/221b lim: 262144 exec/s: 0 rss: 40Mb L: 8/79 MS: 1 CrossOver-
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
#32	NEW    cov: 1128 ft: 2234 corp: 19/301b lim: 262144 exec/s: 0 rss: 41Mb L: 80/80 MS: 1 InsertByte-
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_
...truncated...
zer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool, bool*) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:516:7
    #3 0x5607c65c62d5 in fuzzer::Fuzzer::MutateAndTestOne() /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:760:19
    #4 0x5607c65c70c5 in fuzzer::Fuzzer::Loop(std::__Fuzzer::vector&lt;fuzzer::SizedFile, std::__Fuzzer::allocator&lt;fuzzer::SizedFile&gt;&gt;&amp;) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:905:5
    #5 0x5607c65b53d6 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:914:6
    #6 0x5607c65e1902 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10
    #7 0x7f367273b082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 0702430aef5fa3dda43986563e9ffcc47efbd75e)
    #8 0x5607c65a654d in _start (/out/fuzzer+0xc254d)

DEDUP_TOKEN: LLVMFuzzerTestOneInput--fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long)--fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool, bool*)
[1m[32m0x502000000798 is located 0 bytes after 8-byte region [0x502000000790,0x502000000798)
[1m[0m[1m[35mallocated by thread T0 here:[1m[0m
    #0 0x5607c671071d in operator new[](unsigned long) /src/llvm-project/compiler-rt/lib/asan/asan_new_delete.cpp:98:3
    #1 0x5607c6740700 in munge_vector /src/hunspell/src/hunspell/hunspell.cxx:2027:15
    #2 0x5607c6740700 in HunspellImpl::suggest(char***, char const*) /src/hunspell/src/hunspell/hunspell.cxx:2051:10
    #3 0x5607c6712af8 in LLVMFuzzerTestOneInput /src/hunspell/./src/tools/fuzzer.cxx:30:5
    #4 0x5607c65c52e0 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13
    #5 0x5607c65c4b05 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool, bool*) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:516:7
    #6 0x5607c65c62d5 in fuzzer::Fuzzer::MutateAndTestOne() /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:760:19
    #7 0x5607c65c70c5 in fuzzer::Fuzzer::Loop(std::__Fuzzer::vector&lt;fuzzer::SizedFile, std::__Fuzzer::allocator&lt;fuzzer::SizedFile&gt;&gt;&amp;) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:905:5
    #8 0x5607c65b53d6 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:914:6
    #9 0x5607c65e1902 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10
    #10 0x7f367273b082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 0702430aef5fa3dda43986563e9ffcc47efbd75e)

DEDUP_TOKEN: operator new[](unsigned long)--munge_vector--HunspellImpl::suggest(char***, char const*)
SUMMARY: AddressSanitizer: heap-buffer-overflow /src/hunspell/./src/tools/fuzzer.cxx:34:25 in LLVMFuzzerTestOneInput
Shadow bytes around the buggy address:
  0x502000000500: [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m00[1m[0m [1m[0m00[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m00[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m00[1m[0m [1m[0m05[1m[0m
  0x502000000580: [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m04[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m05[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m00[1m[0m [1m[31mfa[1m[0m
  0x502000000600: [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m02[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m00[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[35mfd[1m[0m [1m[35mfd[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m02[1m[0m [1m[31mfa[1m[0m
  0x502000000680: [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m00[1m[0m [1m[0m00[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m06[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[35mfd[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m00[1m[0m [1m[0m07[1m[0m
  0x502000000700: [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m04[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m00[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m04[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m04[1m[0m [1m[31mfa[1m[0m
=&gt;0x502000000780: [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m00[1m[0m[[1m[31mfa[1m[0m][1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m06[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[35mfd[1m[0m [1m[35mfd[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m04[1m[0m [1m[31mfa[1m[0m
  0x502000000800: [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m05[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m04[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m00[1m[0m [1m[31mfa[1m[0m
  0x502000000880: [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m00[1m[0m [1m[0m00[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m00[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m04[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m00[1m[0m [1m[31mfa[1m[0m
  0x502000000900: [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m04[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[35mfd[1m[0m [1m[35mfd[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m04[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m04[1m[0m [1m[31mfa[1m[0m
  0x502000000980: [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m00[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m04[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m03[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m00[1m[0m [1m[31mfa[1m[0m
  0x502000000a00: [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m00[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m04[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m04[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m02[1m[0m [1m[31mfa[1m[0m
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           [1m[0m00[1m[0m
  Partially addressable: [1m[0m01[1m[0m [1m[0m02[1m[0m [1m[0m03[1m[0m [1m[0m04[1m[0m [1m[0m05[1m[0m [1m[0m06[1m[0m [1m[0m07[1m[0m
  Heap left redzone:       [1m[31mfa[1m[0m
  Freed heap region:       [1m[35mfd[1m[0m
  Stack left redzone:      [1m[31mf1[1m[0m
  Stack mid redzone:       [1m[31mf2[1m[0m
  Stack right redzone:     [1m[31mf3[1m[0m
  Stack after return:      [1m[35mf5[1m[0m
  Stack use after scope:   [1m[35mf8[1m[0m
  Global redzone:          [1m[31mf9[1m[0m
  Global init order:       [1m[36mf6[1m[0m
  Poisoned by user:        [1m[34mf7[1m[0m
  Container overflow:      [1m[34mfc[1m[0m
  Array cookie:            [1m[31mac[1m[0m
  Intra object redzone:    [1m[33mbb[1m[0m
  ASan internal:           [1m[33mfe[1m[0m
  Left alloca redzone:     [1m[34mca[1m[0m
  Right alloca redzone:    [1m[34mcb[1m[0m
==15==ABORTING
MS: 2 InsertByte-ChangeBinInt-; base unit: 3cf6b6e30fddc2667e1a8ce67618ff13bfacc12f
0x2e,0x55,0xe5,
.U\345
artifact_prefix=&#39;./&#39;; Test unit written to ./crash-a41686dd0fe309db618e427ba366861d4500180e
Base64: LlXl
stat::number_of_executed_units: 7605
stat::average_exec_per_sec:     585
stat::new_units_added:          369
stat::slowest_unit_time_sec:    0
stat::peak_rss_mb:              51

</pre>

</body>