<!doctype html>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Experiment results</title>
<style>
* {
    box-sizing: border-box;
}

html {
    line-height: 1.15;
}

body {
    font-family: sans-serif;
    font-size: 16px;
}

table {
    border-collapse: collapse;
    border-spacing: 0;
}

td, th {
    border-right: 1px #dedede solid;
    border-bottom: 1px #dedede solid;
    padding: 5px;
    text-align: left;
}
td:first-child, th:first-child {
    border-left: 1px #dedede solid;
}
th {
    border-top: 1px #dedede solid;
}

tbody tr:nth-child(odd) {
    background-color: #f4f5ff;
}
</style>
<body>
    LLM:

<h1>output-libusb-libusb_get_string_descriptor_ascii / 02</h1>
Bug: False
<br>
Crash reason: NO_SEMANTIC_ERR
<br>
<br>

<h2>Triage</h2>
<pre>

</pre>
<br>





<h3>Final code</h3>

<pre>
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;

extern &#34;C&#34; {
#include &#34;libusb.h&#34;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    libusb_init(NULL);
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    if (size &lt; sizeof(uintptr_t) + sizeof(uint8_t) + sizeof(int)) {
        return 0;
    }

    FuzzedDataProvider fuzzed_data(data, size);

    libusb_device_handle *dev_handle = nullptr;
    libusb_device **devs;
    ssize_t cnt = libusb_get_device_list(NULL, &amp;devs);
    if (cnt &lt; 0) {
        return 0;
    }

    for (ssize_t i = 0; i &lt; cnt; i++) {
        libusb_device *dev = devs[i];
        libusb_open(dev, &amp;dev_handle);
        if (dev_handle != nullptr) {
            break;
        }
    }

    libusb_free_device_list(devs, 1);

    uint8_t desc_index = fuzzed_data.ConsumeIntegral&lt;uint8_t&gt;();
    int length = fuzzed_data.ConsumeIntegralInRange&lt;int&gt;(1, 255);
    unsigned char *buffer = static_cast&lt;unsigned char *&gt;(malloc(length));

    if (buffer == nullptr) {
        if (dev_handle != nullptr) {
            libusb_close(dev_handle);
        }
        return 0;
    }

    if (dev_handle != nullptr) {
        int result = libusb_get_string_descriptor_ascii(dev_handle, desc_index, buffer, length);
        (void)result; // Suppress unused variable warning
        libusb_close(dev_handle);
    }

    free(buffer);

    return 0;
}
</pre>


<h3>Fixer prompt #1</h3>
<pre>

Given the following C++ fuzz harness and its build error message, fix the code to make it build for fuzzing.

If there is undeclared identifier or unknown type name error, fix it by finding and including the related libraries.

You MUST wrap the headers with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; if they are C headers, especially the headers are from the project.

Note that some code may need to be wrapped with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; as their source is C program.

MUST RETURN THE FULL CODE, INCLUDING UNCHANGED PARTS.
EXTREMELY IMPORTANT: AVOID USING &lt;code&gt;goto&lt;/code&gt;. If you have to write code using &lt;code&gt;goto&lt;/code&gt;, you MUST MUST also declare all variables BEFORE the &lt;code&gt;goto&lt;/code&gt;. Never introduce new variables after the &lt;code&gt;goto&lt;/code&gt;.

Below is the code needs to be built:
&lt;code&gt;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;

extern &#34;C&#34; {
#include &#34;libusb.h&#34;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    libusb_init(NULL);
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    FuzzedDataProvider fuzzed_data(data, size);

    libusb_device_handle *dev_handle = reinterpret_cast&lt;libusb_device_handle *&gt;(fuzzed_data.ConsumeIntegral&lt;uintptr_t&gt;());
    uint8_t desc_index = fuzzed_data.ConsumeIntegral&lt;uint8_t&gt;();
    int length = fuzzed_data.ConsumeIntegralInRange&lt;int&gt;(1, 255);
    unsigned char *buffer = static_cast&lt;unsigned char *&gt;(malloc(length));

    if (buffer == nullptr) {
        return 0;
    }

    int result = libusb_get_string_descriptor_ascii(dev_handle, desc_index, buffer, length);

    free(buffer);

    return 0;
}
&lt;/code&gt;

The code can build successfully but has a runtime issue: Fuzzing crashed immediately at runtime (ASAN-ERROR: AddressSanitizer: SEGV on unknown address (pc 0x5573722875dd bp 0x7ffc30696600 sp 0x7ffc30696540 T0)), indicating fuzz target code for invoking the function under test is incorrect or unrobust.
&lt;error&gt;
Crash stacks:
Stack 0:
#0 0x5573722875dd in libusb_control_transfer /src/libusb/libusb/sync.c:112:27
#1 0x55737227a62e in libusb_get_string_descriptor /src/libusb/libusb/./libusb.h:2194:9
#2 0x55737227a62e in libusb_get_string_descriptor_ascii /src/libusb/libusb/descriptor.c:1268:6
#3 0x55737226bee5 in LLVMFuzzerTestOneInput /src/jcc-corrected-libusb_fuzzer.cc:29:18
#4 0x55737211e660 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13
#5 0x55737211de85 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool, bool*) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:516:7
#6 0x55737211f655 in fuzzer::Fuzzer::MutateAndTestOne() /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:760:19
#7 0x557372120445 in fuzzer::Fuzzer::Loop(std::__Fuzzer::vector&lt;fuzzer::SizedFile, std::__Fuzzer::allocator&lt;fuzzer::SizedFile&gt;&gt;&amp;) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:905:5
#8 0x55737210e756 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:914:6
#9 0x55737213ac82 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10
#10 0x7f8cedc15082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 0702430aef5fa3dda43986563e9ffcc47efbd75e)
#11 0x5573720ff8cd in _start (/out/libusb_fuzzer+0x578cd)
&lt;/error&gt;

Fix code:
1. Consider possible solutions for the issues listed above.
2. Choose a solution that can maximize fuzzing result, which is utilizing the function under test and feeding it not null input.
3. Apply the solutions to the original code.
It&#39;s important to show the complete code, not only the fixed line.
&lt;solution&gt;
</pre>



<h3>Code #1</h3>

<pre>
Here&#39;s the complete code with the necessary fixes applied to address the runtime issue:

```cpp
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;

extern &#34;C&#34; {
#include &#34;libusb.h&#34;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    libusb_init(NULL);
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    if (size &lt; sizeof(uintptr_t) + sizeof(uint8_t) + sizeof(int)) {
        return 0;
    }

    FuzzedDataProvider fuzzed_data(data, size);

    libusb_device_handle *dev_handle = reinterpret_cast&lt;libusb_device_handle *&gt;(fuzzed_data.ConsumeIntegral&lt;uintptr_t&gt;());
    uint8_t desc_index = fuzzed_data.ConsumeIntegral&lt;uint8_t&gt;();
    int length = fuzzed_data.ConsumeIntegralInRange&lt;int&gt;(1, 255);
    unsigned char *buffer = static_cast&lt;unsigned char *&gt;(malloc(length));

    if (buffer == nullptr) {
        return 0;
    }

    if (dev_handle != nullptr) {
        int result = libusb_get_string_descriptor_ascii(dev_handle, desc_index, buffer, length);
        (void)result; // Suppress unused variable warning
    }

    free(buffer);

    return 0;
}
```

### Explanation of the Fixes:

1. **Input Size Check**:
   - Added a check at the beginning of `LLVMFuzzerTestOneInput` to ensure that the provided data is large enough to contain all the necessary parts (a `uintptr_t`, a `uint8_t`, and an `int`). This prevents potential out-of-bounds access when consuming data.

2. **Null Check for `dev_handle`**:
   - Added a check to ensure that `dev_handle` is not `nullptr` before calling `libusb_get_string_descriptor_ascii`. This prevents dereferencing a null pointer, which was causing the segmentation fault.

3. **Suppress Unused Variable Warning**:
   - Suppressed the unused variable warning for `result` by casting it to `(void)result;`. This ensures that the variable is used even if we don&#39;t do anything with its value.

These changes ensure that the fuzzing harness is more robust and prevents the immediate crash due to invalid memory access.
</pre>


<h3>Fixer prompt #2</h3>
<pre>

Given the following C++ fuzz harness and its build error message, fix the code to make it build for fuzzing.

If there is undeclared identifier or unknown type name error, fix it by finding and including the related libraries.

You MUST wrap the headers with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; if they are C headers, especially the headers are from the project.

Note that some code may need to be wrapped with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; as their source is C program.

MUST RETURN THE FULL CODE, INCLUDING UNCHANGED PARTS.
EXTREMELY IMPORTANT: AVOID USING &lt;code&gt;goto&lt;/code&gt;. If you have to write code using &lt;code&gt;goto&lt;/code&gt;, you MUST MUST also declare all variables BEFORE the &lt;code&gt;goto&lt;/code&gt;. Never introduce new variables after the &lt;code&gt;goto&lt;/code&gt;.

Below is the code needs to be built:
&lt;code&gt;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;

extern &#34;C&#34; {
#include &#34;libusb.h&#34;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    libusb_init(NULL);
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    if (size &lt; sizeof(uintptr_t) + sizeof(uint8_t) + sizeof(int)) {
        return 0;
    }

    FuzzedDataProvider fuzzed_data(data, size);

    libusb_device_handle *dev_handle = reinterpret_cast&lt;libusb_device_handle *&gt;(fuzzed_data.ConsumeIntegral&lt;uintptr_t&gt;());
    uint8_t desc_index = fuzzed_data.ConsumeIntegral&lt;uint8_t&gt;();
    int length = fuzzed_data.ConsumeIntegralInRange&lt;int&gt;(1, 255);
    unsigned char *buffer = static_cast&lt;unsigned char *&gt;(malloc(length));

    if (buffer == nullptr) {
        return 0;
    }

    if (dev_handle != nullptr) {
        int result = libusb_get_string_descriptor_ascii(dev_handle, desc_index, buffer, length);
        (void)result; // Suppress unused variable warning
    }

    free(buffer);

    return 0;
}
&lt;/code&gt;

The code can build successfully but has a runtime issue: Fuzzing crashed immediately at runtime (ASAN-ERROR: AddressSanitizer: SEGV on unknown address (pc 0x5648ddd4d60d bp 0x7ffe19e131e0 sp 0x7ffe19e13120 T0)), indicating fuzz target code for invoking the function under test is incorrect or unrobust.
&lt;error&gt;
Crash stacks:
Stack 0:
#0 0x5648ddd4d60d in libusb_control_transfer /src/libusb/libusb/sync.c:112:27
#1 0x5648ddd4065e in libusb_get_string_descriptor /src/libusb/libusb/./libusb.h:2194:9
#2 0x5648ddd4065e in libusb_get_string_descriptor_ascii /src/libusb/libusb/descriptor.c:1268:6
#3 0x5648ddd31f16 in LLVMFuzzerTestOneInput /src/jcc-corrected-libusb_fuzzer.cc:34:22
#4 0x5648ddbe4660 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13
#5 0x5648ddbe3e85 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool, bool*) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:516:7
#6 0x5648ddbe5655 in fuzzer::Fuzzer::MutateAndTestOne() /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:760:19
#7 0x5648ddbe6445 in fuzzer::Fuzzer::Loop(std::__Fuzzer::vector&lt;fuzzer::SizedFile, std::__Fuzzer::allocator&lt;fuzzer::SizedFile&gt;&gt;&amp;) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:905:5
#8 0x5648ddbd4756 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:914:6
#9 0x5648ddc00c82 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10
#10 0x7f02674c4082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 0702430aef5fa3dda43986563e9ffcc47efbd75e)
#11 0x5648ddbc58cd in _start (/out/libusb_fuzzer+0x578cd)
&lt;/error&gt;

Fix code:
1. Consider possible solutions for the issues listed above.
2. Choose a solution that can maximize fuzzing result, which is utilizing the function under test and feeding it not null input.
3. Apply the solutions to the original code.
It&#39;s important to show the complete code, not only the fixed line.
&lt;solution&gt;
</pre>



<h3>Code #2</h3>

<pre>
To address the runtime issue, we need to ensure that the `libusb_device_handle` is valid before passing it to `libusb_get_string_descriptor_ascii`. We can achieve this by properly initializing a `libusb_device_handle` and ensuring that the device is correctly opened.

Here is the fixed code:

```cpp
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;

extern &#34;C&#34; {
#include &#34;libusb.h&#34;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    libusb_init(NULL);
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    if (size &lt; sizeof(uintptr_t) + sizeof(uint8_t) + sizeof(int)) {
        return 0;
    }

    FuzzedDataProvider fuzzed_data(data, size);

    libusb_device_handle *dev_handle = nullptr;
    libusb_device **devs;
    ssize_t cnt = libusb_get_device_list(NULL, &amp;devs);
    if (cnt &lt; 0) {
        return 0;
    }

    for (ssize_t i = 0; i &lt; cnt; i++) {
        libusb_device *dev = devs[i];
        libusb_open(dev, &amp;dev_handle);
        if (dev_handle != nullptr) {
            break;
        }
    }

    libusb_free_device_list(devs, 1);

    uint8_t desc_index = fuzzed_data.ConsumeIntegral&lt;uint8_t&gt;();
    int length = fuzzed_data.ConsumeIntegralInRange&lt;int&gt;(1, 255);
    unsigned char *buffer = static_cast&lt;unsigned char *&gt;(malloc(length));

    if (buffer == nullptr) {
        if (dev_handle != nullptr) {
            libusb_close(dev_handle);
        }
        return 0;
    }

    if (dev_handle != nullptr) {
        int result = libusb_get_string_descriptor_ascii(dev_handle, desc_index, buffer, length);
        (void)result; // Suppress unused variable warning
        libusb_close(dev_handle);
    }

    free(buffer);

    return 0;
}
```

### Explanation:
1. **Device List Initialization**: We use `libusb_get_device_list` to get a list of USB devices.
2. **Device Handle Initialization**: We iterate through the list of devices and attempt to open each one using `libusb_open`. If a device handle is successfully opened, we break out of the loop.
3. **Buffer Allocation**: We allocate memory for the buffer to store the descriptor.
4. **Descriptor Fetching**: We call `libusb_get_string_descriptor_ascii` only if a valid device handle is obtained.
5. **Resource Cleanup**: We ensure that the device handle is closed and the buffer is freed to prevent memory leaks.

This approach ensures that the `libusb_device_handle` is valid and properly initialized before it is used, thus preventing the segmentation fault observed during fuzzing.
</pre>


<h2>Logs</h2>
<pre>
Fixing /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-libusb-libusb_get_string_descriptor_ascii/fixed_targets/02.cc with gpt-4o, attempt 1.
Fixing /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-libusb-libusb_get_string_descriptor_ascii/fixed_targets/02.cc with gpt-4o, attempt 2.
Successfully built /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-libusb-libusb_get_string_descriptor_ascii/fixed_targets/02.cc with gpt-4o in 2 iterations of fixing.
Triaging the crash related to /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-libusb-libusb_get_string_descriptor_ascii/fixed_targets/02.cc with gpt-4o.
Warning: no crash info in libusb-libusb_get_string_descriptor_ascii-02.
Result for libusb-libusb_get_string_descriptor_ascii-02: crashes=False, coverage=0.07689320388349515 (198/2575), coverage diff=0.25199645075421473 (1420/5635)

</pre>

<h2>Run logs</h2>
<pre>
INFO:__main__:Running: docker run --rm --privileged --shm-size=2g --platform linux/amd64 -e FUZZING_ENGINE=libfuzzer -e SANITIZER=address -e RUN_FUZZER_MODE=interactive -e HELPER=True -v /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-libusb-libusb_get_string_descriptor_ascii/corpora/02.cc:/tmp/libusb_fuzzer_corpus -v /tmp/tmpqe63huln/build/out/libusb-libusb_get_string_descriptor_ascii-02:/out -t gcr.io/oss-fuzz-base/base-runner run_fuzzer libusb_fuzzer -print_final_stats=1 -max_total_time=30 -len_control=0 -timeout=30.
vm.mmap_rnd_bits = 28
rm: cannot remove &#39;/tmp/libusb_fuzzer_corpus&#39;: Device or resource busy
/out/libusb_fuzzer -rss_limit_mb=2560 -timeout=25 -print_final_stats=1 -max_total_time=30 -len_control=0 -timeout=30 /tmp/libusb_fuzzer_corpus &lt; /dev/null
INFO: Running with entropic power schedule (0xFF, 100).
INFO: Seed: 4191924978
INFO: Loaded 1 modules   (2575 inline 8-bit counters): 2575 [0x558673962dc0, 0x5586739637cf),
INFO: Loaded 1 PC tables (2575 PCs): 2575 [0x5586739637d0,0x55867396d8c0),
INFO:        0 files found in /tmp/libusb_fuzzer_corpus
INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes
INFO: A corpus is not provided, starting from an empty corpus
#2	INITED cov: 2 ft: 2 corp: 1/1b exec/s: 0 rss: 32Mb
	NEW_FUNC[1/41]: 0x5586738ba1c0 in discovered_devs_append /src/libusb/libusb/core.c:676
	NEW_FUNC[2/41]: 0x5586738ba4e0 in libusb_ref_device /src/libusb/libusb/core.c:1274
#5	NEW    cov: 186 ft: 187 corp: 2/101b lim: 4096 exec/s: 5 rss: 33Mb L: 100/100 MS: 2 ShuffleBytes-InsertRepeatedBytes-
#6	NEW    cov: 188 ft: 189 corp: 3/201b lim: 4096 exec/s: 6 rss: 33Mb L: 100/100 MS: 1 ChangeByte-
#29	REDUCE cov: 188 ft: 189 corp: 3/185b lim: 4096 exec/s: 14 rss: 33Mb L: 84/100 MS: 3 ChangeByte-ChangeBit-EraseBytes-
#32	pulse  cov: 188 ft: 189 corp: 3/185b lim: 4096 exec/s: 16 rss: 33Mb
#48	NEW    cov: 191 ft: 195 corp: 4/253b lim: 4096 exec/s: 24 rss: 33Mb L: 68/100 MS: 4 CopyPart-ChangeBit-ChangeBinInt-CrossOver-
#64	pulse  cov: 191 ft: 195 corp: 4/253b lim: 4096 exec/s: 21 rss: 33Mb
#66	NEW    cov: 193 ft: 205 corp: 5/315b lim: 4096 exec/s: 22 rss: 33Mb L: 62/100 MS: 2 CMP-InsertRepeatedBytes- DE: &#34;\001\000\000\000&#34;-
#72	REDUCE cov: 193 ft: 205 corp: 5/301b lim: 4096 exec/s: 24 rss: 33Mb L: 48/100 MS: 3 ShuffleBytes-ChangeBinInt-EraseBytes-
#74	NEW    cov: 194 ft: 206 corp: 6/339b lim: 4096 exec/s: 24 rss: 33Mb L: 38/100 MS: 2 ChangeBit-CrossOver-
#128	pulse  cov: 194 ft: 206 corp: 6/339b lim: 4096 exec/s: 21 rss: 33Mb
#165	REDUCE cov: 194 ft: 206 corp: 6/321b lim: 4096 exec/s: 27 rss: 34Mb L: 50/100 MS: 3 InsertByte-InsertByte-EraseBytes-
#180	REDUCE cov: 194 ft: 206 corp: 6/302b lim: 4096 exec/s: 25 rss: 34Mb L: 65/100 MS: 5 InsertRepeatedBytes-ChangeBit-InsertByte-ChangeBit-EraseBytes-
#212	REDUCE cov: 194 ft: 206 corp: 6/289b lim: 4096 exec/s: 23 rss: 34Mb L: 35/100 MS: 1 EraseBytes-
#213	REDUCE cov: 194 ft: 207 corp: 7/339b lim: 4096 exec/s: 23 rss: 34Mb L: 50/100 MS: 1 ChangeBit-
#226	NEW    cov: 194 ft: 208 corp: 8/378b lim: 4096 exec/s: 25 rss: 34Mb L: 39/100 MS: 1 EraseBytes-
#238	REDUCE cov: 194 ft: 208 corp: 8/374b lim: 4096 exec/s: 23 rss: 34Mb L: 31/100 MS: 1 EraseBytes-
#265	REDUCE cov: 194 ft: 208 corp: 8/359b lim: 4096 exec/s: 24 rss: 34Mb L: 16/100 MS: 1 EraseBytes-
#273	REDUCE cov: 194 ft: 208 corp: 8/354b lim: 4096 exec/s: 24 rss: 34Mb L: 45/100 MS: 3 ChangeBit-PersAutoDict-EraseBytes- DE: &#34;\001\000\000\000&#34;-
#331	REDUCE cov: 194 ft: 208 corp: 8/339b lim: 4096 exec/s: 23 rss: 34Mb L: 30/100 MS: 1 EraseBytes-
#351	REDUCE cov: 194 ft: 208 corp: 8/319b lim: 4096 exec/s: 23 rss: 34Mb L: 45/100 MS: 1 EraseBytes-
#383	REDUCE cov: 194 ft: 208 corp: 8/307b lim: 4096 exec/s: 23 rss: 34Mb L: 18/100 MS: 4 CrossOver-ChangeByte-ShuffleBytes-EraseBytes-
#426	REDUCE cov: 198 ft: 212 corp: 9/325b lim: 4096 exec/s: 23 rss: 35Mb L: 18/100 MS: 4 ChangeBinInt-CMP-CrossOver-CopyPart- DE: &#34;\020\000\000\000\000\000\000\000&#34;-
#512	pulse  cov: 198 ft: 212 corp: 9/325b lim: 4096 exec/s: 23 rss: 35Mb
#522	REDUCE cov: 198 ft: 212 corp: 9/316b lim: 4096 exec/s: 23 rss: 35Mb L: 36/100 MS: 2 ChangeBinInt-EraseBytes-
#621	REDUCE cov: 198 ft: 213 corp: 10/373b lim: 4096 exec/s: 24 rss: 35Mb L: 57/100 MS: 1 CrossOver-
#758	DONE   cov: 198 ft: 213 corp: 10/373b lim: 4096 exec/s: 24 rss: 35Mb
###### Recommended dictionary. ######
&#34;\001\000\000\000&#34; # Uses: 42
&#34;\020\000\000\000\000\000\000\000&#34; # Uses: 11
###### End of recommended dictionary. ######
Done 758 runs in 31 second(s)
stat::number_of_executed_units: 758
stat::average_exec_per_sec:     24
stat::new_units_added:          21
stat::slowest_unit_time_sec:    0
stat::peak_rss_mb:              35

</pre>


</body>