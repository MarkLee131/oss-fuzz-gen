<!doctype html>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Experiment results</title>
<style>
* {
    box-sizing: border-box;
}

html {
    line-height: 1.15;
}

body {
    font-family: sans-serif;
    font-size: 16px;
}

table {
    border-collapse: collapse;
    border-spacing: 0;
}

td, th {
    border-right: 1px #dedede solid;
    border-bottom: 1px #dedede solid;
    padding: 5px;
    text-align: left;
}
td:first-child, th:first-child {
    border-left: 1px #dedede solid;
}
th {
    border-top: 1px #dedede solid;
}

tbody tr:nth-child(odd) {
    background-color: #f4f5ff;
}
</style>
<body>
    LLM:

<h1>output-eigen-_zn5eigen6matrixidlin1elin1eli0elin1elin1eed2ev / 03</h1>
Bug: False
<br>
Crash reason: NO_SEMANTIC_ERR
<br>
<br>

<h2>Triage</h2>
<pre>

</pre>
<br>





<h3>Final code</h3>

<pre>
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;Eigen/Core&gt;
#include &lt;Eigen/Dense&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;

extern &#34;C&#34; {
    // If these are C headers from the project, they should be wrapped in extern &#34;C&#34;
    // However, Eigen is a C++ library, so no need to wrap these includes in extern &#34;C&#34;
    // #include &#34;Eigen/Core&#34;
    // #include &#34;Eigen/Dense&#34;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    FuzzedDataProvider provider(data, size);

    // Create a dynamic matrix with dimensions within a reasonable range
    int rows = provider.ConsumeIntegralInRange&lt;int&gt;(1, 100);
    int cols = provider.ConsumeIntegralInRange&lt;int&gt;(1, 100);
    Eigen::Matrix&lt;int, Eigen::Dynamic, Eigen::Dynamic&gt; matrix(rows, cols);

    // Populate the matrix with integers from the fuzzed data
    for (int i = 0; i &lt; matrix.rows(); ++i) {
        for (int j = 0; j &lt; matrix.cols(); ++j) {
            matrix(i, j) = provider.ConsumeIntegral&lt;int&gt;();
        }
    }

    // No need to manually call the destructor or delete the matrix as it will be
    // automatically cleaned up when it goes out of scope.

    return 0;
}
</pre>


<h3>Fixer prompt #1</h3>
<pre>

Given the following C++ fuzz harness and its build error message, fix the code to make it build for fuzzing.

If there is undeclared identifier or unknown type name error, fix it by finding and including the related libraries.

You MUST wrap the headers with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; if they are C headers, especially the headers are from the project.

Note that some code may need to be wrapped with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; as their source is C program.

MUST RETURN THE FULL CODE, INCLUDING UNCHANGED PARTS.
EXTREMELY IMPORTANT: AVOID USING &lt;code&gt;goto&lt;/code&gt;. If you have to write code using &lt;code&gt;goto&lt;/code&gt;, you MUST MUST also declare all variables BEFORE the &lt;code&gt;goto&lt;/code&gt;. Never introduce new variables after the &lt;code&gt;goto&lt;/code&gt;.

Below is the code needs to be built:
&lt;code&gt;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;Eigen/Core&gt;
#include &lt;Eigen/Dense&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;

extern &#34;C&#34; {
#include &#34;Eigen/Core&#34;
#include &#34;Eigen/Dense&#34;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    FuzzedDataProvider provider(data, size);

    Eigen::Matrix&lt;int, Eigen::Dynamic, Eigen::Dynamic&gt; *matrix = new Eigen::Matrix&lt;int, Eigen::Dynamic, Eigen::Dynamic&gt;(provider.ConsumeIntegralInRange&lt;int&gt;(1, 100), provider.ConsumeIntegralInRange&lt;int&gt;(1, 100));

    for (int i = 0; i &lt; matrix-&gt;rows(); ++i) {
        for (int j = 0; j &lt; matrix-&gt;cols(); ++j) {
            (*matrix)(i, j) = provider.ConsumeIntegral&lt;int&gt;();
        }
    }

    matrix-&gt;~Matrix();

    delete matrix;

    return 0;
}
&lt;/code&gt;

The code can build successfully but has a runtime issue: Fuzzing crashed immediately at runtime (ASAN-ERROR: AddressSanitizer: attempting double-free on 0x5020000000b0 in thread T0:), indicating fuzz target code for invoking the function under test is incorrect or unrobust.
&lt;error&gt;
Crash stacks:
Stack 0:
#0 0x55d87d1687d6 in free /src/llvm-project/compiler-rt/lib/asan/asan_malloc_linux.cpp:52:3
#1 0x55d87d1a803d in aligned_free /src/eigen/./Eigen/src/Core/util/Memory.h:230:5
#2 0x55d87d1a803d in conditional_aligned_free&lt;true&gt; /src/eigen/./Eigen/src/Core/util/Memory.h:294:3
#3 0x55d87d1a803d in conditional_aligned_delete_auto&lt;int, true&gt; /src/eigen/./Eigen/src/Core/util/Memory.h:504:3
#4 0x55d87d1a803d in ~DenseStorage /src/eigen/./Eigen/src/Core/DenseStorage.h:483:5
#5 0x55d87d1a803d in ~PlainObjectBase /src/eigen/./Eigen/src/Core/PlainObjectBase.h:119:7
#6 0x55d87d1a803d in LLVMFuzzerTestOneInput /src/solver_fuzzer.cc:31:5
#7 0x55d87d05a4e0 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13
#8 0x55d87d05b9e1 in fuzzer::Fuzzer::ReadAndExecuteSeedCorpora(std::__Fuzzer::vector&lt;fuzzer::SizedFile, std::__Fuzzer::allocator&lt;fuzzer::SizedFile&gt;&gt;&amp;) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:807:3
#9 0x55d87d05bfc7 in fuzzer::Fuzzer::Loop(std::__Fuzzer::vector&lt;fuzzer::SizedFile, std::__Fuzzer::allocator&lt;fuzzer::SizedFile&gt;&gt;&amp;) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:867:3
#10 0x55d87d04a5d6 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:914:6
#11 0x55d87d076b02 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10
#12 0x7f52562c8082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 0702430aef5fa3dda43986563e9ffcc47efbd75e)
#13 0x55d87d03b74d in _start (/out/solver_fuzzer+0x4474d)
Stack 1:
#0 0x55d87d1687d6 in free /src/llvm-project/compiler-rt/lib/asan/asan_malloc_linux.cpp:52:3
#1 0x55d87d1a801c in aligned_free /src/eigen/./Eigen/src/Core/util/Memory.h:230:5
#2 0x55d87d1a801c in conditional_aligned_free&lt;true&gt; /src/eigen/./Eigen/src/Core/util/Memory.h:294:3
#3 0x55d87d1a801c in conditional_aligned_delete_auto&lt;int, true&gt; /src/eigen/./Eigen/src/Core/util/Memory.h:504:3
#4 0x55d87d1a801c in ~DenseStorage /src/eigen/./Eigen/src/Core/DenseStorage.h:483:5
#5 0x55d87d1a801c in ~PlainObjectBase /src/eigen/./Eigen/src/Core/PlainObjectBase.h:119:7
#6 0x55d87d1a801c in LLVMFuzzerTestOneInput /src/solver_fuzzer.cc:29:13
#7 0x55d87d05a4e0 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13
#8 0x55d87d05b9e1 in fuzzer::Fuzzer::ReadAndExecuteSeedCorpora(std::__Fuzzer::vector&lt;fuzzer::SizedFile, std::__Fuzzer::allocator&lt;fuzzer::SizedFile&gt;&gt;&amp;) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:807:3
#9 0x55d87d05bfc7 in fuzzer::Fuzzer::Loop(std::__Fuzzer::vector&lt;fuzzer::SizedFile, std::__Fuzzer::allocator&lt;fuzzer::SizedFile&gt;&gt;&amp;) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:867:3
#10 0x55d87d04a5d6 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:914:6
#11 0x55d87d076b02 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10
&lt;/error&gt;

Fix code:
1. Consider possible solutions for the issues listed above.
2. Choose a solution that can maximize fuzzing result, which is utilizing the function under test and feeding it not null input.
3. Apply the solutions to the original code.
It&#39;s important to show the complete code, not only the fixed line.
&lt;solution&gt;
</pre>



<h3>Code #1</h3>

<pre>
Here is the corrected code that addresses the runtime issue:

```cpp
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;Eigen/Core&gt;
#include &lt;Eigen/Dense&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;

extern &#34;C&#34; {
    // If these are C headers from the project, they should be wrapped in extern &#34;C&#34;
    // However, Eigen is a C++ library, so no need to wrap these includes in extern &#34;C&#34;
    // #include &#34;Eigen/Core&#34;
    // #include &#34;Eigen/Dense&#34;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    FuzzedDataProvider provider(data, size);

    // Create a dynamic matrix with dimensions within a reasonable range
    int rows = provider.ConsumeIntegralInRange&lt;int&gt;(1, 100);
    int cols = provider.ConsumeIntegralInRange&lt;int&gt;(1, 100);
    Eigen::Matrix&lt;int, Eigen::Dynamic, Eigen::Dynamic&gt; matrix(rows, cols);

    // Populate the matrix with integers from the fuzzed data
    for (int i = 0; i &lt; matrix.rows(); ++i) {
        for (int j = 0; j &lt; matrix.cols(); ++j) {
            matrix(i, j) = provider.ConsumeIntegral&lt;int&gt;();
        }
    }

    // No need to manually call the destructor or delete the matrix as it will be
    // automatically cleaned up when it goes out of scope.

    return 0;
}
```

### Explanation of Changes:
1. **Removed Unnecessary `extern &#34;C&#34;` Wrapping for Eigen Headers:**
   - Eigen is a C++ library, so including its headers within `extern &#34;C&#34;` is unnecessary and incorrect.

2. **Changed the Matrix Allocation:**
   - Instead of using `new` to allocate the matrix, directly instantiate the matrix on the stack. This avoids manual memory management and the risk of double-free errors.

3. **Removed Manual Destructor Call and Delete:**
   - By instantiating the matrix on the stack, it will automatically be destroyed when it goes out of scope, avoiding the need for manual destructor calls and deletion.

These changes ensure that the matrix is properly managed and avoid common pitfalls related to manual memory management in C++.
</pre>


<h2>Logs</h2>
<pre>
Fixing /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-eigen-_zn5eigen6matrixidlin1elin1eli0elin1elin1eed2ev/fixed_targets/03.cc with gpt-4o, attempt 1.
Successfully built /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-eigen-_zn5eigen6matrixidlin1elin1eli0elin1elin1eed2ev/fixed_targets/03.cc with gpt-4o in 1 iterations of fixing.
Triaging the crash related to /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-eigen-_zn5eigen6matrixidlin1elin1eli0elin1elin1eed2ev/fixed_targets/03.cc with gpt-4o.
Warning: no crash info in eigen-zn5eigen6matrixidlin1elin1eli0elin1elin1eed2ev-03.
Result for eigen-zn5eigen6matrixidlin1elin1eli0elin1elin1eed2ev-03: crashes=False, coverage=0.5208333333333334 (25/48), coverage diff=0.0005509641873278236 (3/5445)

</pre>

<h2>Run logs</h2>
<pre>
INFO:__main__:Running: docker run --rm --privileged --shm-size=2g --platform linux/amd64 -e FUZZING_ENGINE=libfuzzer -e SANITIZER=address -e RUN_FUZZER_MODE=interactive -e HELPER=True -v /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-eigen-_zn5eigen6matrixidlin1elin1eli0elin1elin1eed2ev/corpora/03.cc:/tmp/solver_fuzzer_corpus -v /tmp/tmpqe63huln/build/out/eigen-zn5eigen6matrixidlin1elin1eli0elin1elin1eed2ev-03:/out -t gcr.io/oss-fuzz-base/base-runner run_fuzzer solver_fuzzer -print_final_stats=1 -max_total_time=30 -len_control=0 -timeout=30.
vm.mmap_rnd_bits = 28
rm: cannot remove &#39;/tmp/solver_fuzzer_corpus&#39;: Device or resource busy
/out/solver_fuzzer -rss_limit_mb=2560 -timeout=25 -print_final_stats=1 -max_total_time=30 -len_control=0 -timeout=30 /tmp/solver_fuzzer_corpus &lt; /dev/null
INFO: Running with entropic power schedule (0xFF, 100).
INFO: Seed: 3545495096
INFO: Loaded 1 modules   (48 inline 8-bit counters): 48 [0x563fe78cf1e0, 0x563fe78cf210),
INFO: Loaded 1 PC tables (48 PCs): 48 [0x563fe78cf210,0x563fe78cf510),
INFO:        0 files found in /tmp/solver_fuzzer_corpus
INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes
INFO: A corpus is not provided, starting from an empty corpus
#2	INITED cov: 19 ft: 20 corp: 1/1b exec/s: 0 rss: 29Mb
#3	NEW    cov: 19 ft: 23 corp: 2/2b lim: 4096 exec/s: 0 rss: 30Mb L: 1/1 MS: 1 ChangeBit-
#5	NEW    cov: 22 ft: 27 corp: 3/4b lim: 4096 exec/s: 0 rss: 30Mb L: 2/2 MS: 2 ShuffleBytes-InsertByte-
#7	NEW    cov: 23 ft: 31 corp: 4/6b lim: 4096 exec/s: 0 rss: 30Mb L: 2/2 MS: 2 ChangeBit-ChangeBinInt-
#8	NEW    cov: 23 ft: 33 corp: 5/8b lim: 4096 exec/s: 0 rss: 30Mb L: 2/2 MS: 1 CrossOver-
#10	NEW    cov: 24 ft: 34 corp: 6/12b lim: 4096 exec/s: 0 rss: 30Mb L: 4/4 MS: 2 ChangeBinInt-CopyPart-
#11	NEW    cov: 24 ft: 35 corp: 7/17b lim: 4096 exec/s: 0 rss: 30Mb L: 5/5 MS: 1 InsertByte-
#12	NEW    cov: 25 ft: 37 corp: 8/119b lim: 4096 exec/s: 0 rss: 30Mb L: 102/102 MS: 1 InsertRepeatedBytes-
#13	NEW    cov: 25 ft: 38 corp: 9/122b lim: 4096 exec/s: 0 rss: 30Mb L: 3/102 MS: 1 InsertByte-
#15	NEW    cov: 25 ft: 40 corp: 10/126b lim: 4096 exec/s: 0 rss: 30Mb L: 4/102 MS: 2 InsertByte-InsertByte-
#16	NEW    cov: 25 ft: 41 corp: 11/128b lim: 4096 exec/s: 0 rss: 30Mb L: 2/102 MS: 1 CrossOver-
#22	NEW    cov: 25 ft: 43 corp: 12/176b lim: 4096 exec/s: 0 rss: 30Mb L: 48/102 MS: 1 InsertRepeatedBytes-
#27	NEW    cov: 25 ft: 45 corp: 13/307b lim: 4096 exec/s: 0 rss: 30Mb L: 131/131 MS: 5 CrossOver-InsertRepeatedBytes-ShuffleBytes-CopyPart-CrossOver-
#30	NEW    cov: 25 ft: 47 corp: 14/334b lim: 4096 exec/s: 0 rss: 30Mb L: 27/131 MS: 3 CMP-ShuffleBytes-InsertRepeatedBytes- DE: &#34;\377\377\377\377&#34;-
#34	NEW    cov: 25 ft: 48 corp: 15/389b lim: 4096 exec/s: 0 rss: 31Mb L: 55/131 MS: 4 CopyPart-CopyPart-ChangeByte-InsertRepeatedBytes-
#37	NEW    cov: 25 ft: 50 corp: 16/395b lim: 4096 exec/s: 0 rss: 31Mb L: 6/131 MS: 3 CrossOver-InsertByte-CopyPart-
#64	NEW    cov: 25 ft: 51 corp: 17/406b lim: 4096 exec/s: 0 rss: 31Mb L: 11/131 MS: 2 CrossOver-PersAutoDict- DE: &#34;\377\377\377\377&#34;-
#85	NEW    cov: 25 ft: 52 corp: 18/412b lim: 4096 exec/s: 0 rss: 31Mb L: 6/131 MS: 1 PersAutoDict- DE: &#34;\377\377\377\377&#34;-
#89	NEW    cov: 25 ft: 53 corp: 19/414b lim: 4096 exec/s: 0 rss: 31Mb L: 2/131 MS: 4 ShuffleBytes-ShuffleBytes-ChangeBit-CopyPart-
#90	NEW    cov: 25 ft: 54 corp: 20/420b lim: 4096 exec/s: 0 rss: 31Mb L: 6/131 MS: 1 CMP- DE: &#34;\000\000\000\000&#34;-
#91	NEW    cov: 25 ft: 57 corp: 21/422b lim: 4096 exec/s: 0 rss: 31Mb L: 2/131 MS: 1 ChangeBinInt-
#107	REDUCE cov: 25 ft: 57 corp: 21/420b lim: 4096 exec/s: 0 rss: 31Mb L: 2/131 MS: 1 EraseBytes-
#128	REDUCE cov: 25 ft: 57 corp: 21/403b lim: 4096 exec/s: 0 rss: 31Mb L: 38/131 MS: 1 EraseBytes-
#194	NEW    cov: 25 ft: 58 corp: 22/404b lim: 4096 exec/s: 0 rss: 32Mb L: 1/131 MS: 1 EraseBytes-
#210	REDUCE cov: 25 ft: 58 corp: 22/402b lim: 4096 exec/s: 0 rss: 32Mb L: 4/131 MS: 1 EraseBytes-
#221	NEW    cov: 25 ft: 59 corp: 23/404b lim: 4096 exec/s: 0 rss: 32Mb L: 2/131 MS: 1 ChangeBit-
#259	REDUCE cov: 25 ft: 59 corp: 23/397b lim: 4096 exec/s: 0 rss: 32Mb L: 20/131 MS: 3 PersAutoDict-InsertByte-EraseBytes- DE: &#34;\377\377\377\377&#34;-
#280	NEW    cov: 25 ft: 60 corp: 24/403b lim: 4096 exec/s: 0 rss: 32Mb L: 6/131 MS: 1 CMP- DE: &#34;\001\000&#34;-
#319	REDUCE cov: 25 ft: 60 corp: 24/402b lim: 4096 exec/s: 0 rss: 33Mb L: 19/131 MS: 4 CopyPart-CopyPart-InsertByte-EraseBytes-
#340	NEW    cov: 25 ft: 63 corp: 25/403b lim: 4096 exec/s: 0 rss: 33Mb L: 1/131 MS: 1 ChangeBinInt-
#436	REDUCE cov: 25 ft: 63 corp: 25/402b lim: 4096 exec/s: 0 rss: 33Mb L: 3/131 MS: 1 EraseBytes-
#532	REDUCE cov: 25 ft: 63 corp: 25/400b lim: 4096 exec/s: 0 rss: 34Mb L: 4/131 MS: 1 EraseBytes-
#570	NEW    cov: 25 ft: 64 corp: 26/401b lim: 4096 exec/s: 0 rss: 34Mb L: 1/131 MS: 3 CrossOver-ChangeByte-ChangeBit-
#643	REDUCE cov: 25 ft: 64 corp: 26/400b lim: 4096 exec/s: 0 rss: 34Mb L: 1/131 MS: 3 CopyPart-ShuffleBytes-EraseBytes-
#814	REDUCE cov: 25 ft: 64 corp: 26/364b lim: 4096 exec/s: 0 rss: 35Mb L: 66/131 MS: 1 EraseBytes-
#919	REDUCE cov: 25 ft: 64 corp: 26/343b lim: 4096 exec/s: 0 rss: 35Mb L: 27/131 MS: 5 PersAutoDict-ChangeBit-InsertByte-ChangeByte-EraseBytes- DE: &#34;\000\000\000\000&#34;-
#1245	REDUCE cov: 25 ft: 64 corp: 26/342b lim: 4096 exec/s: 0 rss: 36Mb L: 1/131 MS: 1 EraseBytes-
#1362	REDUCE cov: 25 ft: 64 corp: 26/339b lim: 4096 exec/s: 0 rss: 37Mb L: 35/131 MS: 2 CMP-EraseBytes- DE: &#34;\001\000\000\000\000\000\000\002&#34;-
#1534	REDUCE cov: 25 ft: 64 corp: 26/338b lim: 4096 exec/s: 0 rss: 37Mb L: 2/131 MS: 2 ShuffleBytes-EraseBytes-
#1596	REDUCE cov: 25 ft: 64 corp: 26/336b lim: 4096 exec/s: 0 rss: 38Mb L: 4/131 MS: 2 CrossOver-EraseBytes-
#1632	REDUCE cov: 25 ft: 64 corp: 26/335b lim: 4096 exec/s: 0 rss: 38Mb L: 3/131 MS: 1 EraseBytes-
#1809	NEW    cov: 25 ft: 65 corp: 27/337b lim: 4096 exec/s: 0 rss: 39Mb L: 2/131 MS: 2 ShuffleBytes-ChangeBit-
#2306	REDUCE cov: 25 ft: 65 corp: 27/336b lim: 4096 exec/s: 0 rss: 40Mb L: 34/131 MS: 2 ChangeBit-EraseBytes-
#2436	REDUCE cov: 25 ft: 65 corp: 27/326b lim: 4096 exec/s: 0 rss: 41Mb L: 17/131 MS: 5 InsertByte-CrossOver-ChangeBit-CrossOver-EraseBytes-
#2447	REDUCE cov: 25 ft: 65 corp: 27/325b lim: 4096 exec/s: 0 rss: 41Mb L: 2/131 MS: 1 EraseBytes-
#2763	REDUCE cov: 25 ft: 65 corp: 27/324b lim: 4096 exec/s: 0 rss: 42Mb L: 1/131 MS: 1 EraseBytes-
#4222	REDUCE cov: 25 ft: 65 corp: 27/323b lim: 4096 exec/s: 0 rss: 45Mb L: 18/131 MS: 4 CopyPart-EraseBytes-ChangeByte-CrossOver-
#4298	REDUCE cov: 25 ft: 65 corp: 27/322b lim: 4096 exec/s: 0 rss: 45Mb L: 16/131 MS: 1 EraseBytes-
#5645	REDUCE cov: 25 ft: 65 corp: 27/321b lim: 4096 exec/s: 0 rss: 46Mb L: 10/131 MS: 2 ShuffleBytes-EraseBytes-
#6305	REDUCE cov: 25 ft: 65 corp: 27/320b lim: 4096 exec/s: 0 rss: 47Mb L: 15/131 MS: 5 EraseBytes-CopyPart-InsertByte-InsertByte-CrossOver-
#7883	REDUCE cov: 25 ft: 65 corp: 27/319b lim: 4096 exec/s: 0 rss: 48Mb L: 14/131 MS: 3 EraseBytes-CrossOver-InsertByte-
#11227	REDUCE cov: 25 ft: 65 corp: 27/318b lim: 4096 exec/s: 0 rss: 48Mb L: 3/131 MS: 4 ChangeByte-ChangeBit-ShuffleBytes-EraseBytes-
#11965	REDUCE cov: 25 ft: 65 corp: 27/317b lim: 4096 exec/s: 0 rss: 49Mb L: 2/131 MS: 3 ChangeBit-EraseBytes-ChangeByte-
#15152	REDUCE cov: 25 ft: 65 corp: 27/316b lim: 4096 exec/s: 0 rss: 49Mb L: 1/131 MS: 2 ChangeBit-EraseBytes-
#35813	REDUCE cov: 25 ft: 65 corp: 27/315b lim: 4096 exec/s: 0 rss: 51Mb L: 130/130 MS: 1 EraseBytes-
#111668	REDUCE cov: 25 ft: 66 corp: 28/847b lim: 4096 exec/s: 111668 rss: 51Mb L: 532/532 MS: 5 CopyPart-ChangeBinInt-CrossOver-CopyPart-CrossOver-
#131072	pulse  cov: 25 ft: 66 corp: 28/847b lim: 4096 exec/s: 65536 rss: 52Mb
#133147	REDUCE cov: 25 ft: 66 corp: 28/831b lim: 4096 exec/s: 66573 rss: 52Mb L: 516/516 MS: 4 PersAutoDict-EraseBytes-ChangeBinInt-CMP- DE: &#34;\377\377\377\377&#34;-&#34;\003\000\000\000\000\000\000\000&#34;-
#164304	REDUCE cov: 25 ft: 66 corp: 28/830b lim: 4096 exec/s: 82152 rss: 52Mb L: 515/515 MS: 2 EraseBytes-PersAutoDict- DE: &#34;\003\000\000\000\000\000\000\000&#34;-
#213706	REDUCE cov: 25 ft: 66 corp: 28/829b lim: 4096 exec/s: 71235 rss: 52Mb L: 514/514 MS: 2 EraseBytes-PersAutoDict- DE: &#34;\001\000&#34;-
#262144	pulse  cov: 25 ft: 66 corp: 28/829b lim: 4096 exec/s: 65536 rss: 52Mb
#524288	pulse  cov: 25 ft: 66 corp: 28/829b lim: 4096 exec/s: 58254 rss: 52Mb
#1048576	pulse  cov: 25 ft: 66 corp: 28/829b lim: 4096 exec/s: 52428 rss: 52Mb
#1651126	DONE   cov: 25 ft: 66 corp: 28/829b lim: 4096 exec/s: 53262 rss: 52Mb
###### Recommended dictionary. ######
&#34;\377\377\377\377&#34; # Uses: 27094
&#34;\000\000\000\000&#34; # Uses: 26842
&#34;\001\000&#34; # Uses: 31660
&#34;\001\000\000\000\000\000\000\002&#34; # Uses: 24220
&#34;\003\000\000\000\000\000\000\000&#34; # Uses: 22087
###### End of recommended dictionary. ######
Done 1651126 runs in 31 second(s)
stat::number_of_executed_units: 1651126
stat::average_exec_per_sec:     53262
stat::new_units_added:          58
stat::slowest_unit_time_sec:    0
stat::peak_rss_mb:              52

</pre>


</body>