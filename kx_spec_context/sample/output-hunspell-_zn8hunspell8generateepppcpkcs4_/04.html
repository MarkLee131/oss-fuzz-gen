<!doctype html>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Experiment results</title>
<style>
* {
    box-sizing: border-box;
}

html {
    line-height: 1.15;
}

body {
    font-family: sans-serif;
    font-size: 16px;
}

table {
    border-collapse: collapse;
    border-spacing: 0;
}

td, th {
    border-right: 1px #dedede solid;
    border-bottom: 1px #dedede solid;
    padding: 5px;
    text-align: left;
}
td:first-child, th:first-child {
    border-left: 1px #dedede solid;
}
th {
    border-top: 1px #dedede solid;
}

tbody tr:nth-child(odd) {
    background-color: #f4f5ff;
}
</style>
<body>
    LLM:

<h1>output-hunspell-_zn8hunspell8generateepppcpkcs4_ / 04</h1>
Bug: False
<br>
Crash reason: NO_SEMANTIC_ERR
<br>
<br>

<h2>Triage</h2>
<pre>

</pre>
<br>





<h3>Final code</h3>

<pre>
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

extern &#34;C&#34; {
#include &lt;hunspell/hunspell.h&gt;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    FuzzedDataProvider fuzzed_data(data, size);

    std::string word = fuzzed_data.ConsumeRandomLengthString();
    std::string pattern = fuzzed_data.ConsumeRandomLengthString();

    word.push_back(&#39;\0&#39;);
    pattern.push_back(&#39;\0&#39;);

    char **slst = nullptr;

    // Initialize Hunspell object (assuming the dictionary files are available in the current directory)
    Hunhandle *hunspell = Hunspell_create(&#34;en_US.aff&#34;, &#34;en_US.dic&#34;);

    if (hunspell != nullptr) {
        int result = Hunspell_generate(hunspell, &amp;slst, word.c_str(), pattern.c_str());

        if (result &gt;= 0) {
            for (int i = 0; i &lt; result; ++i) {
                if (slst[i] != nullptr) {
                    size_t len = strlen(slst[i]);
                    if (slst[i][len] != &#39;\0&#39;) {
                        std::cerr &lt;&lt; &#34;Error: Non-null terminated string in slst&#34; &lt;&lt; std::endl;
                        abort();
                    }
                    free(slst[i]);
                }
            }
            free(slst);
        }

        Hunspell_destroy(hunspell);
    }

    return 0;
}
</pre>


<h3>Fixer prompt #1</h3>
<pre>

Given the following C++ fuzz harness and its build error message, fix the code to make it build for fuzzing.

If there is undeclared identifier or unknown type name error, fix it by finding and including the related libraries.

You MUST wrap the headers with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; if they are C headers, especially the headers are from the project.

Note that some code may need to be wrapped with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; as their source is C program.

MUST RETURN THE FULL CODE, INCLUDING UNCHANGED PARTS.
EXTREMELY IMPORTANT: AVOID USING &lt;code&gt;goto&lt;/code&gt;. If you have to write code using &lt;code&gt;goto&lt;/code&gt;, you MUST MUST also declare all variables BEFORE the &lt;code&gt;goto&lt;/code&gt;. Never introduce new variables after the &lt;code&gt;goto&lt;/code&gt;.

Below is the code needs to be built:
&lt;code&gt;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

extern &#34;C&#34; {
#include &#34;hunspell.h&#34;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    FuzzedDataProvider fuzzed_data(data, size);

    std::string word = fuzzed_data.ConsumeRandomLengthString();
    std::string pattern = fuzzed_data.ConsumeRandomLengthString();

    word.push_back(&#39;\0&#39;);
    pattern.push_back(&#39;\0&#39;);

    char **slst = nullptr;

    int result = Hunspell::generate(&amp;slst, word.c_str(), pattern.c_str());

    if (result &gt;= 0) {
        for (int i = 0; i &lt; result; ++i) {
            if (slst[i] != nullptr) {
                size_t len = strlen(slst[i]);
                if (slst[i][len] != &#39;\0&#39;) {
                    std::cerr &lt;&lt; &#34;Error: Non-null terminated string in slst&#34; &lt;&lt; std::endl;
                    abort();
                }
                free(slst[i]);
            }
        }
        free(slst);
    }

    return 0;
}
&lt;/code&gt;

The code has the following build issues:
&lt;error&gt;
./src/tools/fuzzer.cxx:15:10: fatal error: &#39;hunspell.h&#39; file not found
   15 | #include &#34;hunspell.h&#34;
      |          ^~~~~~~~~~~~
&lt;/error&gt;

Fix code:
1. Consider possible solutions for the issues listed above.
2. Choose a solution that can maximize fuzzing result, which is utilizing the function under test and feeding it not null input.
3. Apply the solutions to the original code.
It&#39;s important to show the complete code, not only the fixed line.
&lt;solution&gt;
</pre>



<h3>Code #1</h3>

<pre>
Here is the corrected code with the necessary fixes applied:

```cpp
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

extern &#34;C&#34; {
#include &#34;hunspell.h&#34;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    FuzzedDataProvider fuzzed_data(data, size);

    std::string word = fuzzed_data.ConsumeRandomLengthString();
    std::string pattern = fuzzed_data.ConsumeRandomLengthString();

    word.push_back(&#39;\0&#39;);
    pattern.push_back(&#39;\0&#39;);

    char **slst = nullptr;

    // Initialize Hunspell object (assuming the dictionary files are available in the current directory)
    Hunspell *hunspell = Hunspell_create(&#34;en_US.aff&#34;, &#34;en_US.dic&#34;);

    if (hunspell != nullptr) {
        int result = Hunspell_generate(hunspell, &amp;slst, word.c_str(), pattern.c_str());

        if (result &gt;= 0) {
            for (int i = 0; i &lt; result; ++i) {
                if (slst[i] != nullptr) {
                    size_t len = strlen(slst[i]);
                    if (slst[i][len] != &#39;\0&#39;) {
                        std::cerr &lt;&lt; &#34;Error: Non-null terminated string in slst&#34; &lt;&lt; std::endl;
                        abort();
                    }
                    free(slst[i]);
                }
            }
            free(slst);
        }

        Hunspell_destroy(hunspell);
    }

    return 0;
}
```

### Explanation of Fixes:

1. **Include `hunspell.h` Correctly**: The `hunspell.h` file should be included as a C header, so it is wrapped in `extern &#34;C&#34;`.

2. **Initialize and Destroy Hunspell Object**:
   - Added code to create a `Hunspell` object using `Hunspell_create`.
   - Added code to destroy the `Hunspell` object using `Hunspell_destroy` to ensure proper cleanup.

3. **Use Correct Function**:
   - Changed `Hunspell::generate` to `Hunspell_generate` to match the C API of Hunspell.

4. **Dictionary Files**:
   - Assumed dictionary files `en_US.aff` and `en_US.dic` are available in the current directory for initializing the `Hunspell` object.

This should resolve the build issues and ensure the fuzzing harness works correctly with the Hunspell library.
</pre>


<h3>Fixer prompt #2</h3>
<pre>

Given the following C++ fuzz harness and its build error message, fix the code to make it build for fuzzing.

If there is undeclared identifier or unknown type name error, fix it by finding and including the related libraries.

You MUST wrap the headers with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; if they are C headers, especially the headers are from the project.

Note that some code may need to be wrapped with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; as their source is C program.

MUST RETURN THE FULL CODE, INCLUDING UNCHANGED PARTS.
EXTREMELY IMPORTANT: AVOID USING &lt;code&gt;goto&lt;/code&gt;. If you have to write code using &lt;code&gt;goto&lt;/code&gt;, you MUST MUST also declare all variables BEFORE the &lt;code&gt;goto&lt;/code&gt;. Never introduce new variables after the &lt;code&gt;goto&lt;/code&gt;.

Below is the code needs to be built:
&lt;code&gt;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

extern &#34;C&#34; {
#include &#34;hunspell.h&#34;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    FuzzedDataProvider fuzzed_data(data, size);

    std::string word = fuzzed_data.ConsumeRandomLengthString();
    std::string pattern = fuzzed_data.ConsumeRandomLengthString();

    word.push_back(&#39;\0&#39;);
    pattern.push_back(&#39;\0&#39;);

    char **slst = nullptr;

    // Initialize Hunspell object (assuming the dictionary files are available in the current directory)
    Hunspell *hunspell = Hunspell_create(&#34;en_US.aff&#34;, &#34;en_US.dic&#34;);

    if (hunspell != nullptr) {
        int result = Hunspell_generate(hunspell, &amp;slst, word.c_str(), pattern.c_str());

        if (result &gt;= 0) {
            for (int i = 0; i &lt; result; ++i) {
                if (slst[i] != nullptr) {
                    size_t len = strlen(slst[i]);
                    if (slst[i][len] != &#39;\0&#39;) {
                        std::cerr &lt;&lt; &#34;Error: Non-null terminated string in slst&#34; &lt;&lt; std::endl;
                        abort();
                    }
                    free(slst[i]);
                }
            }
            free(slst);
        }

        Hunspell_destroy(hunspell);
    }

    return 0;
}
&lt;/code&gt;

The code has the following build issues:
&lt;error&gt;
./src/tools/fuzzer.cxx:15:10: fatal error: &#39;hunspell.h&#39; file not found
   15 | #include &#34;hunspell.h&#34;
      |          ^~~~~~~~~~~~
&lt;/error&gt;

Fix code:
1. Consider possible solutions for the issues listed above.
2. Choose a solution that can maximize fuzzing result, which is utilizing the function under test and feeding it not null input.
3. Apply the solutions to the original code.
It&#39;s important to show the complete code, not only the fixed line.
&lt;solution&gt;
</pre>



<h3>Code #2</h3>

<pre>
To fix the build error and ensure that the code compiles correctly for fuzzing, we need to include the correct headers and ensure that all necessary libraries are included. The error message indicates that the `hunspell.h` file is not found, which means we need to correct the inclusion of this header file.

Here is the corrected code:

```cpp
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

extern &#34;C&#34; {
#include &lt;hunspell/hunspell.h&gt;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    FuzzedDataProvider fuzzed_data(data, size);

    std::string word = fuzzed_data.ConsumeRandomLengthString();
    std::string pattern = fuzzed_data.ConsumeRandomLengthString();

    word.push_back(&#39;\0&#39;);
    pattern.push_back(&#39;\0&#39;);

    char **slst = nullptr;

    // Initialize Hunspell object (assuming the dictionary files are available in the current directory)
    Hunspell *hunspell = Hunspell_create(&#34;en_US.aff&#34;, &#34;en_US.dic&#34;);

    if (hunspell != nullptr) {
        int result = Hunspell_generate(hunspell, &amp;slst, word.c_str(), pattern.c_str());

        if (result &gt;= 0) {
            for (int i = 0; i &lt; result; ++i) {
                if (slst[i] != nullptr) {
                    size_t len = strlen(slst[i]);
                    if (slst[i][len] != &#39;\0&#39;) {
                        std::cerr &lt;&lt; &#34;Error: Non-null terminated string in slst&#34; &lt;&lt; std::endl;
                        abort();
                    }
                    free(slst[i]);
                }
            }
            free(slst);
        }

        Hunspell_destroy(hunspell);
    }

    return 0;
}
```

Changes made:
1. Corrected the inclusion of the `hunspell.h` header file by using the correct path `&lt;hunspell/hunspell.h&gt;`.
2. Wrapped the inclusion of the `hunspell.h` header file within `extern &#34;C&#34;` to ensure compatibility with C++.

This should resolve the build error and allow the code to compile correctly for fuzzing.
</pre>


<h3>Fixer prompt #3</h3>
<pre>

Given the following C++ fuzz harness and its build error message, fix the code to make it build for fuzzing.

If there is undeclared identifier or unknown type name error, fix it by finding and including the related libraries.

You MUST wrap the headers with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; if they are C headers, especially the headers are from the project.

Note that some code may need to be wrapped with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; as their source is C program.

MUST RETURN THE FULL CODE, INCLUDING UNCHANGED PARTS.
EXTREMELY IMPORTANT: AVOID USING &lt;code&gt;goto&lt;/code&gt;. If you have to write code using &lt;code&gt;goto&lt;/code&gt;, you MUST MUST also declare all variables BEFORE the &lt;code&gt;goto&lt;/code&gt;. Never introduce new variables after the &lt;code&gt;goto&lt;/code&gt;.

Below is the code needs to be built:
&lt;code&gt;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

extern &#34;C&#34; {
#include &lt;hunspell/hunspell.h&gt;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    FuzzedDataProvider fuzzed_data(data, size);

    std::string word = fuzzed_data.ConsumeRandomLengthString();
    std::string pattern = fuzzed_data.ConsumeRandomLengthString();

    word.push_back(&#39;\0&#39;);
    pattern.push_back(&#39;\0&#39;);

    char **slst = nullptr;

    // Initialize Hunspell object (assuming the dictionary files are available in the current directory)
    Hunspell *hunspell = Hunspell_create(&#34;en_US.aff&#34;, &#34;en_US.dic&#34;);

    if (hunspell != nullptr) {
        int result = Hunspell_generate(hunspell, &amp;slst, word.c_str(), pattern.c_str());

        if (result &gt;= 0) {
            for (int i = 0; i &lt; result; ++i) {
                if (slst[i] != nullptr) {
                    size_t len = strlen(slst[i]);
                    if (slst[i][len] != &#39;\0&#39;) {
                        std::cerr &lt;&lt; &#34;Error: Non-null terminated string in slst&#34; &lt;&lt; std::endl;
                        abort();
                    }
                    free(slst[i]);
                }
            }
            free(slst);
        }

        Hunspell_destroy(hunspell);
    }

    return 0;
}
&lt;/code&gt;

The code has the following build issues:
&lt;error&gt;
./src/tools/fuzzer.cxx:34:5: error: unknown type name &#39;Hunspell&#39;
   34 |     Hunspell *hunspell = Hunspell_create(&#34;en_US.aff&#34;, &#34;en_US.dic&#34;);
      |     ^
&lt;/error&gt;

Fix code:
1. Consider possible solutions for the issues listed above.
2. Choose a solution that can maximize fuzzing result, which is utilizing the function under test and feeding it not null input.
3. Apply the solutions to the original code.
It&#39;s important to show the complete code, not only the fixed line.
&lt;solution&gt;
</pre>



<h3>Code #3</h3>

<pre>
Here is the complete fixed code:

```cpp
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

extern &#34;C&#34; {
#include &lt;hunspell/hunspell.h&gt;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    FuzzedDataProvider fuzzed_data(data, size);

    std::string word = fuzzed_data.ConsumeRandomLengthString();
    std::string pattern = fuzzed_data.ConsumeRandomLengthString();

    word.push_back(&#39;\0&#39;);
    pattern.push_back(&#39;\0&#39;);

    char **slst = nullptr;

    // Initialize Hunspell object (assuming the dictionary files are available in the current directory)
    Hunhandle *hunspell = Hunspell_create(&#34;en_US.aff&#34;, &#34;en_US.dic&#34;);

    if (hunspell != nullptr) {
        int result = Hunspell_generate(hunspell, &amp;slst, word.c_str(), pattern.c_str());

        if (result &gt;= 0) {
            for (int i = 0; i &lt; result; ++i) {
                if (slst[i] != nullptr) {
                    size_t len = strlen(slst[i]);
                    if (slst[i][len] != &#39;\0&#39;) {
                        std::cerr &lt;&lt; &#34;Error: Non-null terminated string in slst&#34; &lt;&lt; std::endl;
                        abort();
                    }
                    free(slst[i]);
                }
            }
            free(slst);
        }

        Hunspell_destroy(hunspell);
    }

    return 0;
}
```

### Explanation of Changes:
1. **Fixed Type Name:** The error was due to the incorrect type name `Hunspell`. The correct type name is `Hunhandle`. This was corrected in the line where the `Hunspell` object is created.
2. **Ensured Proper Header Inclusion:** The necessary headers were already included, and the Hunspell headers were correctly wrapped in `extern &#34;C&#34;`.

By making these changes, the code should now compile correctly for fuzzing.
</pre>


<h2>Logs</h2>
<pre>
Fixing /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-hunspell-_zn8hunspell8generateepppcpkcs4_/fixed_targets/04.cxx with gpt-4o, attempt 1.
Fixing /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-hunspell-_zn8hunspell8generateepppcpkcs4_/fixed_targets/04.cxx with gpt-4o, attempt 2.
Fixing /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-hunspell-_zn8hunspell8generateepppcpkcs4_/fixed_targets/04.cxx with gpt-4o, attempt 3.
Successfully built /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-hunspell-_zn8hunspell8generateepppcpkcs4_/fixed_targets/04.cxx with gpt-4o in 3 iterations of fixing.
Triaging the crash related to /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-hunspell-_zn8hunspell8generateepppcpkcs4_/fixed_targets/04.cxx with gpt-4o.
Warning: no crash info in hunspell-zn8hunspell8generateepppcpkcs4-04.
Result for hunspell-zn8hunspell8generateepppcpkcs4-04: crashes=False, coverage=0.028518713758566155 (541/18970), coverage diff=0.017040358744394617 (171/10035)

</pre>

<h2>Run logs</h2>
<pre>
INFO:__main__:Running: docker run --rm --privileged --shm-size=2g --platform linux/amd64 -e FUZZING_ENGINE=libfuzzer -e SANITIZER=address -e RUN_FUZZER_MODE=interactive -e HELPER=True -v /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-hunspell-_zn8hunspell8generateepppcpkcs4_/corpora/04.cxx:/tmp/fuzzer_corpus -v /tmp/tmpqe63huln/build/out/hunspell-zn8hunspell8generateepppcpkcs4-04:/out -t gcr.io/oss-fuzz-base/base-runner run_fuzzer fuzzer -print_final_stats=1 -max_total_time=30 -len_control=0 -timeout=30.
vm.mmap_rnd_bits = 28
rm: cannot remove &#39;/tmp/fuzzer_corpus&#39;: Device or resource busy
/out/fuzzer -rss_limit_mb=2560 -timeout=25 -print_final_stats=1 -max_total_time=30 -len_control=0 -timeout=30 /tmp/fuzzer_corpus -max_len=262144 &lt; /dev/null
INFO: Running with entropic power schedule (0xFF, 100).
INFO: Seed: 4195433231
INFO: Loaded 1 modules   (18970 inline 8-bit counters): 18970 [0x55b21d826c78, 0x55b21d82b692),
INFO: Loaded 1 PC tables (18970 PCs): 18970 [0x55b21d82b698,0x55b21d875838),
INFO:        0 files found in /tmp/fuzzer_corpus
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
INFO: A corpus is not provided, starting from an empty corpus
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
#2	INITED cov: 335 ft: 336 corp: 1/1b exec/s: 0 rss: 33Mb
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
#3	NEW    cov: 340 ft: 348 corp: 2/107b lim: 262144 exec/s: 0 rss: 34Mb L: 106/106 MS: 1 InsertRepeatedBytes-
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
#4	NEW    cov: 340 ft: 352 corp: 3/262b lim: 262144 exec/s: 0 rss: 34Mb L: 155/155 MS: 1 InsertRepeatedBytes-
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
#5	NEW    cov: 342 ft: 354 corp: 4/336b lim: 262144 exec/s: 0 rss: 35Mb L: 74/155 MS: 1 InsertRepeatedBytes-
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
#7	NEW    cov: 342 ft: 358 corp: 5/338b lim: 262144 exec/s: 0 rss: 36Mb L: 2/155 MS: 2 ChangeBit-CopyPart-
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
#8	NEW    cov: 342 ft: 362 corp: 6/347b lim: 262144 exec/s: 0 rss: 36Mb L: 9/155 MS: 1 CMP- DE: &#34;\001\000\000\000\000\000\000\020&#34;-
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
#10	REDUCE cov: 342 ft: 362 corp: 6/346b lim: 262144 exec/s: 0 rss: 37Mb L: 8/155 MS: 2 CMP-EraseBytes- DE: &#34;\001\000\000\000\000\000\000\000&#34;-
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
#11	REDUCE cov: 342 ft: 362 corp: 6/311b lim: 262144 exec/s: 0 rss: 37Mb L: 39/155 MS: 1 EraseBytes-
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
#25	REDUCE cov: 342 ft: 366 corp: 7/330b lim: 262144 exec/s: 0 rss: 39Mb L: 19/155 MS: 4 CMP-ChangeByte-ChangeBit-CopyPart- DE: &#34;\000\000\000\002&#34;-
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
#40	NEW    cov: 342 ft: 370 corp: 8/337b lim: 262144 exec/s: 0 rss: 39Mb L: 7/155 MS: 5 PersAutoDict-EraseBytes-ChangeBinInt-EraseBytes-EraseBytes- DE: &#34;\001\000\000\000\000\000\000\020&#34;-
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
#45	REDUCE cov: 342 ft: 370 corp: 8/335b lim: 262144 exec/s: 0 rss: 39Mb L: 5/155 MS: 5 ChangeBinInt-InsertByte-InsertByte-ChangeBit-EraseBytes-
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
#49	REDUCE cov: 343 ft: 371 corp: 9/341b lim: 262144 exec/s: 0 rss: 39Mb L: 6/155 MS: 4 CopyPart-EraseBytes-EraseBytes-ShuffleBytes-
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error:
...truncated...
S.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
error: en_US.aff: cannot open
error: en_US.dic: cannot open
error: en_US.aff: cannot open
#174845	DONE   cov: 541 ft: 855 corp: 88/1551b lim: 262144 exec/s: 5640 rss: 42Mb
###### Recommended dictionary. ######
&#34;\001\000\000\000\000\000\000\020&#34; # Uses: 566
&#34;\001\000\000\000\000\000\000\000&#34; # Uses: 619
&#34;\000\000\000\002&#34; # Uses: 631
&#34;\000\000\000\000\000\000\000\000&#34; # Uses: 573
&#34;\377\377\377\377&#34; # Uses: 634
&#34;\251\252\252\252\252\252\252\012&#34; # Uses: 547
&#34;\001\000\000\000&#34; # Uses: 612
&#34;\377\377\377\377\377\377\377\377&#34; # Uses: 557
&#34;\004\000\000\000\000\000\000\000&#34; # Uses: 589
&#34;VUUUUUU\005&#34; # Uses: 596
&#34;\377\377\377\377\377\377\377\001&#34; # Uses: 551
&#34;\001\015&#34; # Uses: 632
&#34;\000\030&#34; # Uses: 613
&#34;\026\000\000\000\000\000\000\000&#34; # Uses: 527
&#34;\377\377\377\377\377\377\377\026&#34; # Uses: 555
&#34;\010\000\000\000\000\000\000\000&#34; # Uses: 497
&#34;\027\000\000\000\000\000\000\000&#34; # Uses: 495
&#34;\000\000\000\000\000\000\000\037&#34; # Uses: 551
&#34;\001=&#34; # Uses: 615
&#34;\000\001&#34; # Uses: 576
&#34;\003\000\000\000\000\000\000\000&#34; # Uses: 469
&#34;\001\000\000\020&#34; # Uses: 507
&#34;\001\001&#34; # Uses: 515
&#34;\377\377&#34; # Uses: 503
&#34;7\000\000\000&#34; # Uses: 490
&#34;\\\000&#34; # Uses: 468
&#34;\001\000&#34; # Uses: 328
&#34;\000\000\000\013&#34; # Uses: 325
###### End of recommended dictionary. ######
Done 174845 runs in 31 second(s)
stat::number_of_executed_units: 174845
stat::average_exec_per_sec:     5640
stat::new_units_added:          708
stat::slowest_unit_time_sec:    0
stat::peak_rss_mb:              42

</pre>


</body>