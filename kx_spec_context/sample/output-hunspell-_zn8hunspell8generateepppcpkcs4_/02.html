<!doctype html>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Experiment results</title>
<style>
* {
    box-sizing: border-box;
}

html {
    line-height: 1.15;
}

body {
    font-family: sans-serif;
    font-size: 16px;
}

table {
    border-collapse: collapse;
    border-spacing: 0;
}

td, th {
    border-right: 1px #dedede solid;
    border-bottom: 1px #dedede solid;
    padding: 5px;
    text-align: left;
}
td:first-child, th:first-child {
    border-left: 1px #dedede solid;
}
th {
    border-top: 1px #dedede solid;
}

tbody tr:nth-child(odd) {
    background-color: #f4f5ff;
}
</style>
<body>
    LLM: 
    
<h1>output-hunspell-_zn8hunspell8generateepppcpkcs4_ / 02</h1>
Bug: False
<br>
Crash reason: NO_SEMANTIC_ERR
<br>
<br>

<h2>Triage</h2>
<pre>

</pre>
<br>





<h3>Final code</h3>

<pre>
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

extern &#34;C&#34; {
#include &lt;hunspell/hunspell.h&gt; // Correctly include the necessary header file for Hunspell
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    // Initialize the library or any resources within Hunspell needed for the fuzzing process here.
    // For example, you might initialize a Hunspell instance if needed.
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    // Create a FuzzedDataProvider to handle the input data
    FuzzedDataProvider fuzzed_data(data, size);

    // Generate the input parameters for Hunspell::generate
    // Precondition: The word and pattern must be null-terminated strings.
    std::string word = fuzzed_data.ConsumeRandomLengthString();
    std::string pattern = fuzzed_data.ConsumeRandomLengthString();

    // Ensure the strings are null-terminated
    word.push_back(&#39;\0&#39;);
    pattern.push_back(&#39;\0&#39;);

    // Prepare the char*** parameter
    char **slst = nullptr;

    // Initialize Hunspell instance (assuming the affix and dictionary files are available)
    Hunhandle *hunspell = Hunspell_create(&#34;/path/to/dictionary.aff&#34;, &#34;/path/to/dictionary.dic&#34;);

    if (hunspell == nullptr) {
        std::cerr &lt;&lt; &#34;Error: Failed to create Hunspell instance&#34; &lt;&lt; std::endl;
        return 0;
    }

    // Call the function under test
    int result = Hunspell_generate(hunspell, &amp;slst, word.c_str(), pattern.c_str());

    // Postcondition: Check the result and ensure proper resource management
    if (result &gt;= 0) {
        // If the function returns a non-negative result, slst should be properly allocated and populated
        for (int i = 0; i &lt; result; ++i) {
            if (slst[i] != nullptr) {
                // Ensure each string in slst is null-terminated
                size_t len = strlen(slst[i]);
                if (slst[i][len] != &#39;\0&#39;) {
                    std::cerr &lt;&lt; &#34;Error: Non-null terminated string in slst&#34; &lt;&lt; std::endl;
                    abort();
                }
                // Free each string
                free(slst[i]);
            }
        }
        // Free the slst array itself
        free(slst);
    }

    // Clean up the Hunspell instance
    Hunspell_destroy(hunspell);

    // Return 0 to indicate successful execution of the fuzzing test
    return 0;
}
</pre>


<h3>Fixer prompt #1</h3>
<pre>

Given the following C++ fuzz harness and its build error message, fix the code to make it build for fuzzing.

If there is undeclared identifier or unknown type name error, fix it by finding and including the related libraries.

You MUST wrap the headers with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; if they are C headers, especially the headers are from the project.

Note that some code may need to be wrapped with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; as their source is C program.

MUST RETURN THE FULL CODE, INCLUDING UNCHANGED PARTS.
EXTREMELY IMPORTANT: AVOID USING &lt;code&gt;goto&lt;/code&gt;. If you have to write code using &lt;code&gt;goto&lt;/code&gt;, you MUST MUST also declare all variables BEFORE the &lt;code&gt;goto&lt;/code&gt;. Never introduce new variables after the &lt;code&gt;goto&lt;/code&gt;.

Below is the code needs to be built:
&lt;code&gt;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

extern &#34;C&#34; {
#include &#34;hunspell.h&#34; // Include the necessary header file for Hunspell
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    // Initialize the library or any resources within Hunspell needed for the fuzzing process here.
    // For example, you might initialize a Hunspell instance if needed.
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    // Create a FuzzedDataProvider to handle the input data
    FuzzedDataProvider fuzzed_data(data, size);

    // Generate the input parameters for Hunspell::generate
    // Precondition: The word and pattern must be null-terminated strings.
    std::string word = fuzzed_data.ConsumeRandomLengthString();
    std::string pattern = fuzzed_data.ConsumeRandomLengthString();

    // Ensure the strings are null-terminated
    word.push_back(&#39;\0&#39;);
    pattern.push_back(&#39;\0&#39;);

    // Prepare the char*** parameter
    char **slst = nullptr;

    // Call the function under test
    int result = Hunspell::generate(&amp;slst, word.c_str(), pattern.c_str());

    // Postcondition: Check the result and ensure proper resource management
    if (result &gt;= 0) {
        // If the function returns a non-negative result, slst should be properly allocated and populated
        for (int i = 0; i &lt; result; ++i) {
            if (slst[i] != nullptr) {
                // Ensure each string in slst is null-terminated
                size_t len = strlen(slst[i]);
                if (slst[i][len] != &#39;\0&#39;) {
                    std::cerr &lt;&lt; &#34;Error: Non-null terminated string in slst&#34; &lt;&lt; std::endl;
                    abort();
                }
                // Free each string
                free(slst[i]);
            }
        }
        // Free the slst array itself
        free(slst);
    }

    // Return 0 to indicate successful execution of the fuzzing test
    return 0;
}
&lt;/code&gt;

The code has the following build issues:
&lt;error&gt;
./src/tools/fuzzer.cxx:15:10: fatal error: &#39;hunspell.h&#39; file not found
   15 | #include &#34;hunspell.h&#34; // Include the necessary header file for Hunspell
      |          ^~~~~~~~~~~~
&lt;/error&gt;

Fix code:
1. Consider possible solutions for the issues listed above.
2. Choose a solution that can maximize fuzzing result, which is utilizing the function under test and feeding it not null input.
3. Apply the solutions to the original code.
It&#39;s important to show the complete code, not only the fixed line.
&lt;solution&gt;
</pre>



<h3>Code #1</h3>

<pre>
Certainly! To fix the build issue, we need to ensure that the `hunspell.h` file is correctly included. Since `hunspell.h` is a C header file, we have to wrap it with `extern &#34;C&#34;`. Additionally, we need to ensure that we correctly handle the Hunspell API, which might have a different function signature than assumed.

Here&#39;s the corrected code:

```cpp
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

extern &#34;C&#34; {
#include &lt;hunspell/hunspell.h&gt; // Correctly include the necessary header file for Hunspell
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    // Initialize the library or any resources within Hunspell needed for the fuzzing process here.
    // For example, you might initialize a Hunspell instance if needed.
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    // Create a FuzzedDataProvider to handle the input data
    FuzzedDataProvider fuzzed_data(data, size);

    // Generate the input parameters for Hunspell::generate
    // Precondition: The word and pattern must be null-terminated strings.
    std::string word = fuzzed_data.ConsumeRandomLengthString();
    std::string pattern = fuzzed_data.ConsumeRandomLengthString();

    // Ensure the strings are null-terminated
    word.push_back(&#39;\0&#39;);
    pattern.push_back(&#39;\0&#39;);

    // Prepare the char*** parameter
    char **slst = nullptr;

    // Initialize Hunspell instance (assuming the affix and dictionary files are available)
    Hunspell *hunspell = Hunspell_create(&#34;/path/to/dictionary.aff&#34;, &#34;/path/to/dictionary.dic&#34;);

    if (hunspell == nullptr) {
        std::cerr &lt;&lt; &#34;Error: Failed to create Hunspell instance&#34; &lt;&lt; std::endl;
        return 0;
    }

    // Call the function under test
    int result = Hunspell_generate(hunspell, &amp;slst, word.c_str(), pattern.c_str());

    // Postcondition: Check the result and ensure proper resource management
    if (result &gt;= 0) {
        // If the function returns a non-negative result, slst should be properly allocated and populated
        for (int i = 0; i &lt; result; ++i) {
            if (slst[i] != nullptr) {
                // Ensure each string in slst is null-terminated
                size_t len = strlen(slst[i]);
                if (slst[i][len] != &#39;\0&#39;) {
                    std::cerr &lt;&lt; &#34;Error: Non-null terminated string in slst&#34; &lt;&lt; std::endl;
                    abort();
                }
                // Free each string
                free(slst[i]);
            }
        }
        // Free the slst array itself
        free(slst);
    }

    // Clean up the Hunspell instance
    Hunspell_destroy(hunspell);

    // Return 0 to indicate successful execution of the fuzzing test
    return 0;
}
```

### Explanation:
1. **Include Correct Header**: The `hunspell.h` file is included with the correct path.
2. **Wrap C Headers with `extern &#34;C&#34;`**: The `hunspell.h` inclusion is wrapped with `extern &#34;C&#34;` to avoid C++ name mangling.
3. **Initialize Hunspell Instance**: The code initializes a Hunspell instance using `Hunspell_create` and cleans it up using `Hunspell_destroy`.
4. **Correct Function Signature**: The function `Hunspell_generate` is called with the correct parameters.

Make sure to replace `&#34;/path/to/dictionary.aff&#34;` and `&#34;/path/to/dictionary.dic&#34;` with the actual paths to your Hunspell dictionary files to ensure proper initialization.
</pre>


<h3>Fixer prompt #2</h3>
<pre>

Given the following C++ fuzz harness and its build error message, fix the code to make it build for fuzzing.

If there is undeclared identifier or unknown type name error, fix it by finding and including the related libraries.

You MUST wrap the headers with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; if they are C headers, especially the headers are from the project.

Note that some code may need to be wrapped with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; as their source is C program.

MUST RETURN THE FULL CODE, INCLUDING UNCHANGED PARTS.
EXTREMELY IMPORTANT: AVOID USING &lt;code&gt;goto&lt;/code&gt;. If you have to write code using &lt;code&gt;goto&lt;/code&gt;, you MUST MUST also declare all variables BEFORE the &lt;code&gt;goto&lt;/code&gt;. Never introduce new variables after the &lt;code&gt;goto&lt;/code&gt;.

Below is the code needs to be built:
&lt;code&gt;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

extern &#34;C&#34; {
#include &lt;hunspell/hunspell.h&gt; // Correctly include the necessary header file for Hunspell
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    // Initialize the library or any resources within Hunspell needed for the fuzzing process here.
    // For example, you might initialize a Hunspell instance if needed.
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    // Create a FuzzedDataProvider to handle the input data
    FuzzedDataProvider fuzzed_data(data, size);

    // Generate the input parameters for Hunspell::generate
    // Precondition: The word and pattern must be null-terminated strings.
    std::string word = fuzzed_data.ConsumeRandomLengthString();
    std::string pattern = fuzzed_data.ConsumeRandomLengthString();

    // Ensure the strings are null-terminated
    word.push_back(&#39;\0&#39;);
    pattern.push_back(&#39;\0&#39;);

    // Prepare the char*** parameter
    char **slst = nullptr;

    // Initialize Hunspell instance (assuming the affix and dictionary files are available)
    Hunspell *hunspell = Hunspell_create(&#34;/path/to/dictionary.aff&#34;, &#34;/path/to/dictionary.dic&#34;);

    if (hunspell == nullptr) {
        std::cerr &lt;&lt; &#34;Error: Failed to create Hunspell instance&#34; &lt;&lt; std::endl;
        return 0;
    }

    // Call the function under test
    int result = Hunspell_generate(hunspell, &amp;slst, word.c_str(), pattern.c_str());

    // Postcondition: Check the result and ensure proper resource management
    if (result &gt;= 0) {
        // If the function returns a non-negative result, slst should be properly allocated and populated
        for (int i = 0; i &lt; result; ++i) {
            if (slst[i] != nullptr) {
                // Ensure each string in slst is null-terminated
                size_t len = strlen(slst[i]);
                if (slst[i][len] != &#39;\0&#39;) {
                    std::cerr &lt;&lt; &#34;Error: Non-null terminated string in slst&#34; &lt;&lt; std::endl;
                    abort();
                }
                // Free each string
                free(slst[i]);
            }
        }
        // Free the slst array itself
        free(slst);
    }

    // Clean up the Hunspell instance
    Hunspell_destroy(hunspell);

    // Return 0 to indicate successful execution of the fuzzing test
    return 0;
}
&lt;/code&gt;

The code has the following build issues:
&lt;error&gt;
./src/tools/fuzzer.cxx:41:5: error: unknown type name &#39;Hunspell&#39;
   41 |     Hunspell *hunspell = Hunspell_create(&#34;/path/to/dictionary.aff&#34;, &#34;/path/to/dictionary.dic&#34;);
      |     ^
&lt;/error&gt;

Fix code:
1. Consider possible solutions for the issues listed above.
2. Choose a solution that can maximize fuzzing result, which is utilizing the function under test and feeding it not null input.
3. Apply the solutions to the original code.
It&#39;s important to show the complete code, not only the fixed line.
&lt;solution&gt;
</pre>



<h3>Code #2</h3>

<pre>
Here&#39;s the corrected code with the necessary changes to fix the build issues:

```cpp
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

extern &#34;C&#34; {
#include &lt;hunspell/hunspell.h&gt; // Correctly include the necessary header file for Hunspell
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    // Initialize the library or any resources within Hunspell needed for the fuzzing process here.
    // For example, you might initialize a Hunspell instance if needed.
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    // Create a FuzzedDataProvider to handle the input data
    FuzzedDataProvider fuzzed_data(data, size);

    // Generate the input parameters for Hunspell::generate
    // Precondition: The word and pattern must be null-terminated strings.
    std::string word = fuzzed_data.ConsumeRandomLengthString();
    std::string pattern = fuzzed_data.ConsumeRandomLengthString();

    // Ensure the strings are null-terminated
    word.push_back(&#39;\0&#39;);
    pattern.push_back(&#39;\0&#39;);

    // Prepare the char*** parameter
    char **slst = nullptr;

    // Initialize Hunspell instance (assuming the affix and dictionary files are available)
    Hunhandle *hunspell = Hunspell_create(&#34;/path/to/dictionary.aff&#34;, &#34;/path/to/dictionary.dic&#34;);

    if (hunspell == nullptr) {
        std::cerr &lt;&lt; &#34;Error: Failed to create Hunspell instance&#34; &lt;&lt; std::endl;
        return 0;
    }

    // Call the function under test
    int result = Hunspell_generate(hunspell, &amp;slst, word.c_str(), pattern.c_str());

    // Postcondition: Check the result and ensure proper resource management
    if (result &gt;= 0) {
        // If the function returns a non-negative result, slst should be properly allocated and populated
        for (int i = 0; i &lt; result; ++i) {
            if (slst[i] != nullptr) {
                // Ensure each string in slst is null-terminated
                size_t len = strlen(slst[i]);
                if (slst[i][len] != &#39;\0&#39;) {
                    std::cerr &lt;&lt; &#34;Error: Non-null terminated string in slst&#34; &lt;&lt; std::endl;
                    abort();
                }
                // Free each string
                free(slst[i]);
            }
        }
        // Free the slst array itself
        free(slst);
    }

    // Clean up the Hunspell instance
    Hunspell_destroy(hunspell);

    // Return 0 to indicate successful execution of the fuzzing test
    return 0;
}
```

### Changes Made:
1. **Typo Fix**: Corrected the type name from `Hunspell` to `Hunhandle` which is the correct type used in the Hunspell C API.
2. **Ensured Proper Inclusion**: The `hunspell.h` header is correctly included within the `extern &#34;C&#34;` block to ensure compatibility with C++.

This should resolve the unknown type name error and allow the code to build successfully for fuzzing.
</pre>


<h2>Logs</h2>
<pre>
Fixing /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-hunspell-_zn8hunspell8generateepppcpkcs4_/fixed_targets/02.cxx with gpt-4o, attempt 1.
Fixing /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-hunspell-_zn8hunspell8generateepppcpkcs4_/fixed_targets/02.cxx with gpt-4o, attempt 2.
Successfully built /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-hunspell-_zn8hunspell8generateepppcpkcs4_/fixed_targets/02.cxx with gpt-4o in 2 iterations of fixing.
Triaging the crash related to /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-hunspell-_zn8hunspell8generateepppcpkcs4_/fixed_targets/02.cxx with gpt-4o.
Warning: no crash info in hunspell-zn8hunspell8generateepppcpkcs4-02.
Result for hunspell-zn8hunspell8generateepppcpkcs4-02: crashes=False, coverage=0.028615092748735246 (543/18976), coverage diff=0.017040358744394617 (171/10035)

</pre>

<h2>Run logs</h2>
<pre>
INFO:__main__:Running: docker run --rm --privileged --shm-size=2g --platform linux/amd64 -e FUZZING_ENGINE=libfuzzer -e SANITIZER=address -e RUN_FUZZER_MODE=interactive -e HELPER=True -v /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-hunspell-_zn8hunspell8generateepppcpkcs4_/corpora/02.cxx:/tmp/fuzzer_corpus -v /tmp/tmpqe63huln/build/out/hunspell-zn8hunspell8generateepppcpkcs4-02:/out -t gcr.io/oss-fuzz-base/base-runner run_fuzzer fuzzer -print_final_stats=1 -max_total_time=30 -len_control=0 -timeout=30.
vm.mmap_rnd_bits = 28
rm: cannot remove &#39;/tmp/fuzzer_corpus&#39;: Device or resource busy
/out/fuzzer -rss_limit_mb=2560 -timeout=25 -print_final_stats=1 -max_total_time=30 -len_control=0 -timeout=30 /tmp/fuzzer_corpus -max_len=262144 &lt; /dev/null
INFO: Running with entropic power schedule (0xFF, 100).
INFO: Seed: 4152630139
INFO: Loaded 1 modules   (18976 inline 8-bit counters): 18976 [0x56027ab9ecb8, 0x56027aba36d8), 
INFO: Loaded 1 PC tables (18976 PCs): 18976 [0x56027aba36d8,0x56027abed8d8), 
INFO:        0 files found in /tmp/fuzzer_corpus
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
INFO: A corpus is not provided, starting from an empty corpus
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
#2	INITED cov: 337 ft: 338 corp: 1/1b exec/s: 0 rss: 34Mb
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
#3	NEW    cov: 337 ft: 342 corp: 2/3b lim: 262144 exec/s: 0 rss: 34Mb L: 2/2 MS: 1 CrossOver-
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
#6	NEW    cov: 337 ft: 346 corp: 3/6b lim: 262144 exec/s: 0 rss: 35Mb L: 3/3 MS: 3 ChangeByte-CopyPart-InsertByte-
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
#8	NEW    cov: 342 ft: 358 corp: 4/116b lim: 262144 exec/s: 0 rss: 36Mb L: 110/110 MS: 2 CrossOver-InsertRepeatedBytes-
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
#11	NEW    cov: 342 ft: 362 corp: 5/125b lim: 262144 exec/s: 0 rss: 37Mb L: 9/110 MS: 3 ChangeBit-ShuffleBytes-CMP- DE: &#34;\001\000\000\000\000\000\000\000&#34;-
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
#15	NEW    cov: 342 ft: 366 corp: 6/131b lim: 262144 exec/s: 0 rss: 38Mb L: 6/110 MS: 4 CrossOver-EraseBytes-ShuffleBytes-InsertRepeatedBytes-
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
#18	NEW    cov: 342 ft: 370 corp: 7/151b lim: 262144 exec/s: 0 rss: 38Mb L: 20/110 MS: 3 PersAutoDict-InsertByte-PersAutoDict- DE: &#34;\001\000\000\000\000\000\000\000&#34;-&#34;\001\000\000\000\000\000\000\000&#34;-
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
#20	NEW    cov: 342 ft: 374 corp: 8/373b lim: 262144 exec/s: 0 rss: 38Mb L: 222/222 MS: 2 ChangeByte-InsertRepeatedBytes-
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
#32	REDUCE cov: 342 ft: 374 corp: 8/316b lim: 262144 exec/s: 0 rss: 39Mb L: 165/165 MS: 2 InsertRepeatedBytes-EraseBytes-
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
...truncated...
ath/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.aff: cannot open
error: /path/to/dictionary.dic: cannot open
error: /path/to/dictionary.aff: cannot open
#160769	DONE   cov: 543 ft: 858 corp: 84/1730b lim: 262144 exec/s: 5186 rss: 43Mb
###### Recommended dictionary. ######
&#34;\001\000\000\000\000\000\000\000&#34; # Uses: 556
&#34;\377\377\377\377&#34; # Uses: 535
&#34;\012\252\252\252\252\252\252\252&#34; # Uses: 510
&#34;\014\000\000\000\000\000\000\000&#34; # Uses: 487
&#34;\377\377\377\377\377\377\377\032&#34; # Uses: 487
&#34;\001\000\000\000&#34; # Uses: 569
&#34;\000\000\000\002&#34; # Uses: 489
&#34;\377\377\377\377\377\377\377\031&#34; # Uses: 467
&#34;\000\000\000\000\000\000\000\001&#34; # Uses: 484
&#34;\377\377\377\006&#34; # Uses: 497
&#34;\000\002&#34; # Uses: 548
&#34;\021\000\000\000\000\000\000\000&#34; # Uses: 479
&#34;\003\000&#34; # Uses: 562
&#34;Q\000&#34; # Uses: 529
&#34;\016\000\000\000\000\000\000\000&#34; # Uses: 419
&#34;3\000\000\000&#34; # Uses: 478
&#34;\000\000&#34; # Uses: 487
&#34;\377\377&#34; # Uses: 477
&#34;\020\000\000\000\000\000\000\000&#34; # Uses: 421
&#34;\002\000\000\000\000\000\000\000&#34; # Uses: 411
&#34;\000\017&#34; # Uses: 467
&#34;\377\001&#34; # Uses: 426
&#34;\001\000&#34; # Uses: 427
&#34;\000\000\000\031&#34; # Uses: 367
&#34;\377\013&#34; # Uses: 373
&#34;\015\000\000\000&#34; # Uses: 399
&#34;\006UUUUUUU&#34; # Uses: 304
&#34;\0000&#34; # Uses: 359
&#34;\001\000\000\000\000\000\000\002&#34; # Uses: 303
&#34;\011\000&#34; # Uses: 326
&#34;\001\032&#34; # Uses: 279
&#34;\251\252\252\252\252\252\252\012&#34; # Uses: 189
&#34;\377\377\377\377\377\377\377\377&#34; # Uses: 125
###### End of recommended dictionary. ######
Done 160769 runs in 31 second(s)
stat::number_of_executed_units: 160769
stat::average_exec_per_sec:     5186
stat::new_units_added:          704
stat::slowest_unit_time_sec:    0
stat::peak_rss_mb:              43

</pre>


</body>