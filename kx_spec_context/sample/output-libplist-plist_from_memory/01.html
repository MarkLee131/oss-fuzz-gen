<!doctype html>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Experiment results</title>
<style>
* {
    box-sizing: border-box;
}

html {
    line-height: 1.15;
}

body {
    font-family: sans-serif;
    font-size: 16px;
}

table {
    border-collapse: collapse;
    border-spacing: 0;
}

td, th {
    border-right: 1px #dedede solid;
    border-bottom: 1px #dedede solid;
    padding: 5px;
    text-align: left;
}
td:first-child, th:first-child {
    border-left: 1px #dedede solid;
}
th {
    border-top: 1px #dedede solid;
}

tbody tr:nth-child(odd) {
    background-color: #f4f5ff;
}
</style>
<body>
    LLM:

<h1>output-libplist-plist_from_memory / 01</h1>
Bug: True
<br>
Crash reason: NO_SEMANTIC_ERR
<br>
<br>

<h2>Triage</h2>
<pre>
Crash is caused by bug in fuzz driver.

The crash is triggered by the `abort()` call within the fuzz driver when `plist` is `nullptr` despite `plist_from_memory` returning `PLIST_ERR_SUCCESS`. This indicates that the driver is not handling the output of `plist_from_memory` correctly, leading to the `abort()` call. Proper handling or additional checks in the fuzz driver could prevent this crash.
</pre>
<br>





<h3>Final code</h3>

<pre>
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

extern &#34;C&#34; {
#include &#34;plist/plist.h&#34;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    // Initialize the library or any resources within plist_from_memory within libplist needed for the fuzzing process here.
    // No specific initialization required for libplist.
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    FuzzedDataProvider dataProvider(data, size);

    // Generate fuzzed data for the parameters
    std::vector&lt;char&gt; plist_data_vector = dataProvider.ConsumeRemainingBytes&lt;char&gt;();
    const char *plist_data = plist_data_vector.data();
    uint32_t length = static_cast&lt;uint32_t&gt;(plist_data_vector.size());
    plist_t plist = nullptr;
    plist_format_t format;

    // Call the function under test
    plist_err_t result = plist_from_memory(plist_data, length, &amp;plist, &amp;format);

    // Validate the result and postconditions
    if (result == PLIST_ERR_SUCCESS) {
        // Ensure plist is non-null
        if (plist == nullptr) {
            std::cerr &lt;&lt; &#34;Error: plist is null on success.&#34; &lt;&lt; std::endl;
            abort();
        }
        // If format pointer was provided, ensure it is set correctly
        switch (format) {
            case PLIST_FORMAT_BINARY:
            case PLIST_FORMAT_XML:
            case PLIST_FORMAT_JSON:
            case PLIST_FORMAT_OSTEP:
                break;
            default:
                std::cerr &lt;&lt; &#34;Error: Invalid plist format.&#34; &lt;&lt; std::endl;
                abort();
        }
    } else {
        // Ensure plist is null on failure
        if (plist != nullptr) {
            std::cerr &lt;&lt; &#34;Error: plist is not null on failure.&#34; &lt;&lt; std::endl;
            abort();
        }
    }

    // Free resources if necessary
    if (plist != nullptr) {
        plist_free(plist);
    }

    return 0;
}
</pre>


<h3>Fixer prompt #1</h3>
<pre>

Given the following C++ fuzz harness and its build error message, fix the code to make it build for fuzzing.

If there is undeclared identifier or unknown type name error, fix it by finding and including the related libraries.

You MUST wrap the headers with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; if they are C headers, especially the headers are from the project.

Note that some code may need to be wrapped with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; as their source is C program.

MUST RETURN THE FULL CODE, INCLUDING UNCHANGED PARTS.
EXTREMELY IMPORTANT: AVOID USING &lt;code&gt;goto&lt;/code&gt;. If you have to write code using &lt;code&gt;goto&lt;/code&gt;, you MUST MUST also declare all variables BEFORE the &lt;code&gt;goto&lt;/code&gt;. Never introduce new variables after the &lt;code&gt;goto&lt;/code&gt;.

Below is the code needs to be built:
&lt;code&gt;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

extern &#34;C&#34; {
#include &#34;plist/plist.h&#34;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    // Initialize the library or any resources within plist_from_memory within libplist needed for the fuzzing process here.
    // No specific initialization required for libplist.
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    FuzzedDataProvider dataProvider(data, size);

    // Generate fuzzed data for the parameters
    const char *plist_data = dataProvider.ConsumeRemainingBytes&lt;char&gt;();
    uint32_t length = static_cast&lt;uint32_t&gt;(dataProvider.ConsumeIntegralInRange&lt;uint32_t&gt;(1, size));
    plist_t plist = nullptr;
    plist_format_t format;

    // Call the function under test
    plist_err_t result = plist_from_memory(plist_data, length, &amp;plist, &amp;format);

    // Validate the result and postconditions
    if (result == PLIST_ERR_SUCCESS) {
        // Ensure plist is non-null
        if (plist == nullptr) {
            std::cerr &lt;&lt; &#34;Error: plist is null on success.&#34; &lt;&lt; std::endl;
            abort();
        }
        // If format pointer was provided, ensure it is set correctly
        if (&amp;format != nullptr) {
            switch (format) {
                case PLIST_FORMAT_BINARY:
                case PLIST_FORMAT_XML:
                case PLIST_FORMAT_JSON:
                case PLIST_FORMAT_OSTEP:
                    break;
                default:
                    std::cerr &lt;&lt; &#34;Error: Invalid plist format.&#34; &lt;&lt; std::endl;
                    abort();
            }
        }
    } else {
        // Ensure plist is null on failure
        if (plist != nullptr) {
            std::cerr &lt;&lt; &#34;Error: plist is not null on failure.&#34; &lt;&lt; std::endl;
            abort();
        }
    }

    // Free resources if necessary
    if (plist != nullptr) {
        plist_free(plist);
    }

    return 0;
}
&lt;/code&gt;

The code has the following build issues:
&lt;error&gt;
fuzz/oplist_fuzzer.cc:28:17: error: no viable conversion from &#39;std::vector&lt;char&gt;&#39; to &#39;const char *&#39;
   28 |     const char *plist_data = dataProvider.ConsumeRemainingBytes&lt;char&gt;();
      |                 ^            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
fuzz/oplist_fuzzer.cc:44:14: warning: comparison of address of &#39;format&#39; not equal to a null pointer is always true [-Wtautological-pointer-compare]
   44 |         if (&amp;format != nullptr) {
      |              ^~~~~~    ~~~~~~~
&lt;/error&gt;

Fix code:
1. Consider possible solutions for the issues listed above.
2. Choose a solution that can maximize fuzzing result, which is utilizing the function under test and feeding it not null input.
3. Apply the solutions to the original code.
It&#39;s important to show the complete code, not only the fixed line.
&lt;solution&gt;
</pre>



<h3>Code #1</h3>

<pre>
Here is the fixed code with the necessary changes to address the build issues:

```cpp
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

extern &#34;C&#34; {
#include &#34;plist/plist.h&#34;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    // Initialize the library or any resources within plist_from_memory within libplist needed for the fuzzing process here.
    // No specific initialization required for libplist.
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    FuzzedDataProvider dataProvider(data, size);

    // Generate fuzzed data for the parameters
    std::vector&lt;char&gt; plist_data_vector = dataProvider.ConsumeRemainingBytes&lt;char&gt;();
    const char *plist_data = plist_data_vector.data();
    uint32_t length = static_cast&lt;uint32_t&gt;(dataProvider.ConsumeIntegralInRange&lt;uint32_t&gt;(1, size));
    plist_t plist = nullptr;
    plist_format_t format;

    // Call the function under test
    plist_err_t result = plist_from_memory(plist_data, length, &amp;plist, &amp;format);

    // Validate the result and postconditions
    if (result == PLIST_ERR_SUCCESS) {
        // Ensure plist is non-null
        if (plist == nullptr) {
            std::cerr &lt;&lt; &#34;Error: plist is null on success.&#34; &lt;&lt; std::endl;
            abort();
        }
        // If format pointer was provided, ensure it is set correctly
        switch (format) {
            case PLIST_FORMAT_BINARY:
            case PLIST_FORMAT_XML:
            case PLIST_FORMAT_JSON:
            case PLIST_FORMAT_OSTEP:
                break;
            default:
                std::cerr &lt;&lt; &#34;Error: Invalid plist format.&#34; &lt;&lt; std::endl;
                abort();
        }
    } else {
        // Ensure plist is null on failure
        if (plist != nullptr) {
            std::cerr &lt;&lt; &#34;Error: plist is not null on failure.&#34; &lt;&lt; std::endl;
            abort();
        }
    }

    // Free resources if necessary
    if (plist != nullptr) {
        plist_free(plist);
    }

    return 0;
}
```

### Changes made:
1. **Line 28:** Changed the assignment to use a `std::vector&lt;char&gt;` to store the consumed bytes and then used `.data()` to get the pointer to the underlying array.
2. **Line 44:** Removed the unnecessary check `if (&amp;format != nullptr)` since it is always true.

This should resolve the build issues and ensure the code runs correctly for fuzzing.
</pre>


<h3>Fixer prompt #2</h3>
<pre>

Given the following C++ fuzz harness and its build error message, fix the code to make it build for fuzzing.

If there is undeclared identifier or unknown type name error, fix it by finding and including the related libraries.

You MUST wrap the headers with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; if they are C headers, especially the headers are from the project.

Note that some code may need to be wrapped with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; as their source is C program.

MUST RETURN THE FULL CODE, INCLUDING UNCHANGED PARTS.
EXTREMELY IMPORTANT: AVOID USING &lt;code&gt;goto&lt;/code&gt;. If you have to write code using &lt;code&gt;goto&lt;/code&gt;, you MUST MUST also declare all variables BEFORE the &lt;code&gt;goto&lt;/code&gt;. Never introduce new variables after the &lt;code&gt;goto&lt;/code&gt;.

Below is the code needs to be built:
&lt;code&gt;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

extern &#34;C&#34; {
#include &#34;plist/plist.h&#34;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    // Initialize the library or any resources within plist_from_memory within libplist needed for the fuzzing process here.
    // No specific initialization required for libplist.
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    FuzzedDataProvider dataProvider(data, size);

    // Generate fuzzed data for the parameters
    std::vector&lt;char&gt; plist_data_vector = dataProvider.ConsumeRemainingBytes&lt;char&gt;();
    const char *plist_data = plist_data_vector.data();
    uint32_t length = static_cast&lt;uint32_t&gt;(dataProvider.ConsumeIntegralInRange&lt;uint32_t&gt;(1, size));
    plist_t plist = nullptr;
    plist_format_t format;

    // Call the function under test
    plist_err_t result = plist_from_memory(plist_data, length, &amp;plist, &amp;format);

    // Validate the result and postconditions
    if (result == PLIST_ERR_SUCCESS) {
        // Ensure plist is non-null
        if (plist == nullptr) {
            std::cerr &lt;&lt; &#34;Error: plist is null on success.&#34; &lt;&lt; std::endl;
            abort();
        }
        // If format pointer was provided, ensure it is set correctly
        switch (format) {
            case PLIST_FORMAT_BINARY:
            case PLIST_FORMAT_XML:
            case PLIST_FORMAT_JSON:
            case PLIST_FORMAT_OSTEP:
                break;
            default:
                std::cerr &lt;&lt; &#34;Error: Invalid plist format.&#34; &lt;&lt; std::endl;
                abort();
        }
    } else {
        // Ensure plist is null on failure
        if (plist != nullptr) {
            std::cerr &lt;&lt; &#34;Error: plist is not null on failure.&#34; &lt;&lt; std::endl;
            abort();
        }
    }

    // Free resources if necessary
    if (plist != nullptr) {
        plist_free(plist);
    }

    return 0;
}
&lt;/code&gt;

The code can build successfully but has a runtime issue: Fuzzing crashed immediately at runtime (ASAN-ERROR: AddressSanitizer: ABRT on unknown address 0x000000000011 (pc 0x7fa880f5c00b bp 0x7ffc807a9f50 sp 0x7ffc807a9c30 T0)), indicating fuzz target code for invoking the function under test is incorrect or unrobust.
&lt;error&gt;
Crash stacks:
Stack 0:
#0 0x7fa880f5c00b in raise (/lib/x86_64-linux-gnu/libc.so.6+0x4300b) (BuildId: 0702430aef5fa3dda43986563e9ffcc47efbd75e)
#1 0x7fa880f3b858 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x22858) (BuildId: 0702430aef5fa3dda43986563e9ffcc47efbd75e)
#2 0x55c198d30ebd in ConsumeIntegralInRange&lt;unsigned int&gt; /usr/local/lib/clang/18/include/fuzzer/FuzzedDataProvider.h:209:5
#3 0x55c198d30ebd in LLVMFuzzerTestOneInput /src/libplist/fuzz/oplist_fuzzer.cc:30:58
#4 0x55c198be3390 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13
#5 0x55c198be4891 in fuzzer::Fuzzer::ReadAndExecuteSeedCorpora(std::__Fuzzer::vector&lt;fuzzer::SizedFile, std::__Fuzzer::allocator&lt;fuzzer::SizedFile&gt;&gt;&amp;) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:807:3
#6 0x55c198be4e77 in fuzzer::Fuzzer::Loop(std::__Fuzzer::vector&lt;fuzzer::SizedFile, std::__Fuzzer::allocator&lt;fuzzer::SizedFile&gt;&gt;&amp;) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:867:3
#7 0x55c198bd3486 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:914:6
#8 0x55c198bff9b2 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10
#9 0x7fa880f3d082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 0702430aef5fa3dda43986563e9ffcc47efbd75e)
#10 0x55c198bc45fd in _start (/out/oplist_fuzzer+0x715fd)
&lt;/error&gt;

Fix code:
1. Consider possible solutions for the issues listed above.
2. Choose a solution that can maximize fuzzing result, which is utilizing the function under test and feeding it not null input.
3. Apply the solutions to the original code.
It&#39;s important to show the complete code, not only the fixed line.
&lt;solution&gt;
</pre>



<h3>Code #2</h3>

<pre>
To address the runtime issue with the fuzzing target, we need to ensure that the `length` parameter passed to `plist_from_memory` is within the bounds of the actual data size. The crash is likely due to an invalid memory access because `length` is being set to a value that exceeds the size of the `plist_data_vector`.

Here&#39;s the fixed code:

```cpp
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

extern &#34;C&#34; {
#include &#34;plist/plist.h&#34;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    // Initialize the library or any resources within plist_from_memory within libplist needed for the fuzzing process here.
    // No specific initialization required for libplist.
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    FuzzedDataProvider dataProvider(data, size);

    // Generate fuzzed data for the parameters
    std::vector&lt;char&gt; plist_data_vector = dataProvider.ConsumeRemainingBytes&lt;char&gt;();
    const char *plist_data = plist_data_vector.data();
    uint32_t length = static_cast&lt;uint32_t&gt;(plist_data_vector.size());
    plist_t plist = nullptr;
    plist_format_t format;

    // Call the function under test
    plist_err_t result = plist_from_memory(plist_data, length, &amp;plist, &amp;format);

    // Validate the result and postconditions
    if (result == PLIST_ERR_SUCCESS) {
        // Ensure plist is non-null
        if (plist == nullptr) {
            std::cerr &lt;&lt; &#34;Error: plist is null on success.&#34; &lt;&lt; std::endl;
            abort();
        }
        // If format pointer was provided, ensure it is set correctly
        switch (format) {
            case PLIST_FORMAT_BINARY:
            case PLIST_FORMAT_XML:
            case PLIST_FORMAT_JSON:
            case PLIST_FORMAT_OSTEP:
                break;
            default:
                std::cerr &lt;&lt; &#34;Error: Invalid plist format.&#34; &lt;&lt; std::endl;
                abort();
        }
    } else {
        // Ensure plist is null on failure
        if (plist != nullptr) {
            std::cerr &lt;&lt; &#34;Error: plist is not null on failure.&#34; &lt;&lt; std::endl;
            abort();
        }
    }

    // Free resources if necessary
    if (plist != nullptr) {
        plist_free(plist);
    }

    return 0;
}
```

### Explanation of Changes:
1. **Length Calculation**: Instead of using `dataProvider.ConsumeIntegralInRange&lt;uint32_t&gt;(1, size)`, which could potentially exceed the actual size of `plist_data_vector`, I directly use the size of `plist_data_vector` for the `length` parameter. This ensures that the length is always within the bounds of the actual data size.

2. **Data Consumption**: The `dataProvider.ConsumeRemainingBytes&lt;char&gt;()` method consumes all remaining bytes from the input data, ensuring that `plist_data_vector` contains all the data provided by the fuzzer.

These changes should prevent out-of-bounds access and make the fuzzing target more robust.
</pre>


<h2>Logs</h2>
<pre>
Fixing /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-libplist-plist_from_memory/fixed_targets/01.cc with gpt-4o, attempt 1.
Fixing /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-libplist-plist_from_memory/fixed_targets/01.cc with gpt-4o, attempt 2.
Successfully built /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-libplist-plist_from_memory/fixed_targets/01.cc with gpt-4o in 2 iterations of fixing.
Triaging the crash related to /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-libplist-plist_from_memory/fixed_targets/01.cc with gpt-4o.
Result for libplist-plist_from_memory-01: crashes=True, coverage=0.08651138981315587 (338/3907), coverage diff=0.006002728512960437 (44/7330)

</pre>

<h2>Run logs</h2>
<pre>
INFO:__main__:Running: docker run --rm --privileged --shm-size=2g --platform linux/amd64 -e FUZZING_ENGINE=libfuzzer -e SANITIZER=address -e RUN_FUZZER_MODE=interactive -e HELPER=True -v /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-libplist-plist_from_memory/corpora/01.cc:/tmp/oplist_fuzzer_corpus -v /tmp/tmpqe63huln/build/out/libplist-plist_from_memory-01:/out -t gcr.io/oss-fuzz-base/base-runner run_fuzzer oplist_fuzzer -print_final_stats=1 -max_total_time=30 -len_control=0 -timeout=30.
vm.mmap_rnd_bits = 28
rm: cannot remove &#39;/tmp/oplist_fuzzer_corpus&#39;: Device or resource busy
Using seed corpus: oplist_fuzzer_seed_corpus.zip
/out/oplist_fuzzer -rss_limit_mb=2560 -timeout=25 -print_final_stats=1 -max_total_time=30 -len_control=0 -timeout=30 /tmp/oplist_fuzzer_corpus -max_len=4096 -dict=oplist.dict &lt; /dev/null
Dictionary: 41 entries
INFO: Running with entropic power schedule (0xFF, 100).
INFO: Seed: 1960784405
INFO: Loaded 1 modules   (3907 inline 8-bit counters): 3907 [0x562bc82d9948, 0x562bc82da88b),
INFO: Loaded 1 PC tables (3907 PCs): 3907 [0x562bc82da890,0x562bc82e9cc0),
INFO:        3 files found in /tmp/oplist_fuzzer_corpus
INFO: seed corpus: files: 3 min: 341b max: 566b total: 1368b rss: 31Mb
#4	INITED cov: 155 ft: 307 corp: 3/1368b exec/s: 0 rss: 32Mb
#5	NEW    cov: 168 ft: 351 corp: 4/1709b lim: 4096 exec/s: 0 rss: 32Mb L: 341/566 MS: 1 ChangeByte-
#8	NEW    cov: 169 ft: 383 corp: 5/2171b lim: 4096 exec/s: 0 rss: 32Mb L: 462/566 MS: 3 ChangeBinInt-InsertByte-ManualDict- DE: &#34;\\t&#34;-
#10	NEW    cov: 170 ft: 388 corp: 6/2633b lim: 4096 exec/s: 0 rss: 32Mb L: 462/566 MS: 2 ChangeBit-PersAutoDict- DE: &#34;\\t&#34;-
#11	NEW    cov: 171 ft: 406 corp: 7/3094b lim: 4096 exec/s: 0 rss: 32Mb L: 461/566 MS: 1 CopyPart-
#12	NEW    cov: 171 ft: 409 corp: 8/3558b lim: 4096 exec/s: 0 rss: 32Mb L: 464/566 MS: 1 PersAutoDict- DE: &#34;\\t&#34;-
#13	REDUCE cov: 171 ft: 409 corp: 8/3556b lim: 4096 exec/s: 0 rss: 32Mb L: 460/566 MS: 1 EraseBytes-
#14	NEW    cov: 172 ft: 428 corp: 9/4106b lim: 4096 exec/s: 0 rss: 33Mb L: 550/566 MS: 1 EraseBytes-
#15	NEW    cov: 173 ft: 433 corp: 10/4672b lim: 4096 exec/s: 0 rss: 33Mb L: 566/566 MS: 1 ChangeBinInt-
#18	NEW    cov: 174 ft: 469 corp: 11/5103b lim: 4096 exec/s: 0 rss: 33Mb L: 431/566 MS: 3 ChangeBinInt-InsertByte-InsertRepeatedBytes-
#20	NEW    cov: 174 ft: 471 corp: 12/5519b lim: 4096 exec/s: 0 rss: 33Mb L: 416/566 MS: 2 CMP-InsertRepeatedBytes- DE: &#34;\001\001&#34;-
#21	NEW    cov: 174 ft: 496 corp: 13/5860b lim: 4096 exec/s: 0 rss: 33Mb L: 341/566 MS: 1 ManualDict- DE: &#34;,0&#34;-
#25	NEW    cov: 175 ft: 521 corp: 14/6709b lim: 4096 exec/s: 0 rss: 33Mb L: 849/849 MS: 4 ChangeByte-CopyPart-ChangeByte-ChangeByte-
#30	REDUCE cov: 175 ft: 538 corp: 15/7210b lim: 4096 exec/s: 0 rss: 33Mb L: 501/849 MS: 5 ChangeByte-InsertRepeatedBytes-ChangeBit-ChangeBinInt-EraseBytes-
#31	NEW    cov: 175 ft: 542 corp: 16/7733b lim: 4096 exec/s: 0 rss: 33Mb L: 523/849 MS: 1 CopyPart-
#35	REDUCE cov: 175 ft: 543 corp: 17/8072b lim: 4096 exec/s: 0 rss: 33Mb L: 339/849 MS: 4 ChangeASCIIInt-InsertByte-ManualDict-EraseBytes- DE: &#34;\\r&#34;-
#36	NEW    cov: 175 ft: 564 corp: 18/8622b lim: 4096 exec/s: 0 rss: 33Mb L: 550/849 MS: 1 CMP- DE: &#34;\003\000\000\000&#34;-
#37	NEW    cov: 175 ft: 597 corp: 19/8964b lim: 4096 exec/s: 0 rss: 33Mb L: 342/849 MS: 1 InsertByte-
#41	REDUCE cov: 175 ft: 597 corp: 19/8936b lim: 4096 exec/s: 0 rss: 33Mb L: 473/849 MS: 4 CrossOver-ChangeBinInt-ChangeASCIIInt-EraseBytes-
#47	NEW    cov: 176 ft: 600 corp: 20/9399b lim: 4096 exec/s: 0 rss: 33Mb L: 463/849 MS: 1 PersAutoDict- DE: &#34;\\r&#34;-
#48	NEW    cov: 176 ft: 608 corp: 21/9782b lim: 4096 exec/s: 0 rss: 33Mb L: 383/849 MS: 1 EraseBytes-
#49	NEW    cov: 176 ft: 613 corp: 22/10348b lim: 4096 exec/s: 0 rss: 33Mb L: 566/849 MS: 1 CrossOver-
#56	REDUCE cov: 176 ft: 613 corp: 22/10206b lim: 4096 exec/s: 0 rss: 33Mb L: 289/849 MS: 2 ChangeBit-EraseBytes-
#57	NEW    cov: 176 ft: 623 corp: 23/10547b lim: 4096 exec/s: 0 rss: 33Mb L: 341/849 MS: 1 PersAutoDict- DE: &#34;\001\001&#34;-
#63	REDUCE cov: 176 ft: 623 corp: 23/10310b lim: 4096 exec/s: 0 rss: 33Mb L: 612/612 MS: 1 EraseBytes-
#64	NEW    cov: 176 ft: 625 corp: 24/10652b lim: 4096 exec/s: 0 rss: 33Mb L: 342/612 MS: 1 CopyPart-
#65	NEW    cov: 176 ft: 626 corp: 25/11113b lim: 4096 exec/s: 0 rss: 33Mb L: 461/612 MS: 1 ShuffleBytes-
#66	NEW    cov: 176 ft: 632 corp: 26/11352b lim: 4096 exec/s: 0 rss: 33Mb L: 239/612 MS: 1 CrossOver-
#70	NEW    cov: 176 ft: 634 corp: 27/11715b lim: 4096 exec/s: 0 rss: 33Mb L: 363/612 MS: 4 ChangeBinInt-ChangeBit-ChangeBinInt-EraseBytes-
#82	NEW    cov: 176 ft: 645 corp: 28/12282b lim: 4096 exec/s: 0 rss: 34Mb L: 567/612 MS: 2 ShuffleBytes-InsertByte-
	NEW_FUNC[1/1]: 0x562bc8189f10 in plist_new_dict /src/libplist/src/plist.c:470
#83	NEW    cov: 181 ft: 652 corp: 29/12926b lim: 4096 exec/s: 41 rss: 34Mb L: 644/644 MS: 1 CopyPart-
#91	REDUCE cov: 181 ft: 652 corp: 29/12917b lim: 4096 exec/s: 45 rss: 34Mb L: 603/644 MS: 3 ChangeASCIIInt-CrossOver-EraseBytes-
#102	REDUCE cov: 181 ft: 652 corp: 29/12891b lim: 4096 exec/s: 51 rss: 35Mb L: 316/644 MS: 1 EraseBytes-
#106	NEW    cov: 181 ft: 665 corp: 30/13307b lim: 4096 exec/s: 53 rss: 35Mb L: 416/644 MS: 4 ChangeBit-ChangeBinInt-ShuffleBytes-CopyPart-
#108	NEW    cov: 181 ft: 670 corp: 31/14102b lim: 4096 exec/s: 54 rss: 35Mb L: 795/795 MS: 2 InsertRepeatedBytes-CrossOver-
#117	NEW    cov: 181 ft: 675 corp: 32/14440b lim: 4096 exec/s: 58 rss: 35Mb L: 338/795 MS: 4 PersAutoDict-InsertRepeatedBytes-CopyPart-EraseBytes- DE: &#34;\001\001&#34;-
#118	NEW    cov: 181 ft: 678 corp: 33/14904b lim: 4096 exec/s: 59 rss: 35Mb L: 464/795 MS: 1 ChangeBit-
#128	pulse  cov: 181 ft: 678 corp: 33/14904b lim: 4096 exec/s: 64 rss: 35Mb
#132	NEW    cov: 181 ft: 688 corp: 34/15386b lim: 4096 exec/s: 66 rss: 35Mb L: 482/795 MS: 4 ChangeByte-InsertByte-ChangeBit-EraseBytes-
#136	NEW    cov: 181 ft: 692 corp: 35/15855b lim: 4096 exec/s: 68 rss: 35Mb L: 469/795 MS: 4 ChangeBinInt-PersAutoDict-ChangeBit-EraseBytes- DE: &#34;\\r&#34;-
#140	NEW    cov: 181 ft: 694 corp: 36/16199b lim: 4096 exec/s: 70 rss: 35Mb L: 344/795 MS: 4 InsertRepeatedBytes-ManualDict-EraseBytes-InsertByte- DE: &#34;,{}&#34;-
#148	NEW    cov: 181 ft: 696 corp: 37/16Kb lim: 4096 exec/s: 74 rss: 35Mb L: 463/795 MS: 3 ChangeBinInt-ChangeASCIIInt-CrossOver-
#149	NEW    cov: 181 ft: 697 corp: 38/16Kb lim: 4096 exec/s: 74 rss: 35Mb L: 239/795 MS: 1 ChangeBinInt-
#153	NEW    cov: 181 ft: 698 corp: 39/16Kb lim: 4096 exec/s: 76 rss: 35Mb L: 44/795 MS: 4 InsertByte-EraseBytes-CrossOver-InsertRepeatedBytes-
#175	NEW    cov: 181 ft: 710 corp: 40/17Kb lim: 4096 exec/s: 87 rss: 35Mb L: 566/795 MS: 2 ChangeBit-ChangeByte-
#181	NEW    cov: 182 ft: 713 corp: 41/17Kb lim: 4096 exec/s: 90 rss: 35Mb L: 464/795 MS: 1 InsertByte-
#184	REDUCE cov: 182 ft: 713 corp: 41/17Kb lim: 4096 exec/s: 92 rss: 35Mb L: 338/795 MS: 3 ShuffleBytes-ChangeASCIIInt-EraseBytes-
#195	REDUCE cov: 182 ft: 713 corp: 41/17Kb lim: 4096 exec/s: 97 rss: 35Mb L: 292/795 MS: 1 EraseBytes-
#196	REDUCE cov: 182 ft: 713 corp: 41/17Kb lim: 4096 exec/s: 98 rss: 35Mb L: 408/795 MS: 1 EraseBytes-
#207	NEW    cov: 183 ft: 717 corp: 42/18Kb lim: 4096 exec/s: 103 rss: 35Mb L: 645/795 MS: 1 InsertByte-
#210	REDUCE cov: 183 ft: 717 corp: 42/17Kb lim: 4096 exec/s: 105 rss: 35Mb L: 300/795 MS: 3 CopyPart-CrossOver-EraseBytes-
#223	REDUCE cov: 183 ft: 717 corp: 42/17Kb lim: 4096 exec/s: 111 rss: 35Mb L: 274/795 MS: 3 CopyPart-InsertRepeatedBytes-EraseBytes-
#229	NEW    cov: 183 ft: 718 corp: 43/18Kb lim: 4096 exec/s: 114 rss: 35Mb L: 775/795 MS: 1 CopyPart-
#231	REDUCE cov: 183 ft: 718 corp: 43/18Kb lim: 4096 exec/s: 115 rss: 35Mb L: 436/795 MS: 2 ChangeByte-EraseBytes-
#232	NEW    cov: 183 ft: 719 corp: 44/18Kb lim: 4096 exec/s: 116 rss: 35Mb L: 405/795 MS: 1 EraseBytes-
#238	REDUCE cov: 183 ft: 719 corp: 44/18Kb lim: 4096 exec/s: 119 rss: 35Mb L: 467/795 MS: 1 EraseBytes-
#239	NEW    cov: 183 ft: 721 corp: 45/20Kb lim: 4096 exec/s: 119 rss: 35Mb L: 1137/1137 MS: 1 CrossOver-
#241	REDUCE cov: 183 ft: 721 corp: 45/19Kb lim: 4096 exec/s: 120 rss: 35Mb L: 446/1137 MS: 2 ShuffleBytes-EraseBytes-
#245	REDUCE cov: 183 ft: 721 corp: 45/19Kb lim: 4096 exec/s: 122 rss: 36Mb L: 248/1137 MS: 4 ChangeByte-ChangeBit-ShuffleB
...truncated...
11/2068 MS: 1 CrossOver-
#7396	REDUCE cov: 332 ft: 1206 corp: 213/75Kb lim: 4096 exec/s: 3698 rss: 57Mb L: 149/2068 MS: 1 EraseBytes-
#7432	NEW    cov: 332 ft: 1209 corp: 214/76Kb lim: 4096 exec/s: 3716 rss: 57Mb L: 566/2068 MS: 1 CopyPart-
#7474	NEW    cov: 332 ft: 1216 corp: 215/77Kb lim: 4096 exec/s: 3737 rss: 57Mb L: 1436/2068 MS: 2 ManualDict-CopyPart- DE: &#34;=()&#34;-
#7477	REDUCE cov: 332 ft: 1216 corp: 215/77Kb lim: 4096 exec/s: 3738 rss: 57Mb L: 606/2068 MS: 3 ShuffleBytes-ManualDict-EraseBytes- DE: &#34;=()&#34;-
#7489	REDUCE cov: 332 ft: 1217 corp: 216/77Kb lim: 4096 exec/s: 3744 rss: 57Mb L: 83/2068 MS: 2 ChangeBit-CopyPart-
#7518	REDUCE cov: 332 ft: 1217 corp: 216/77Kb lim: 4096 exec/s: 3759 rss: 57Mb L: 412/2068 MS: 4 ChangeBit-ManualDict-ChangeByte-EraseBytes- DE: &#34;,0&#34;-
#7527	NEW    cov: 333 ft: 1218 corp: 217/77Kb lim: 4096 exec/s: 3763 rss: 57Mb L: 2/2068 MS: 4 CrossOver-CrossOver-ManualDict-ManualDict- DE: &#34;=0&#34;-&#34;0=&#34;-
#7557	REDUCE cov: 333 ft: 1219 corp: 218/79Kb lim: 4096 exec/s: 3778 rss: 58Mb L: 2057/2068 MS: 5 ChangeByte-CrossOver-InsertByte-InsertRepeatedBytes-CopyPart-
#7558	REDUCE cov: 333 ft: 1219 corp: 218/79Kb lim: 4096 exec/s: 3779 rss: 58Mb L: 2/2068 MS: 1 EraseBytes-
#7565	REDUCE cov: 334 ft: 1222 corp: 219/79Kb lim: 4096 exec/s: 3782 rss: 58Mb L: 161/2068 MS: 2 ChangeBit-ManualDict- DE: &#34;\\0&#34;-
#7616	NEW    cov: 334 ft: 1223 corp: 220/79Kb lim: 4096 exec/s: 3808 rss: 58Mb L: 3/2068 MS: 1 CopyPart-
#7662	NEW    cov: 335 ft: 1236 corp: 221/80Kb lim: 4096 exec/s: 3831 rss: 58Mb L: 1195/2068 MS: 1 CopyPart-
#7689	REDUCE cov: 335 ft: 1236 corp: 221/80Kb lim: 4096 exec/s: 3844 rss: 58Mb L: 295/2068 MS: 2 CrossOver-EraseBytes-
#7710	REDUCE cov: 335 ft: 1236 corp: 221/80Kb lim: 4096 exec/s: 3855 rss: 58Mb L: 8/2068 MS: 1 EraseBytes-
#7715	NEW    cov: 336 ft: 1237 corp: 222/80Kb lim: 4096 exec/s: 3857 rss: 58Mb L: 4/2068 MS: 5 ChangeBit-InsertByte-ShuffleBytes-ChangeByte-PersAutoDict- DE: &#34;0=&#34;-
#7764	REDUCE cov: 336 ft: 1237 corp: 222/80Kb lim: 4096 exec/s: 3882 rss: 58Mb L: 47/2068 MS: 4 ChangeBit-ChangeBinInt-PersAutoDict-EraseBytes- DE: &#34;\\&#34;-
#7803	REDUCE cov: 336 ft: 1237 corp: 222/80Kb lim: 4096 exec/s: 3901 rss: 58Mb L: 110/2068 MS: 4 CrossOver-ChangeByte-InsertByte-EraseBytes-
#7854	REDUCE cov: 336 ft: 1237 corp: 222/80Kb lim: 4096 exec/s: 3927 rss: 58Mb L: 81/2068 MS: 1 EraseBytes-
#7896	NEW    cov: 337 ft: 1238 corp: 223/80Kb lim: 4096 exec/s: 3948 rss: 58Mb L: 1/2068 MS: 2 EraseBytes-ChangeByte-
#7934	REDUCE cov: 337 ft: 1238 corp: 223/80Kb lim: 4096 exec/s: 3967 rss: 58Mb L: 155/2068 MS: 3 CopyPart-InsertByte-EraseBytes-
#7963	REDUCE cov: 337 ft: 1238 corp: 223/80Kb lim: 4096 exec/s: 3981 rss: 58Mb L: 82/2068 MS: 4 ChangeBit-CMP-InsertByte-EraseBytes- DE: &#34;\001\000\000h&#34;-
#7965	REDUCE cov: 337 ft: 1238 corp: 223/80Kb lim: 4096 exec/s: 3982 rss: 58Mb L: 1026/2068 MS: 2 ShuffleBytes-EraseBytes-
#7999	REDUCE cov: 337 ft: 1238 corp: 223/80Kb lim: 4096 exec/s: 3999 rss: 58Mb L: 114/2068 MS: 4 ChangeByte-CopyPart-InsertByte-EraseBytes-
#8007	REDUCE cov: 337 ft: 1239 corp: 224/80Kb lim: 4096 exec/s: 4003 rss: 58Mb L: 168/2068 MS: 3 ChangeByte-InsertByte-CopyPart-
#8018	REDUCE cov: 337 ft: 1239 corp: 224/80Kb lim: 4096 exec/s: 4009 rss: 58Mb L: 242/2068 MS: 1 EraseBytes-
#8025	REDUCE cov: 337 ft: 1239 corp: 224/80Kb lim: 4096 exec/s: 4012 rss: 58Mb L: 157/2068 MS: 2 ChangeByte-EraseBytes-
#8028	REDUCE cov: 337 ft: 1239 corp: 224/80Kb lim: 4096 exec/s: 4014 rss: 58Mb L: 837/2068 MS: 3 ShuffleBytes-CopyPart-EraseBytes-
#8034	REDUCE cov: 337 ft: 1239 corp: 224/80Kb lim: 4096 exec/s: 4017 rss: 58Mb L: 95/2068 MS: 1 EraseBytes-
#8120	REDUCE cov: 337 ft: 1239 corp: 224/80Kb lim: 4096 exec/s: 4060 rss: 58Mb L: 321/2068 MS: 1 EraseBytes-
#8138	REDUCE cov: 337 ft: 1239 corp: 224/79Kb lim: 4096 exec/s: 4069 rss: 58Mb L: 134/2068 MS: 3 PersAutoDict-CMP-EraseBytes- DE: &#34;\001\000\000\000\000\000\000\000&#34;-&#34;\000\000\000\000\000\000\000\001&#34;-
#8139	REDUCE cov: 337 ft: 1239 corp: 224/79Kb lim: 4096 exec/s: 4069 rss: 58Mb L: 239/2068 MS: 1 EraseBytes-
#8140	REDUCE cov: 337 ft: 1240 corp: 225/79Kb lim: 4096 exec/s: 4070 rss: 58Mb L: 7/2068 MS: 1 PersAutoDict- DE: &#34;{\&#34;\&#34;=0}&#34;-
#8149	REDUCE cov: 337 ft: 1240 corp: 225/79Kb lim: 4096 exec/s: 4074 rss: 58Mb L: 289/2068 MS: 4 InsertRepeatedBytes-PersAutoDict-ShuffleBytes-EraseBytes- DE: &#34;\\uD800\\uDC00&#34;-
#8192	pulse  cov: 337 ft: 1240 corp: 225/79Kb lim: 4096 exec/s: 4096 rss: 58Mb
#8206	REDUCE cov: 337 ft: 1240 corp: 225/79Kb lim: 4096 exec/s: 4103 rss: 58Mb L: 229/2068 MS: 2 ChangeBit-EraseBytes-
#8224	REDUCE cov: 337 ft: 1241 corp: 226/79Kb lim: 4096 exec/s: 4112 rss: 58Mb L: 54/2068 MS: 3 ManualDict-ChangeByte-EraseBytes- DE: &#34;\\0&#34;-
#8255	REDUCE cov: 337 ft: 1241 corp: 226/79Kb lim: 4096 exec/s: 4127 rss: 58Mb L: 43/2068 MS: 1 EraseBytes-
#8325	REDUCE cov: 337 ft: 1241 corp: 226/79Kb lim: 4096 exec/s: 4162 rss: 58Mb L: 349/2068 MS: 5 ShuffleBytes-ManualDict-ChangeByte-ChangeBit-EraseBytes- DE: &#34;=\&#34;\&#34;&#34;-
#8336	REDUCE cov: 337 ft: 1241 corp: 226/79Kb lim: 4096 exec/s: 4168 rss: 58Mb L: 258/2068 MS: 1 EraseBytes-
#8358	REDUCE cov: 338 ft: 1242 corp: 227/79Kb lim: 4096 exec/s: 4179 rss: 58Mb L: 591/2068 MS: 2 InsertRepeatedBytes-CrossOver-
#8360	REDUCE cov: 338 ft: 1242 corp: 227/79Kb lim: 4096 exec/s: 4180 rss: 58Mb L: 122/2068 MS: 2 ChangeBinInt-EraseBytes-
#8389	REDUCE cov: 338 ft: 1242 corp: 227/79Kb lim: 4096 exec/s: 4194 rss: 58Mb L: 199/2068 MS: 4 InsertRepeatedBytes-PersAutoDict-ChangeASCIIInt-EraseBytes- DE: &#34;Some Int&#34;-
#8395	REDUCE cov: 338 ft: 1242 corp: 227/79Kb lim: 4096 exec/s: 4197 rss: 58Mb L: 175/2068 MS: 1 EraseBytes-
#8408	REDUCE cov: 338 ft: 1242 corp: 227/79Kb lim: 4096 exec/s: 4204 rss: 58Mb L: 251/2068 MS: 3 InsertByte-ChangeBinInt-EraseBytes-
Error: plist is null on success.
AddressSanitizer:DEADLYSIGNAL
=================================================================
[1m[31m==17==ERROR: AddressSanitizer: ABRT on unknown address 0x000000000011 (pc 0x7f35d31f800b bp 0x7ffc62593260 sp 0x7ffc62592f70 T0)
[1m[0mSCARINESS: 10 (signal)
    #0 0x7f35d31f800b in raise (/lib/x86_64-linux-gnu/libc.so.6+0x4300b) (BuildId: 0702430aef5fa3dda43986563e9ffcc47efbd75e)
    #1 0x7f35d31d7858 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x22858) (BuildId: 0702430aef5fa3dda43986563e9ffcc47efbd75e)
    #2 0x562bc8186dd0 in LLVMFuzzerTestOneInput /src/libplist/fuzz/oplist_fuzzer.cc:42:13
    #3 0x562bc8039390 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13
    #4 0x562bc8038bb5 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool, bool*) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:516:7
    #5 0x562bc803a385 in fuzzer::Fuzzer::MutateAndTestOne() /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:760:19
    #6 0x562bc803b175 in fuzzer::Fuzzer::Loop(std::__Fuzzer::vector&lt;fuzzer::SizedFile, std::__Fuzzer::allocator&lt;fuzzer::SizedFile&gt;&gt;&amp;) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:905:5
    #7 0x562bc8029486 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:914:6
    #8 0x562bc80559b2 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10
    #9 0x7f35d31d9082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 0702430aef5fa3dda43986563e9ffcc47efbd75e)
    #10 0x562bc801a5fd in _start (/out/oplist_fuzzer+0x715fd)

DEDUP_TOKEN: raise--abort--LLVMFuzzerTestOneInput
AddressSanitizer can not provide additional info.
SUMMARY: AddressSanitizer: ABRT (/lib/x86_64-linux-gnu/libc.so.6+0x4300b) (BuildId: 0702430aef5fa3dda43986563e9ffcc47efbd75e) in raise
==17==ABORTING
MS: 1 ChangeBit-; base unit: cd63fcb0130cb6568c8be0f9da5fe17878fa3dde
0x5b,0x3d,0x7b,0x5d,0x2f,0x2f,
[={]//
artifact_prefix=&#39;./&#39;; Test unit written to ./crash-272b719e71e19a8834897ed8de3fa565f7e341e5
Base64: Wz17XS8v
stat::number_of_executed_units: 8414
stat::average_exec_per_sec:     4207
stat::new_units_added:          494
stat::slowest_unit_time_sec:    0
stat::peak_rss_mb:              59

</pre>


</body>