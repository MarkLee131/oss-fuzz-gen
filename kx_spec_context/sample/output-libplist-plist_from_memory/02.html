<!doctype html>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Experiment results</title>
<style>
* {
    box-sizing: border-box;
}

html {
    line-height: 1.15;
}

body {
    font-family: sans-serif;
    font-size: 16px;
}

table {
    border-collapse: collapse;
    border-spacing: 0;
}

td, th {
    border-right: 1px #dedede solid;
    border-bottom: 1px #dedede solid;
    padding: 5px;
    text-align: left;
}
td:first-child, th:first-child {
    border-left: 1px #dedede solid;
}
th {
    border-top: 1px #dedede solid;
}

tbody tr:nth-child(odd) {
    background-color: #f4f5ff;
}
</style>
<body>
    LLM: 
    
<h1>output-libplist-plist_from_memory / 02</h1>
Bug: True
<br>
Crash reason: NO_SEMANTIC_ERR
<br>
<br>

<h2>Triage</h2>
<pre>
Crash is caused by bug in fuzz driver.

Analysis:
The crash occurs due to an explicit call to `abort()` in the fuzz driver when `plist` is found to be `nullptr` despite `plist_from_memory` returning `PLIST_ERR_SUCCESS`. This indicates a logical error in the fuzz driver, where it does not handle the case properly and prematurely aborts the execution.
</pre>
<br>





<h3>Final code</h3>

<pre>
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

extern &#34;C&#34; {
#include &#34;plist/plist.h&#34;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    // Initialize the library or any resources within plist_from_memory within libplist needed for the fuzzing process here.
    // No specific initialization required for libplist.
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    if (size == 0) {
        return 0;
    }

    FuzzedDataProvider dataProvider(data, size);

    // Generate fuzzed data for the parameters
    std::vector&lt;char&gt; plist_data = dataProvider.ConsumeRemainingBytes&lt;char&gt;();
    uint32_t length = static_cast&lt;uint32_t&gt;(plist_data.size());
    plist_t plist = nullptr;
    plist_format_t format;

    // Call the function under test
    plist_err_t result = plist_from_memory(plist_data.data(), length, &amp;plist, &amp;format);

    // Validate the result and postconditions
    if (result == PLIST_ERR_SUCCESS) {
        // Ensure plist is non-null
        if (plist == nullptr) {
            std::cerr &lt;&lt; &#34;Error: plist is null on success.&#34; &lt;&lt; std::endl;
            abort();
        }
        // Ensure format is set correctly
        switch (format) {
            case PLIST_FORMAT_BINARY:
            case PLIST_FORMAT_XML:
            case PLIST_FORMAT_JSON:
            case PLIST_FORMAT_OSTEP:
                break;
            default:
                std::cerr &lt;&lt; &#34;Error: Invalid plist format.&#34; &lt;&lt; std::endl;
                abort();
        }
    } else {
        // Ensure plist is null on failure
        if (plist != nullptr) {
            std::cerr &lt;&lt; &#34;Error: plist is not null on failure.&#34; &lt;&lt; std::endl;
            abort();
        }
    }

    // Free resources if necessary
    if (plist != nullptr) {
        plist_free(plist);
    }

    return 0;
}
</pre>


<h3>Fixer prompt #1</h3>
<pre>

Given the following C++ fuzz harness and its build error message, fix the code to make it build for fuzzing.

If there is undeclared identifier or unknown type name error, fix it by finding and including the related libraries.

You MUST wrap the headers with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; if they are C headers, especially the headers are from the project.

Note that some code may need to be wrapped with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; as their source is C program.

MUST RETURN THE FULL CODE, INCLUDING UNCHANGED PARTS.
EXTREMELY IMPORTANT: AVOID USING &lt;code&gt;goto&lt;/code&gt;. If you have to write code using &lt;code&gt;goto&lt;/code&gt;, you MUST MUST also declare all variables BEFORE the &lt;code&gt;goto&lt;/code&gt;. Never introduce new variables after the &lt;code&gt;goto&lt;/code&gt;.

Below is the code needs to be built:
&lt;code&gt;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

extern &#34;C&#34; {
#include &#34;plist/plist.h&#34;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    // Initialize the library or any resources within plist_from_memory within libplist needed for the fuzzing process here.
    // No specific initialization required for libplist.
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    FuzzedDataProvider dataProvider(data, size);

    // Generate fuzzed data for the parameters
    const char *plist_data = dataProvider.ConsumeRemainingBytes&lt;char&gt;();
    uint32_t length = static_cast&lt;uint32_t&gt;(dataProvider.ConsumeIntegralInRange&lt;uint32_t&gt;(1, size));
    plist_t plist = nullptr;
    plist_format_t format;

    // Call the function under test
    plist_err_t result = plist_from_memory(plist_data, length, &amp;plist, &amp;format);

    // Validate the result and postconditions
    if (result == PLIST_ERR_SUCCESS) {
        // Ensure plist is non-null
        if (plist == nullptr) {
            std::cerr &lt;&lt; &#34;Error: plist is null on success.&#34; &lt;&lt; std::endl;
            abort();
        }
        // If format pointer was provided, ensure it is set correctly
        if (&amp;format != nullptr) {
            switch (format) {
                case PLIST_FORMAT_BINARY:
                case PLIST_FORMAT_XML:
                case PLIST_FORMAT_JSON:
                case PLIST_FORMAT_OSTEP:
                    break;
                default:
                    std::cerr &lt;&lt; &#34;Error: Invalid plist format.&#34; &lt;&lt; std::endl;
                    abort();
            }
        }
    } else {
        // Ensure plist is null on failure
        if (plist != nullptr) {
            std::cerr &lt;&lt; &#34;Error: plist is not null on failure.&#34; &lt;&lt; std::endl;
            abort();
        }
    }

    // Free resources if necessary
    if (plist != nullptr) {
        plist_free(plist);
    }

    return 0;
}
&lt;/code&gt;

The code has the following build issues:
&lt;error&gt;
fuzz/oplist_fuzzer.cc:28:17: error: no viable conversion from &#39;std::vector&lt;char&gt;&#39; to &#39;const char *&#39;
   28 |     const char *plist_data = dataProvider.ConsumeRemainingBytes&lt;char&gt;();
      |                 ^            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
fuzz/oplist_fuzzer.cc:44:14: warning: comparison of address of &#39;format&#39; not equal to a null pointer is always true [-Wtautological-pointer-compare]
   44 |         if (&amp;format != nullptr) {
      |              ^~~~~~    ~~~~~~~
&lt;/error&gt;

Fix code:
1. Consider possible solutions for the issues listed above.
2. Choose a solution that can maximize fuzzing result, which is utilizing the function under test and feeding it not null input.
3. Apply the solutions to the original code.
It&#39;s important to show the complete code, not only the fixed line.
&lt;solution&gt;
</pre>



<h3>Code #1</h3>

<pre>
Here is the fixed code:

```cpp
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

extern &#34;C&#34; {
#include &#34;plist/plist.h&#34;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    // Initialize the library or any resources within plist_from_memory within libplist needed for the fuzzing process here.
    // No specific initialization required for libplist.
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    FuzzedDataProvider dataProvider(data, size);

    // Generate fuzzed data for the parameters
    std::vector&lt;char&gt; plist_data = dataProvider.ConsumeRemainingBytes&lt;char&gt;();
    uint32_t length = static_cast&lt;uint32_t&gt;(dataProvider.ConsumeIntegralInRange&lt;uint32_t&gt;(1, size));
    plist_t plist = nullptr;
    plist_format_t format;

    // Call the function under test
    plist_err_t result = plist_from_memory(plist_data.data(), length, &amp;plist, &amp;format);

    // Validate the result and postconditions
    if (result == PLIST_ERR_SUCCESS) {
        // Ensure plist is non-null
        if (plist == nullptr) {
            std::cerr &lt;&lt; &#34;Error: plist is null on success.&#34; &lt;&lt; std::endl;
            abort();
        }
        // Ensure format is set correctly
        switch (format) {
            case PLIST_FORMAT_BINARY:
            case PLIST_FORMAT_XML:
            case PLIST_FORMAT_JSON:
            case PLIST_FORMAT_OSTEP:
                break;
            default:
                std::cerr &lt;&lt; &#34;Error: Invalid plist format.&#34; &lt;&lt; std::endl;
                abort();
        }
    } else {
        // Ensure plist is null on failure
        if (plist != nullptr) {
            std::cerr &lt;&lt; &#34;Error: plist is not null on failure.&#34; &lt;&lt; std::endl;
            abort();
        }
    }

    // Free resources if necessary
    if (plist != nullptr) {
        plist_free(plist);
    }

    return 0;
}
```

### Explanation of Changes:
1. **Conversion Issue**: The original code tried to assign a `std::vector&lt;char&gt;` to a `const char *`. This was corrected by using `plist_data.data()` to get a pointer to the underlying array.
2. **Tautological Pointer Comparison**: The check `if (&amp;format != nullptr)` was redundant because `&amp;format` will always be non-null. This check was removed, and the subsequent switch statement directly validates the format.

The corrected code ensures that the function `plist_from_memory` is properly tested with non-null input, and the results are validated correctly.
</pre>


<h3>Fixer prompt #2</h3>
<pre>

Given the following C++ fuzz harness and its build error message, fix the code to make it build for fuzzing.

If there is undeclared identifier or unknown type name error, fix it by finding and including the related libraries.

You MUST wrap the headers with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; if they are C headers, especially the headers are from the project.

Note that some code may need to be wrapped with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; as their source is C program.

MUST RETURN THE FULL CODE, INCLUDING UNCHANGED PARTS.
EXTREMELY IMPORTANT: AVOID USING &lt;code&gt;goto&lt;/code&gt;. If you have to write code using &lt;code&gt;goto&lt;/code&gt;, you MUST MUST also declare all variables BEFORE the &lt;code&gt;goto&lt;/code&gt;. Never introduce new variables after the &lt;code&gt;goto&lt;/code&gt;.

Below is the code needs to be built:
&lt;code&gt;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

extern &#34;C&#34; {
#include &#34;plist/plist.h&#34;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    // Initialize the library or any resources within plist_from_memory within libplist needed for the fuzzing process here.
    // No specific initialization required for libplist.
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    FuzzedDataProvider dataProvider(data, size);

    // Generate fuzzed data for the parameters
    std::vector&lt;char&gt; plist_data = dataProvider.ConsumeRemainingBytes&lt;char&gt;();
    uint32_t length = static_cast&lt;uint32_t&gt;(dataProvider.ConsumeIntegralInRange&lt;uint32_t&gt;(1, size));
    plist_t plist = nullptr;
    plist_format_t format;

    // Call the function under test
    plist_err_t result = plist_from_memory(plist_data.data(), length, &amp;plist, &amp;format);

    // Validate the result and postconditions
    if (result == PLIST_ERR_SUCCESS) {
        // Ensure plist is non-null
        if (plist == nullptr) {
            std::cerr &lt;&lt; &#34;Error: plist is null on success.&#34; &lt;&lt; std::endl;
            abort();
        }
        // Ensure format is set correctly
        switch (format) {
            case PLIST_FORMAT_BINARY:
            case PLIST_FORMAT_XML:
            case PLIST_FORMAT_JSON:
            case PLIST_FORMAT_OSTEP:
                break;
            default:
                std::cerr &lt;&lt; &#34;Error: Invalid plist format.&#34; &lt;&lt; std::endl;
                abort();
        }
    } else {
        // Ensure plist is null on failure
        if (plist != nullptr) {
            std::cerr &lt;&lt; &#34;Error: plist is not null on failure.&#34; &lt;&lt; std::endl;
            abort();
        }
    }

    // Free resources if necessary
    if (plist != nullptr) {
        plist_free(plist);
    }

    return 0;
}
&lt;/code&gt;

The code can build successfully but has a runtime issue: Fuzzing crashed immediately at runtime (ASAN-ERROR: AddressSanitizer: ABRT on unknown address 0x000000000011 (pc 0x7fee9e24500b bp 0x7ffdd4110060 sp 0x7ffdd410fd50 T0)), indicating fuzz target code for invoking the function under test is incorrect or unrobust.
&lt;error&gt;
Crash stacks:
Stack 0:
#0 0x7fee9e24500b in raise (/lib/x86_64-linux-gnu/libc.so.6+0x4300b) (BuildId: 0702430aef5fa3dda43986563e9ffcc47efbd75e)
#1 0x7fee9e224858 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x22858) (BuildId: 0702430aef5fa3dda43986563e9ffcc47efbd75e)
#2 0x5566b89bdea6 in ConsumeIntegralInRange&lt;unsigned int&gt; /usr/local/lib/clang/18/include/fuzzer/FuzzedDataProvider.h:209:5
#3 0x5566b89bdea6 in LLVMFuzzerTestOneInput /src/libplist/fuzz/oplist_fuzzer.cc:29:58
#4 0x5566b8870390 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13
#5 0x5566b8871891 in fuzzer::Fuzzer::ReadAndExecuteSeedCorpora(std::__Fuzzer::vector&lt;fuzzer::SizedFile, std::__Fuzzer::allocator&lt;fuzzer::SizedFile&gt;&gt;&amp;) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:807:3
#6 0x5566b8871e77 in fuzzer::Fuzzer::Loop(std::__Fuzzer::vector&lt;fuzzer::SizedFile, std::__Fuzzer::allocator&lt;fuzzer::SizedFile&gt;&gt;&amp;) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:867:3
#7 0x5566b8860486 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:914:6
#8 0x5566b888c9b2 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10
#9 0x7fee9e226082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 0702430aef5fa3dda43986563e9ffcc47efbd75e)
#10 0x5566b88515fd in _start (/out/oplist_fuzzer+0x715fd)
&lt;/error&gt;

Fix code:
1. Consider possible solutions for the issues listed above.
2. Choose a solution that can maximize fuzzing result, which is utilizing the function under test and feeding it not null input.
3. Apply the solutions to the original code.
It&#39;s important to show the complete code, not only the fixed line.
&lt;solution&gt;
</pre>



<h3>Code #2</h3>

<pre>
Here is the corrected and complete code with the necessary fixes applied:

```cpp
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

extern &#34;C&#34; {
#include &#34;plist/plist.h&#34;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    // Initialize the library or any resources within plist_from_memory within libplist needed for the fuzzing process here.
    // No specific initialization required for libplist.
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    if (size == 0) {
        return 0;
    }

    FuzzedDataProvider dataProvider(data, size);

    // Generate fuzzed data for the parameters
    std::vector&lt;char&gt; plist_data = dataProvider.ConsumeRemainingBytes&lt;char&gt;();
    uint32_t length = static_cast&lt;uint32_t&gt;(plist_data.size());
    plist_t plist = nullptr;
    plist_format_t format;

    // Call the function under test
    plist_err_t result = plist_from_memory(plist_data.data(), length, &amp;plist, &amp;format);

    // Validate the result and postconditions
    if (result == PLIST_ERR_SUCCESS) {
        // Ensure plist is non-null
        if (plist == nullptr) {
            std::cerr &lt;&lt; &#34;Error: plist is null on success.&#34; &lt;&lt; std::endl;
            abort();
        }
        // Ensure format is set correctly
        switch (format) {
            case PLIST_FORMAT_BINARY:
            case PLIST_FORMAT_XML:
            case PLIST_FORMAT_JSON:
            case PLIST_FORMAT_OSTEP:
                break;
            default:
                std::cerr &lt;&lt; &#34;Error: Invalid plist format.&#34; &lt;&lt; std::endl;
                abort();
        }
    } else {
        // Ensure plist is null on failure
        if (plist != nullptr) {
            std::cerr &lt;&lt; &#34;Error: plist is not null on failure.&#34; &lt;&lt; std::endl;
            abort();
        }
    }

    // Free resources if necessary
    if (plist != nullptr) {
        plist_free(plist);
    }

    return 0;
}
```

### Explanation of Fixes:
1. **Check for Empty Input**: Added a check at the beginning of `LLVMFuzzerTestOneInput` to return immediately if the input size is zero. This prevents the function from processing empty inputs, which can lead to crashes or undefined behavior.
2. **Correct Length Calculation**: Updated the length calculation to use the size of the `plist_data` vector directly. This ensures that the length passed to `plist_from_memory` matches the actual size of the data.
3. **Removed Unnecessary Integral Consumption**: Removed the unnecessary call to `ConsumeIntegralInRange` for the length, as it was causing issues and is not needed. The length should be the size of the `plist_data` vector.

These changes ensure that the fuzz target processes valid inputs and handles edge cases correctly, improving the robustness and effectiveness of the fuzzing process.
</pre>


<h2>Logs</h2>
<pre>
Fixing /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-libplist-plist_from_memory/fixed_targets/02.cc with gpt-4o, attempt 1.
Fixing /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-libplist-plist_from_memory/fixed_targets/02.cc with gpt-4o, attempt 2.
Successfully built /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-libplist-plist_from_memory/fixed_targets/02.cc with gpt-4o in 2 iterations of fixing.
Triaging the crash related to /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-libplist-plist_from_memory/fixed_targets/02.cc with gpt-4o.
Result for libplist-plist_from_memory-02: crashes=True, coverage=0.0944700460829493 (369/3906), coverage diff=0.006412005457025921 (47/7330)

</pre>

<h2>Run logs</h2>
<pre>
INFO:__main__:Running: docker run --rm --privileged --shm-size=2g --platform linux/amd64 -e FUZZING_ENGINE=libfuzzer -e SANITIZER=address -e RUN_FUZZER_MODE=interactive -e HELPER=True -v /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-libplist-plist_from_memory/corpora/02.cc:/tmp/oplist_fuzzer_corpus -v /tmp/tmpqe63huln/build/out/libplist-plist_from_memory-02:/out -t gcr.io/oss-fuzz-base/base-runner run_fuzzer oplist_fuzzer -print_final_stats=1 -max_total_time=30 -len_control=0 -timeout=30.
vm.mmap_rnd_bits = 28
rm: cannot remove &#39;/tmp/oplist_fuzzer_corpus&#39;: Device or resource busy
Using seed corpus: oplist_fuzzer_seed_corpus.zip
/out/oplist_fuzzer -rss_limit_mb=2560 -timeout=25 -print_final_stats=1 -max_total_time=30 -len_control=0 -timeout=30 /tmp/oplist_fuzzer_corpus -max_len=4096 -dict=oplist.dict &lt; /dev/null
Dictionary: 41 entries
INFO: Running with entropic power schedule (0xFF, 100).
INFO: Seed: 1960792425
INFO: Loaded 1 modules   (3906 inline 8-bit counters): 3906 [0x55ff7e84d948, 0x55ff7e84e88a), 
INFO: Loaded 1 PC tables (3906 PCs): 3906 [0x55ff7e84e890,0x55ff7e85dcb0), 
INFO:        3 files found in /tmp/oplist_fuzzer_corpus
INFO: seed corpus: files: 3 min: 341b max: 566b total: 1368b rss: 30Mb
#4	INITED cov: 154 ft: 306 corp: 3/1368b exec/s: 0 rss: 32Mb
#6	NEW    cov: 165 ft: 340 corp: 4/1912b lim: 4096 exec/s: 0 rss: 32Mb L: 544/566 MS: 2 ShuffleBytes-CrossOver-
#8	NEW    cov: 168 ft: 357 corp: 5/2444b lim: 4096 exec/s: 0 rss: 32Mb L: 532/566 MS: 2 ChangeBit-InsertRepeatedBytes-
#9	NEW    cov: 169 ft: 399 corp: 6/3010b lim: 4096 exec/s: 0 rss: 32Mb L: 566/566 MS: 1 ChangeBit-
#15	NEW    cov: 169 ft: 427 corp: 7/3702b lim: 4096 exec/s: 0 rss: 32Mb L: 692/692 MS: 1 CopyPart-
#18	NEW    cov: 169 ft: 462 corp: 8/4243b lim: 4096 exec/s: 0 rss: 32Mb L: 541/692 MS: 3 ManualDict-CMP-CMP- DE: &#34;=\&#34;\&#34;&#34;-&#34;\364\001&#34;-&#34;\377\377\001\031&#34;-
#35	NEW    cov: 169 ft: 468 corp: 9/5060b lim: 4096 exec/s: 0 rss: 33Mb L: 817/817 MS: 2 ChangeBit-InsertRepeatedBytes-
#37	NEW    cov: 170 ft: 481 corp: 10/5628b lim: 4096 exec/s: 0 rss: 33Mb L: 568/817 MS: 2 ManualDict-ManualDict- DE: &#34;\\t&#34;-&#34;0=&#34;-
#41	NEW    cov: 170 ft: 507 corp: 11/6172b lim: 4096 exec/s: 0 rss: 33Mb L: 544/817 MS: 4 ShuffleBytes-ChangeByte-CMP-PersAutoDict- DE: &#34;\001\000\0028&#34;-&#34;\364\001&#34;-
#42	NEW    cov: 170 ft: 510 corp: 12/6738b lim: 4096 exec/s: 0 rss: 33Mb L: 566/817 MS: 1 ChangeBit-
#46	NEW    cov: 170 ft: 514 corp: 13/7427b lim: 4096 exec/s: 0 rss: 33Mb L: 689/817 MS: 4 InsertRepeatedBytes-InsertByte-PersAutoDict-ChangeBit- DE: &#34;\\t&#34;-
#50	REDUCE cov: 170 ft: 514 corp: 13/7176b lim: 4096 exec/s: 0 rss: 33Mb L: 317/817 MS: 4 CMP-CopyPart-PersAutoDict-EraseBytes- DE: &#34;\377\377\377\000&#34;-&#34;\377\377\001\031&#34;-
#66	NEW    cov: 170 ft: 536 corp: 14/7584b lim: 4096 exec/s: 0 rss: 33Mb L: 408/817 MS: 1 InsertRepeatedBytes-
#69	NEW    cov: 170 ft: 541 corp: 15/8402b lim: 4096 exec/s: 0 rss: 33Mb L: 818/818 MS: 3 InsertByte-ChangeBinInt-ChangeByte-
#77	NEW    cov: 170 ft: 551 corp: 16/8968b lim: 4096 exec/s: 0 rss: 33Mb L: 566/818 MS: 3 ChangeBit-ChangeBit-ChangeByte-
#78	NEW    cov: 170 ft: 560 corp: 17/9534b lim: 4096 exec/s: 0 rss: 33Mb L: 566/818 MS: 1 CopyPart-
#80	NEW    cov: 170 ft: 564 corp: 18/10080b lim: 4096 exec/s: 0 rss: 33Mb L: 546/818 MS: 2 ManualDict-PersAutoDict- DE: &#34;&#39;&#39;&#34;-&#34;=\&#34;\&#34;&#34;-
#83	NEW    cov: 171 ft: 596 corp: 19/10421b lim: 4096 exec/s: 0 rss: 33Mb L: 341/818 MS: 3 ChangeByte-ShuffleBytes-CMP- DE: &#34;\001\000\000\000\000\000\000\000&#34;-
#94	REDUCE cov: 171 ft: 596 corp: 19/10185b lim: 4096 exec/s: 0 rss: 33Mb L: 330/818 MS: 1 EraseBytes-
#95	NEW    cov: 172 ft: 597 corp: 20/10648b lim: 4096 exec/s: 0 rss: 33Mb L: 463/818 MS: 1 ManualDict- DE: &#34;\\t&#34;-
#103	NEW    cov: 172 ft: 598 corp: 21/11156b lim: 4096 exec/s: 0 rss: 33Mb L: 508/818 MS: 3 CopyPart-ManualDict-ManualDict- DE: &#34;\\t&#34;-&#34;(0)&#34;-
#110	NEW    cov: 172 ft: 604 corp: 22/11846b lim: 4096 exec/s: 0 rss: 33Mb L: 690/818 MS: 2 ChangeASCIIInt-InsertByte-
#112	NEW    cov: 172 ft: 605 corp: 23/12272b lim: 4096 exec/s: 0 rss: 33Mb L: 426/818 MS: 2 PersAutoDict-EraseBytes- DE: &#34;\364\001&#34;-
#113	NEW    cov: 172 ft: 606 corp: 24/12519b lim: 4096 exec/s: 0 rss: 33Mb L: 247/818 MS: 1 EraseBytes-
#114	REDUCE cov: 172 ft: 607 corp: 25/12883b lim: 4096 exec/s: 0 rss: 33Mb L: 364/818 MS: 1 InsertRepeatedBytes-
#132	NEW    cov: 172 ft: 611 corp: 26/13370b lim: 4096 exec/s: 0 rss: 34Mb L: 487/818 MS: 3 ChangeASCIIInt-PersAutoDict-EraseBytes- DE: &#34;\377\377\001\031&#34;-
#133	NEW    cov: 172 ft: 613 corp: 27/13936b lim: 4096 exec/s: 0 rss: 34Mb L: 566/818 MS: 1 PersAutoDict- DE: &#34;0=&#34;-
#134	NEW    cov: 172 ft: 636 corp: 28/14938b lim: 4096 exec/s: 0 rss: 34Mb L: 1002/1002 MS: 1 CrossOver-
#135	NEW    cov: 172 ft: 641 corp: 29/15470b lim: 4096 exec/s: 0 rss: 34Mb L: 532/1002 MS: 1 ShuffleBytes-
#143	REDUCE cov: 172 ft: 641 corp: 29/15396b lim: 4096 exec/s: 0 rss: 34Mb L: 290/1002 MS: 3 ChangeByte-InsertByte-EraseBytes-
#152	NEW    cov: 173 ft: 646 corp: 30/16086b lim: 4096 exec/s: 0 rss: 34Mb L: 690/1002 MS: 4 ChangeByte-CopyPart-ChangeASCIIInt-CopyPart-
#166	NEW    cov: 173 ft: 647 corp: 31/16Kb lim: 4096 exec/s: 0 rss: 34Mb L: 464/1002 MS: 4 CopyPart-ChangeBit-ManualDict-EraseBytes- DE: &#34;{}&#34;-
#167	NEW    cov: 173 ft: 653 corp: 32/16Kb lim: 4096 exec/s: 0 rss: 34Mb L: 566/1002 MS: 1 CrossOver-
#174	REDUCE cov: 173 ft: 653 corp: 32/16Kb lim: 4096 exec/s: 0 rss: 34Mb L: 317/1002 MS: 2 InsertRepeatedBytes-EraseBytes-
#210	NEW    cov: 173 ft: 657 corp: 33/17Kb lim: 4096 exec/s: 0 rss: 34Mb L: 566/1002 MS: 1 CrossOver-
#218	REDUCE cov: 173 ft: 657 corp: 33/17Kb lim: 4096 exec/s: 0 rss: 35Mb L: 276/1002 MS: 3 ChangeBinInt-CopyPart-EraseBytes-
#233	REDUCE cov: 173 ft: 657 corp: 33/16Kb lim: 4096 exec/s: 0 rss: 35Mb L: 309/1002 MS: 5 ChangeByte-ChangeBinInt-ChangeASCIIInt-ChangeBit-EraseBytes-
#248	NEW    cov: 173 ft: 660 corp: 34/17Kb lim: 4096 exec/s: 0 rss: 35Mb L: 351/1002 MS: 5 ShuffleBytes-ChangeByte-ChangeBit-ChangeASCIIInt-EraseBytes-
	NEW_FUNC[1/1]: 0x55ff7e717ab0 in plist_from_bin /src/libplist/src/bplist.c:788
#252	NEW    cov: 176 ft: 664 corp: 35/17Kb lim: 4096 exec/s: 126 rss: 35Mb L: 552/1002 MS: 4 CopyPart-PersAutoDict-PersAutoDict-CMP- DE: &#34;\364\001&#34;-&#34;\001\000\000\000\000\000\000\000&#34;-&#34;bplist00&#34;-
#255	REDUCE cov: 176 ft: 664 corp: 35/17Kb lim: 4096 exec/s: 127 rss: 36Mb L: 618/1002 MS: 3 ManualDict-ChangeByte-EraseBytes- DE: &#34;\\a&#34;-
#256	pulse  cov: 176 ft: 664 corp: 35/17Kb lim: 4096 exec/s: 128 rss: 36Mb
#258	REDUCE cov: 176 ft: 664 corp: 35/17Kb lim: 4096 exec/s: 129 rss: 36Mb L: 304/1002 MS: 3 CrossOver-InsertByte-EraseBytes-
#266	NEW    cov: 177 ft: 666 corp: 36/18Kb lim: 4096 exec/s: 133 rss: 36Mb L: 723/1002 MS: 3 CopyPart-ChangeBinInt-ManualDict- DE: &#34;\\b&#34;-
#268	NEW    cov: 177 ft: 669 corp: 37/18Kb lim: 4096 exec/s: 134 rss: 36Mb L: 692/1002 MS: 2 ShuffleBytes-InsertRepeatedBytes-
#274	NEW    cov: 177 ft: 670 corp: 38/19Kb lim: 4096 exec/s: 137 rss: 36Mb L: 772/1002 MS: 1 CrossOver-
#275	NEW    cov: 177 ft: 671 corp: 39/20Kb lim: 4096 exec/s: 137 rss: 36Mb L: 341/1002 MS: 1 CMP- DE: &#34;\001\000\000\000\000\000\000\000&#34;-
#278	REDUCE cov: 178 ft: 680 corp: 40/20Kb lim: 4096 exec/s: 139 rss: 36Mb L: 276/1002 MS: 3 ChangeBinInt-ChangeASCIIInt-ChangeBit-
#279	NEW    cov: 179 ft: 681 corp: 41/20Kb lim: 4096 exec/s: 139 rss: 36Mb L: 566/1002 MS: 1 PersAutoDict- DE: &#34;&#39;&#39;&#34;-
#281	NEW    cov: 179 ft: 683 corp: 42/21Kb lim: 4096 exec/s: 140 rss: 36Mb L: 214/1002 MS: 2 CrossOver-EraseBytes-
#282	NEW    cov: 179 ft: 686 corp: 43/21Kb lim: 4096 exec/s: 141 rss: 36Mb L: 288/1002 MS: 1 EraseBytes-
#294	NEW    cov: 179 ft: 702 corp: 44/21Kb lim: 4096 exec/s: 147 rss: 36Mb L: 258/1002 MS: 2 EraseBytes-InsertRepeatedBytes-
#298	REDUCE cov: 179 ft: 702 corp: 44/21Kb lim: 4096 exec/s: 149 rss: 36Mb L: 437/1002 MS: 4 ChangeBit-PersAutoDict-ShuffleBytes-EraseBytes- DE: &#34;\364\001&#34;-
#304	NEW    cov: 179 ft: 704 corp: 45/21Kb lim: 4096 exec/s: 152 rss: 36Mb L: 353/1002 MS: 1 EraseBytes-
#309	NEW    cov: 180 ft: 706 corp: 46/23Kb lim: 4096 exec/s: 154 rss: 36Mb L: 1827/1827 MS: 5 CrossOver-ChangeByte-ShuffleBytes-CopyPart-PersAutoDict- DE: &#34;\\a&#34;-
#314	NEW    cov: 182 ft: 708 corp: 47/24Kb lim: 4096 exec/s: 157 rss: 36Mb L: 878/1827 MS: 5 CrossOver-EraseBytes-M
...truncated...
930 rss: 65Mb L: 734/2788 MS: 2 PersAutoDict-EraseBytes- DE: &#34;\307\004\000\000&#34;-
#20839	NEW    cov: 366 ft: 1355 corp: 293/122Kb lim: 4096 exec/s: 6946 rss: 65Mb L: 873/2788 MS: 2 CopyPart-CopyPart-
#20850	REDUCE cov: 366 ft: 1355 corp: 293/122Kb lim: 4096 exec/s: 6950 rss: 65Mb L: 1600/2788 MS: 1 EraseBytes-
#20859	REDUCE cov: 366 ft: 1355 corp: 293/122Kb lim: 4096 exec/s: 6953 rss: 65Mb L: 509/2788 MS: 4 ChangeBinInt-ChangeBinInt-InsertRepeatedBytes-EraseBytes-
#20865	NEW    cov: 366 ft: 1356 corp: 294/122Kb lim: 4096 exec/s: 6955 rss: 65Mb L: 113/2788 MS: 1 EraseBytes-
#20866	NEW    cov: 366 ft: 1361 corp: 295/122Kb lim: 4096 exec/s: 6955 rss: 65Mb L: 85/2788 MS: 1 CopyPart-
#20883	REDUCE cov: 366 ft: 1361 corp: 295/122Kb lim: 4096 exec/s: 6961 rss: 65Mb L: 1306/2788 MS: 2 ChangeBinInt-EraseBytes-
#20898	NEW    cov: 367 ft: 1363 corp: 296/122Kb lim: 4096 exec/s: 6966 rss: 65Mb L: 321/2788 MS: 5 ChangeByte-ChangeASCIIInt-ChangeByte-InsertByte-InsertRepeatedBytes-
#20906	REDUCE cov: 367 ft: 1363 corp: 296/122Kb lim: 4096 exec/s: 6968 rss: 65Mb L: 415/2788 MS: 3 InsertByte-InsertByte-EraseBytes-
#20907	REDUCE cov: 367 ft: 1363 corp: 296/122Kb lim: 4096 exec/s: 6969 rss: 65Mb L: 515/2788 MS: 1 EraseBytes-
#20934	REDUCE cov: 367 ft: 1363 corp: 296/122Kb lim: 4096 exec/s: 6978 rss: 65Mb L: 937/2788 MS: 2 CMP-EraseBytes- DE: &#34;bplist00&#34;-
#20961	REDUCE cov: 367 ft: 1363 corp: 296/122Kb lim: 4096 exec/s: 6987 rss: 65Mb L: 110/2788 MS: 2 InsertByte-EraseBytes-
#20975	REDUCE cov: 367 ft: 1363 corp: 296/121Kb lim: 4096 exec/s: 6991 rss: 65Mb L: 153/2788 MS: 4 CMP-ShuffleBytes-InsertRepeatedBytes-EraseBytes- DE: &#34;\000\000\000\000\000\000\000\357&#34;-
#21007	REDUCE cov: 367 ft: 1363 corp: 296/121Kb lim: 4096 exec/s: 7002 rss: 65Mb L: 532/2788 MS: 2 ChangeBinInt-CrossOver-
#21017	NEW    cov: 367 ft: 1365 corp: 297/122Kb lim: 4096 exec/s: 7005 rss: 65Mb L: 1076/2788 MS: 5 ManualDict-CrossOver-ManualDict-EraseBytes-InsertRepeatedBytes- DE: &#34;\\0&#34;-&#34;()&#34;-
#21024	NEW    cov: 367 ft: 1366 corp: 298/124Kb lim: 4096 exec/s: 7008 rss: 65Mb L: 2057/2788 MS: 2 ManualDict-CopyPart- DE: &#34;/**/&#34;-
#21041	REDUCE cov: 367 ft: 1366 corp: 298/124Kb lim: 4096 exec/s: 7013 rss: 65Mb L: 716/2788 MS: 2 InsertByte-EraseBytes-
#21056	REDUCE cov: 367 ft: 1366 corp: 298/124Kb lim: 4096 exec/s: 7018 rss: 65Mb L: 1142/2788 MS: 5 ChangeBinInt-InsertRepeatedBytes-ChangeByte-CMP-EraseBytes- DE: &#34;\374\001\000\000\000\000\000\000&#34;-
#21096	REDUCE cov: 367 ft: 1368 corp: 299/124Kb lim: 4096 exec/s: 7032 rss: 65Mb L: 100/2788 MS: 5 ChangeBit-CopyPart-PersAutoDict-CMP-PersAutoDict- DE: &#34;;&#34;-&#34;l\003\000\000\000\000\000\000&#34;-&#34;[\012  \&#34;Som&#34;-
#21159	REDUCE cov: 367 ft: 1368 corp: 299/123Kb lim: 4096 exec/s: 7053 rss: 65Mb L: 303/2788 MS: 3 ChangeASCIIInt-ChangeByte-CrossOver-
#21230	REDUCE cov: 367 ft: 1368 corp: 299/123Kb lim: 4096 exec/s: 7076 rss: 65Mb L: 3/2788 MS: 1 EraseBytes-
#21264	REDUCE cov: 367 ft: 1369 corp: 300/124Kb lim: 4096 exec/s: 7088 rss: 65Mb L: 935/2788 MS: 4 ManualDict-PersAutoDict-ChangeBinInt-ChangeBinInt- DE: &#34;\\a&#34;-&#34;Some UTF8&#34;-
#21341	REDUCE cov: 367 ft: 1369 corp: 300/124Kb lim: 4096 exec/s: 7113 rss: 65Mb L: 127/2788 MS: 2 ChangeBinInt-EraseBytes-
#21360	REDUCE cov: 367 ft: 1369 corp: 300/124Kb lim: 4096 exec/s: 7120 rss: 65Mb L: 44/2788 MS: 4 ChangeByte-InsertByte-ChangeByte-EraseBytes-
#21396	REDUCE cov: 367 ft: 1369 corp: 300/124Kb lim: 4096 exec/s: 7132 rss: 65Mb L: 143/2788 MS: 1 EraseBytes-
#21470	NEW    cov: 367 ft: 1371 corp: 301/124Kb lim: 4096 exec/s: 7156 rss: 65Mb L: 125/2788 MS: 4 ManualDict-PersAutoDict-PersAutoDict-InsertRepeatedBytes- DE: &#34;0=&#34;-&#34;j\000\000\000\000\000\000\000&#34;-&#34;\307\004\000\000&#34;-
#21472	REDUCE cov: 367 ft: 1371 corp: 301/124Kb lim: 4096 exec/s: 7157 rss: 65Mb L: 607/2788 MS: 2 EraseBytes-CopyPart-
#21483	REDUCE cov: 367 ft: 1371 corp: 301/124Kb lim: 4096 exec/s: 7161 rss: 65Mb L: 36/2788 MS: 1 EraseBytes-
#21490	NEW    cov: 369 ft: 1373 corp: 302/125Kb lim: 4096 exec/s: 7163 rss: 65Mb L: 802/2788 MS: 2 ChangeByte-CopyPart-
#21538	REDUCE cov: 369 ft: 1373 corp: 302/125Kb lim: 4096 exec/s: 7179 rss: 65Mb L: 25/2788 MS: 3 InsertByte-CopyPart-EraseBytes-
#21545	REDUCE cov: 369 ft: 1373 corp: 302/125Kb lim: 4096 exec/s: 7181 rss: 65Mb L: 521/2788 MS: 2 PersAutoDict-EraseBytes- DE: &#34;&#39;&#39;&#34;-
#21550	REDUCE cov: 369 ft: 1373 corp: 302/125Kb lim: 4096 exec/s: 7183 rss: 65Mb L: 661/2788 MS: 5 ShuffleBytes-ShuffleBytes-InsertByte-ChangeASCIIInt-EraseBytes-
#21551	REDUCE cov: 369 ft: 1373 corp: 302/125Kb lim: 4096 exec/s: 7183 rss: 65Mb L: 267/2788 MS: 1 EraseBytes-
#21558	REDUCE cov: 369 ft: 1373 corp: 302/125Kb lim: 4096 exec/s: 7186 rss: 65Mb L: 329/2788 MS: 2 ChangeByte-EraseBytes-
#21625	REDUCE cov: 369 ft: 1373 corp: 302/125Kb lim: 4096 exec/s: 7208 rss: 65Mb L: 35/2788 MS: 2 ManualDict-EraseBytes- DE: &#34;\\t&#34;-
#21651	NEW    cov: 369 ft: 1376 corp: 303/125Kb lim: 4096 exec/s: 7217 rss: 65Mb L: 74/2788 MS: 1 EraseBytes-
#21772	REDUCE cov: 369 ft: 1376 corp: 303/125Kb lim: 4096 exec/s: 7257 rss: 65Mb L: 56/2788 MS: 1 EraseBytes-
#21840	REDUCE cov: 369 ft: 1376 corp: 303/125Kb lim: 4096 exec/s: 7280 rss: 65Mb L: 886/2788 MS: 3 InsertByte-InsertRepeatedBytes-EraseBytes-
#21857	REDUCE cov: 369 ft: 1376 corp: 303/125Kb lim: 4096 exec/s: 7285 rss: 65Mb L: 126/2788 MS: 2 ChangeASCIIInt-EraseBytes-
#21913	REDUCE cov: 369 ft: 1376 corp: 303/125Kb lim: 4096 exec/s: 7304 rss: 65Mb L: 82/2788 MS: 1 EraseBytes-
#21989	REDUCE cov: 369 ft: 1376 corp: 303/125Kb lim: 4096 exec/s: 7329 rss: 65Mb L: 471/2788 MS: 1 EraseBytes-
#22001	REDUCE cov: 369 ft: 1376 corp: 303/125Kb lim: 4096 exec/s: 7333 rss: 65Mb L: 43/2788 MS: 2 ChangeBit-EraseBytes-
#22075	REDUCE cov: 369 ft: 1376 corp: 303/125Kb lim: 4096 exec/s: 7358 rss: 65Mb L: 201/2788 MS: 4 ShuffleBytes-CopyPart-InsertRepeatedBytes-EraseBytes-
Error: plist is null on success.
AddressSanitizer:DEADLYSIGNAL
=================================================================
[1m[31m==17==ERROR: AddressSanitizer: ABRT on unknown address 0x000000000011 (pc 0x7f525e6d500b bp 0x7ffd2d3ff140 sp 0x7ffd2d3fee50 T0)
[1m[0mSCARINESS: 10 (signal)
    #0 0x7f525e6d500b in raise (/lib/x86_64-linux-gnu/libc.so.6+0x4300b) (BuildId: 0702430aef5fa3dda43986563e9ffcc47efbd75e)
    #1 0x7f525e6b4858 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x22858) (BuildId: 0702430aef5fa3dda43986563e9ffcc47efbd75e)
    #2 0x55ff7e6fadd8 in LLVMFuzzerTestOneInput /src/libplist/fuzz/oplist_fuzzer.cc:45:13
    #3 0x55ff7e5ad390 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13
    #4 0x55ff7e5acbb5 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool, bool*) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:516:7
    #5 0x55ff7e5ae385 in fuzzer::Fuzzer::MutateAndTestOne() /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:760:19
    #6 0x55ff7e5af175 in fuzzer::Fuzzer::Loop(std::__Fuzzer::vector&lt;fuzzer::SizedFile, std::__Fuzzer::allocator&lt;fuzzer::SizedFile&gt;&gt;&amp;) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:905:5
    #7 0x55ff7e59d486 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:914:6
    #8 0x55ff7e5c99b2 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10
    #9 0x7f525e6b6082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 0702430aef5fa3dda43986563e9ffcc47efbd75e)
    #10 0x55ff7e58e5fd in _start (/out/oplist_fuzzer+0x715fd)

DEDUP_TOKEN: raise--abort--LLVMFuzzerTestOneInput
AddressSanitizer can not provide additional info.
SUMMARY: AddressSanitizer: ABRT (/lib/x86_64-linux-gnu/libc.so.6+0x4300b) (BuildId: 0702430aef5fa3dda43986563e9ffcc47efbd75e) in raise
==17==ABORTING
MS: 1 ChangeByte-; base unit: d08045f099b19db4f4142f0f7e9335d367278e16
artifact_prefix=&#39;./&#39;; Test unit written to ./crash-7f98f9c83ec1f26272f939df0a5fe2ed75e0a093
stat::number_of_executed_units: 22081
stat::average_exec_per_sec:     7360
stat::new_units_added:          890
stat::slowest_unit_time_sec:    0
stat::peak_rss_mb:              65

</pre>


</body>