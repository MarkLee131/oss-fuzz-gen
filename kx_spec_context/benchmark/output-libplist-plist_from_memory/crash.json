{
    "samples": [

    {
        "benchmark": "output-libplist-plist_from_memory",
        "sample": "01",
        "status": "Done",
        "compiles": "True",
        "crashes": "True",
        "crash_reason": "NO_SEMANTIC_ERR",
        "bug": "True",
        "coverage": "8.65",
        "coverage_diff": "0.006002728512960437",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include <string>\\n#include <vector>\\n#include <cstdint>\\n#include <cstddef>\\n#include <cstdlib>\\n#include <cstring>\\n#include <iostream>\\n#include <sstream>\\n#include <algorithm>\\n#include <iterator>\\n#include <cctype>\\n\\nextern \"C\" {\\n#include \"plist/plist.h\"\\n}\\n\\nextern \"C\" int LLVMFuzzerInitialize(int *argc, char ***argv) {\\n    // Initialize the library or any resources within plist_from_memory within libplist needed for the fuzzing process here.\\n    // No specific initialization required for libplist.\\n    return 0;\\n}\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\\n    FuzzedDataProvider dataProvider(data, size);\\n\\n    // Generate fuzzed data for the parameters\\n    std::vector<char> plist_data_vector = dataProvider.ConsumeRemainingBytes<char>();\\n    const char *plist_data = plist_data_vector.data();\\n    uint32_t length = static_cast<uint32_t>(plist_data_vector.size());\\n    plist_t plist = nullptr;\\n    plist_format_t format;\\n\\n    // Call the function under test\\n    plist_err_t result = plist_from_memory(plist_data, length, &plist, &format);\\n\\n    // Validate the result and postconditions\\n    if (result == PLIST_ERR_SUCCESS) {\\n        // Ensure plist is non-null\\n        if (plist == nullptr) {\\n            std::cerr << \"Error: plist is null on success.\" << std::endl;\\n            abort();\\n        }\\n        // If format pointer was provided, ensure it is set correctly\\n        switch (format) {\\n            case PLIST_FORMAT_BINARY:\\n            case PLIST_FORMAT_XML:\\n            case PLIST_FORMAT_JSON:\\n            case PLIST_FORMAT_OSTEP:\\n                break;\\n            default:\\n                std::cerr << \"Error: Invalid plist format.\" << std::endl;\\n                abort();\\n        }\\n    } else {\\n        // Ensure plist is null on failure\\n        if (plist != nullptr) {\\n            std::cerr << \"Error: plist is not null on failure.\" << std::endl;\\n            abort();\\n        }\\n    }\\n\\n    // Free resources if necessary\\n    if (plist != nullptr) {\\n        plist_free(plist);\\n    }\\n\\n    return 0;\\n}",
        "model": ""
    },

    {
        "benchmark": "output-libplist-plist_from_memory",
        "sample": "02",
        "status": "Done",
        "compiles": "True",
        "crashes": "True",
        "crash_reason": "NO_SEMANTIC_ERR",
        "bug": "True",
        "coverage": "9.45",
        "coverage_diff": "0.006412005457025921",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include <string>\\n#include <vector>\\n#include <cstdint>\\n#include <cstddef>\\n#include <cstdlib>\\n#include <cstring>\\n#include <iostream>\\n#include <sstream>\\n#include <algorithm>\\n#include <iterator>\\n#include <cctype>\\n\\nextern \"C\" {\\n#include \"plist/plist.h\"\\n}\\n\\nextern \"C\" int LLVMFuzzerInitialize(int *argc, char ***argv) {\\n    // Initialize the library or any resources within plist_from_memory within libplist needed for the fuzzing process here.\\n    // No specific initialization required for libplist.\\n    return 0;\\n}\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\\n    if (size == 0) {\\n        return 0;\\n    }\\n\\n    FuzzedDataProvider dataProvider(data, size);\\n\\n    // Generate fuzzed data for the parameters\\n    std::vector<char> plist_data = dataProvider.ConsumeRemainingBytes<char>();\\n    uint32_t length = static_cast<uint32_t>(plist_data.size());\\n    plist_t plist = nullptr;\\n    plist_format_t format;\\n\\n    // Call the function under test\\n    plist_err_t result = plist_from_memory(plist_data.data(), length, &plist, &format);\\n\\n    // Validate the result and postconditions\\n    if (result == PLIST_ERR_SUCCESS) {\\n        // Ensure plist is non-null\\n        if (plist == nullptr) {\\n            std::cerr << \"Error: plist is null on success.\" << std::endl;\\n            abort();\\n        }\\n        // Ensure format is set correctly\\n        switch (format) {\\n            case PLIST_FORMAT_BINARY:\\n            case PLIST_FORMAT_XML:\\n            case PLIST_FORMAT_JSON:\\n            case PLIST_FORMAT_OSTEP:\\n                break;\\n            default:\\n                std::cerr << \"Error: Invalid plist format.\" << std::endl;\\n                abort();\\n        }\\n    } else {\\n        // Ensure plist is null on failure\\n        if (plist != nullptr) {\\n            std::cerr << \"Error: plist is not null on failure.\" << std::endl;\\n            abort();\\n        }\\n    }\\n\\n    // Free resources if necessary\\n    if (plist != nullptr) {\\n        plist_free(plist);\\n    }\\n\\n    return 0;\\n}",
        "model": ""
    },

    {
        "benchmark": "output-libplist-plist_from_memory",
        "sample": "03",
        "status": "Done",
        "compiles": "True",
        "crashes": "True",
        "crash_reason": "NO_SEMANTIC_ERR",
        "bug": "True",
        "coverage": "10.49",
        "coverage_diff": "0.006412005457025921",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include <string>\\n#include <vector>\\n#include <cstdint>\\n#include <cstddef>\\n#include <cstdlib>\\n#include <cstring>\\n#include <iostream>\\n#include <sstream>\\n#include <algorithm>\\n#include <iterator>\\n#include <cctype>\\n\\nextern \"C\" {\\n#include \"plist/plist.h\"\\n}\\n\\nextern \"C\" int LLVMFuzzerInitialize(int *argc, char ***argv) {\\n    // Initialize the library or any resources within plist_from_memory within libplist needed for the fuzzing process here.\\n    // No specific initialization required for libplist.\\n    return 0;\\n}\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\\n    FuzzedDataProvider dataProvider(data, size);\\n\\n    // Generate fuzzed data for the parameters\\n    std::vector<char> plist_data_vector = dataProvider.ConsumeRemainingBytes<char>();\\n    const char *plist_data = plist_data_vector.data();\\n    uint32_t length = static_cast<uint32_t>(plist_data_vector.size());\\n\\n    if (length == 0) {\\n        return 0; // No data to process\\n    }\\n\\n    plist_t plist = nullptr;\\n    plist_format_t format;\\n\\n    // Call the function under test\\n    plist_err_t result = plist_from_memory(plist_data, length, &plist, &format);\\n\\n    // Validate the result and postconditions\\n    if (result == PLIST_ERR_SUCCESS) {\\n        // Ensure plist is non-null\\n        if (plist == nullptr) {\\n            std::cerr << \"Error: plist is null on success.\" << std::endl;\\n            abort();\\n        }\\n        // Ensure format is set correctly\\n        switch (format) {\\n            case PLIST_FORMAT_BINARY:\\n            case PLIST_FORMAT_XML:\\n            case PLIST_FORMAT_JSON:\\n            case PLIST_FORMAT_OSTEP:\\n                break;\\n            default:\\n                std::cerr << \"Error: Invalid plist format.\" << std::endl;\\n                abort();\\n        }\\n    } else {\\n        // Ensure plist is null on failure\\n        if (plist != nullptr) {\\n            std::cerr << \"Error: plist is not null on failure.\" << std::endl;\\n            abort();\\n        }\\n    }\\n\\n    // Free resources if necessary\\n    if (plist != nullptr) {\\n        plist_free(plist);\\n    }\\n\\n    return 0;\\n}",
        "model": ""
    },

    {
        "benchmark": "output-libplist-plist_from_memory",
        "sample": "04",
        "status": "Done",
        "compiles": "True",
        "crashes": "True",
        "crash_reason": "NO_SEMANTIC_ERR",
        "bug": "True",
        "coverage": "11.77",
        "coverage_diff": "0.006412005457025921",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include <string>\\n#include <vector>\\n#include <cstdint>\\n#include <cstddef>\\n#include <cstdlib>\\n#include <cstring>\\n#include <iostream>\\n#include <sstream>\\n#include <algorithm>\\n#include <iterator>\\n#include <cctype>\\n\\nextern \"C\" {\\n#include \"plist/plist.h\"\\n}\\n\\nextern \"C\" int LLVMFuzzerInitialize(int *argc, char ***argv) {\\n    // No specific initialization required for libplist.\\n    return 0;\\n}\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\\n    FuzzedDataProvider dataProvider(data, size);\\n\\n    // Generate fuzzed data for the parameters\\n    std::vector<char> plist_data = dataProvider.ConsumeRemainingBytes<char>();\\n    uint32_t length = static_cast<uint32_t>(plist_data.size());\\n    plist_t plist = nullptr;\\n    plist_format_t format;\\n\\n    // Ensure plist_data is not empty before calling the function\\n    if (length == 0) {\\n        return 0;\\n    }\\n\\n    // Call the function under test\\n    plist_err_t result = plist_from_memory(plist_data.data(), length, &plist, &format);\\n\\n    // Validate the result and postconditions\\n    if (result == PLIST_ERR_SUCCESS) {\\n        // Ensure plist is non-null\\n        if (plist == nullptr) {\\n            std::cerr << \"Error: plist is null on success.\" << std::endl;\\n            abort();\\n        }\\n        // If format pointer was provided, ensure it is set correctly\\n        switch (format) {\\n            case PLIST_FORMAT_BINARY:\\n            case PLIST_FORMAT_XML:\\n            case PLIST_FORMAT_JSON:\\n            case PLIST_FORMAT_OSTEP:\\n                break;\\n            default:\\n                std::cerr << \"Error: Invalid plist format.\" << std::endl;\\n                abort();\\n        }\\n    } else {\\n        // Ensure plist is null on failure\\n        if (plist != nullptr) {\\n            std::cerr << \"Error: plist is not null on failure.\" << std::endl;\\n            abort();\\n        }\\n    }\\n\\n    // Free resources if necessary\\n    if (plist != nullptr) {\\n        plist_free(plist);\\n    }\\n\\n    return 0;\\n}",
        "model": ""
    },

    {
        "benchmark": "output-libplist-plist_from_memory",
        "sample": "05",
        "status": "Done",
        "compiles": "True",
        "crashes": "True",
        "crash_reason": "NO_SEMANTIC_ERR",
        "bug": "True",
        "coverage": "9.24",
        "coverage_diff": "0.006412005457025921",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include <string>\\n#include <vector>\\n#include <cstdint>\\n#include <cstddef>\\n#include <cstdlib>\\n#include <cstring>\\n#include <iostream>\\n#include <sstream>\\n#include <algorithm>\\n#include <iterator>\\n#include <cctype>\\n\\nextern \"C\" {\\n#include \"plist/plist.h\"\\n}\\n\\nextern \"C\" int LLVMFuzzerInitialize(int *argc, char ***argv) {\\n    // Initialize the library or any resources within plist_from_memory within libplist needed for the fuzzing process here.\\n    // No specific initialization required for libplist.\\n    return 0;\\n}\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\\n    if (size == 0) {\\n        return 0;\\n    }\\n\\n    FuzzedDataProvider dataProvider(data, size);\\n\\n    // Generate fuzzed data for the parameters\\n    std::vector<char> plist_data_vector = dataProvider.ConsumeRemainingBytes<char>();\\n    if (plist_data_vector.empty()) {\\n        return 0;\\n    }\\n\\n    const char *plist_data = plist_data_vector.data();\\n    uint32_t length = static_cast<uint32_t>(plist_data_vector.size());\\n    plist_t plist = nullptr;\\n    plist_format_t format;\\n\\n    // Call the function under test\\n    plist_err_t result = plist_from_memory(plist_data, length, &plist, &format);\\n\\n    // Validate the result and postconditions\\n    if (result == PLIST_ERR_SUCCESS) {\\n        // Ensure plist is non-null\\n        if (plist == nullptr) {\\n            std::cerr << \"Error: plist is null on success.\" << std::endl;\\n            abort();\\n        }\\n        // Ensure format is set correctly\\n        switch (format) {\\n            case PLIST_FORMAT_BINARY:\\n            case PLIST_FORMAT_XML:\\n            case PLIST_FORMAT_JSON:\\n            case PLIST_FORMAT_OSTEP:\\n                break;\\n            default:\\n                std::cerr << \"Error: Invalid plist format.\" << std::endl;\\n                abort();\\n        }\\n    } else {\\n        // Ensure plist is null on failure\\n        if (plist != nullptr) {\\n            std::cerr << \"Error: plist is not null on failure.\" << std::endl;\\n            abort();\\n        }\\n    }\\n\\n    // Free resources if necessary\\n    if (plist != nullptr) {\\n        plist_free(plist);\\n    }\\n\\n    return 0;\\n}",
        "model": ""
    }

    ]
}