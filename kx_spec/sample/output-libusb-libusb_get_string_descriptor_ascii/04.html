<!doctype html>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Experiment results</title>
<style>
* {
    box-sizing: border-box;
}

html {
    line-height: 1.15;
}

body {
    font-family: sans-serif;
    font-size: 16px;
}

table {
    border-collapse: collapse;
    border-spacing: 0;
}

td, th {
    border-right: 1px #dedede solid;
    border-bottom: 1px #dedede solid;
    padding: 5px;
    text-align: left;
}
td:first-child, th:first-child {
    border-left: 1px #dedede solid;
}
th {
    border-top: 1px #dedede solid;
}

tbody tr:nth-child(odd) {
    background-color: #f4f5ff;
}
</style>
<body>
    LLM: 
    
<h1>output-libusb-libusb_get_string_descriptor_ascii / 04</h1>
Bug: False
<br>
Crash reason: NO_SEMANTIC_ERR
<br>
<br>




<h3>Final code</h3>

<pre>
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

extern &#34;C&#34; {
#include &lt;libusb.h&gt;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    libusb_init(NULL);
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    FuzzedDataProvider dataProvider(data, size);

    libusb_device **devs;
    ssize_t cnt = libusb_get_device_list(NULL, &amp;devs);
    if (cnt &lt; 0) {
        return 0;
    }

    for (ssize_t i = 0; i &lt; cnt; ++i) {
        libusb_device *dev = devs[i];
        libusb_device_handle *dev_handle;
        int r = libusb_open(dev, &amp;dev_handle);
        if (r != 0) {
            continue;
        }

        uint8_t desc_index = dataProvider.ConsumeIntegral&lt;uint8_t&gt;();
        if (desc_index == 0) {
            desc_index = 1;
        }

        int length = dataProvider.ConsumeIntegralInRange&lt;int&gt;(1, 256);
        std::vector&lt;unsigned char&gt; buffer(length);

        libusb_get_string_descriptor_ascii(dev_handle, desc_index, buffer.data(), length);

        libusb_close(dev_handle);
    }

    libusb_free_device_list(devs, 1);
    return 0;
}
</pre>


<h3>Fixer prompt #1</h3>
<pre>

Given the following C++ fuzz harness and its build error message, fix the code to make it build for fuzzing.

If there is undeclared identifier or unknown type name error, fix it by finding and including the related libraries.

You MUST wrap the headers with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; if they are C headers, especially the headers are from the project.

Note that some code may need to be wrapped with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; as their source is C program.

MUST RETURN THE FULL CODE, INCLUDING UNCHANGED PARTS.
EXTREMELY IMPORTANT: AVOID USING &lt;code&gt;goto&lt;/code&gt;. If you have to write code using &lt;code&gt;goto&lt;/code&gt;, you MUST MUST also declare all variables BEFORE the &lt;code&gt;goto&lt;/code&gt;. Never introduce new variables after the &lt;code&gt;goto&lt;/code&gt;.

Below is the code needs to be built:
&lt;code&gt;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;
#include &lt;libusb-1.0/libusb.h&gt;

extern &#34;C&#34; {
#include &#34;libusbi.h&#34;
#include &#34;libusb.h&#34;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    libusb_init(NULL);
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    FuzzedDataProvider dataProvider(data, size);

    libusb_device_handle *dev_handle = libusb_open_device_with_vid_pid(NULL, 0x1234, 0x5678);
    if (!dev_handle) {
        return 0;
    }

    uint8_t desc_index = dataProvider.ConsumeIntegral&lt;uint8_t&gt;();
    if (desc_index == 0) {
        desc_index = 1;
    }

    int length = dataProvider.ConsumeIntegralInRange&lt;int&gt;(1, 256);
    std::vector&lt;unsigned char&gt; buffer(length);

    libusb_get_string_descriptor_ascii(dev_handle, desc_index, buffer.data(), length);

    libusb_close(dev_handle);
    return 0;
}
&lt;/code&gt;

The code has the following build issues:
&lt;error&gt;
/src/libusb_fuzzer.cc:13:10: fatal error: &#39;libusb-1.0/libusb.h&#39; file not found
   13 | #include &lt;libusb-1.0/libusb.h&gt;
      |          ^~~~~~~~~~~~~~~~~~~~~
&lt;/error&gt;

Fix code:
1. Consider possible solutions for the issues listed above.
2. Choose a solution that can maximize fuzzing result, which is utilizing the function under test and feeding it not null input.
3. Apply the solutions to the original code.
It&#39;s important to show the complete code, not only the fixed line.
&lt;solution&gt;
</pre>



<h3>Code #1</h3>

<pre>
Here is the complete fixed code:

```cpp
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

extern &#34;C&#34; {
#include &lt;libusb-1.0/libusb.h&gt;
#include &#34;libusbi.h&#34;
#include &#34;libusb.h&#34;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    libusb_init(NULL);
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    FuzzedDataProvider dataProvider(data, size);

    libusb_device_handle *dev_handle = libusb_open_device_with_vid_pid(NULL, 0x1234, 0x5678);
    if (!dev_handle) {
        return 0;
    }

    uint8_t desc_index = dataProvider.ConsumeIntegral&lt;uint8_t&gt;();
    if (desc_index == 0) {
        desc_index = 1;
    }

    int length = dataProvider.ConsumeIntegralInRange&lt;int&gt;(1, 256);
    std::vector&lt;unsigned char&gt; buffer(length);

    libusb_get_string_descriptor_ascii(dev_handle, desc_index, buffer.data(), length);

    libusb_close(dev_handle);
    return 0;
}
```

In this fixed version:
1. The `#include &lt;libusb-1.0/libusb.h&gt;` line is moved inside the `extern &#34;C&#34;` block to ensure C linkage.
2. All necessary headers are included and properly wrapped with `extern &#34;C&#34;` to avoid linkage issues.
3. The rest of the code remains unchanged as it correctly initializes the fuzzing environment and performs the fuzzing on the `libusb` functions.
</pre>


<h3>Fixer prompt #2</h3>
<pre>

Given the following C++ fuzz harness and its build error message, fix the code to make it build for fuzzing.

If there is undeclared identifier or unknown type name error, fix it by finding and including the related libraries.

You MUST wrap the headers with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; if they are C headers, especially the headers are from the project.

Note that some code may need to be wrapped with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; as their source is C program.

MUST RETURN THE FULL CODE, INCLUDING UNCHANGED PARTS.
EXTREMELY IMPORTANT: AVOID USING &lt;code&gt;goto&lt;/code&gt;. If you have to write code using &lt;code&gt;goto&lt;/code&gt;, you MUST MUST also declare all variables BEFORE the &lt;code&gt;goto&lt;/code&gt;. Never introduce new variables after the &lt;code&gt;goto&lt;/code&gt;.

Below is the code needs to be built:
&lt;code&gt;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

extern &#34;C&#34; {
#include &lt;libusb-1.0/libusb.h&gt;
#include &#34;libusbi.h&#34;
#include &#34;libusb.h&#34;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    libusb_init(NULL);
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    FuzzedDataProvider dataProvider(data, size);

    libusb_device_handle *dev_handle = libusb_open_device_with_vid_pid(NULL, 0x1234, 0x5678);
    if (!dev_handle) {
        return 0;
    }

    uint8_t desc_index = dataProvider.ConsumeIntegral&lt;uint8_t&gt;();
    if (desc_index == 0) {
        desc_index = 1;
    }

    int length = dataProvider.ConsumeIntegralInRange&lt;int&gt;(1, 256);
    std::vector&lt;unsigned char&gt; buffer(length);

    libusb_get_string_descriptor_ascii(dev_handle, desc_index, buffer.data(), length);

    libusb_close(dev_handle);
    return 0;
}
&lt;/code&gt;

The code has the following build issues:
&lt;error&gt;
/src/libusb_fuzzer.cc:15:10: fatal error: &#39;libusb-1.0/libusb.h&#39; file not found
   15 | #include &lt;libusb-1.0/libusb.h&gt;
      |          ^~~~~~~~~~~~~~~~~~~~~
&lt;/error&gt;

Fix code:
1. Consider possible solutions for the issues listed above.
2. Choose a solution that can maximize fuzzing result, which is utilizing the function under test and feeding it not null input.
3. Apply the solutions to the original code.
It&#39;s important to show the complete code, not only the fixed line.
&lt;solution&gt;
</pre>



<h3>Code #2</h3>

<pre>
Here&#39;s the fixed code that includes the necessary headers and ensures the code builds correctly for fuzzing:

```cpp
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

extern &#34;C&#34; {
#include &lt;libusb.h&gt;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    libusb_init(NULL);
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    FuzzedDataProvider dataProvider(data, size);

    libusb_device_handle *dev_handle = libusb_open_device_with_vid_pid(NULL, 0x1234, 0x5678);
    if (!dev_handle) {
        return 0;
    }

    uint8_t desc_index = dataProvider.ConsumeIntegral&lt;uint8_t&gt;();
    if (desc_index == 0) {
        desc_index = 1;
    }

    int length = dataProvider.ConsumeIntegralInRange&lt;int&gt;(1, 256);
    std::vector&lt;unsigned char&gt; buffer(length);

    libusb_get_string_descriptor_ascii(dev_handle, desc_index, buffer.data(), length);

    libusb_close(dev_handle);
    return 0;
}
```

Changes made:
1. Removed the incorrect `#include &lt;libusb-1.0/libusb.h&gt;` and replaced it with `#include &lt;libusb.h&gt;`.
2. Removed the unnecessary includes `&#34;libusbi.h&#34;` and `&#34;libusb.h&#34;` which are not needed for this context.

This should resolve the build error and ensure the fuzzing harness works correctly.
</pre>


<h3>Fixer prompt #3</h3>
<pre>

Given the following C++ fuzz harness and its build error message, fix the code to make it build for fuzzing.

If there is undeclared identifier or unknown type name error, fix it by finding and including the related libraries.

You MUST wrap the headers with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; if they are C headers, especially the headers are from the project.

Note that some code may need to be wrapped with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; as their source is C program.

MUST RETURN THE FULL CODE, INCLUDING UNCHANGED PARTS.
EXTREMELY IMPORTANT: AVOID USING &lt;code&gt;goto&lt;/code&gt;. If you have to write code using &lt;code&gt;goto&lt;/code&gt;, you MUST MUST also declare all variables BEFORE the &lt;code&gt;goto&lt;/code&gt;. Never introduce new variables after the &lt;code&gt;goto&lt;/code&gt;.

Below is the code needs to be built:
&lt;code&gt;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

extern &#34;C&#34; {
#include &lt;libusb.h&gt;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    libusb_init(NULL);
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    FuzzedDataProvider dataProvider(data, size);

    libusb_device_handle *dev_handle = libusb_open_device_with_vid_pid(NULL, 0x1234, 0x5678);
    if (!dev_handle) {
        return 0;
    }

    uint8_t desc_index = dataProvider.ConsumeIntegral&lt;uint8_t&gt;();
    if (desc_index == 0) {
        desc_index = 1;
    }

    int length = dataProvider.ConsumeIntegralInRange&lt;int&gt;(1, 256);
    std::vector&lt;unsigned char&gt; buffer(length);

    libusb_get_string_descriptor_ascii(dev_handle, desc_index, buffer.data(), length);

    libusb_close(dev_handle);
    return 0;
}
&lt;/code&gt;

The code can build successfully but has a runtime issue: No code coverage increasement, indicating the fuzz target ineffectively invokes the function under test.

Fix code:
1. Consider possible solutions for the issues listed above.
2. Choose a solution that can maximize fuzzing result, which is utilizing the function under test and feeding it not null input.
3. Apply the solutions to the original code.
It&#39;s important to show the complete code, not only the fixed line.
&lt;solution&gt;
</pre>



<h3>Code #3</h3>

<pre>
Sure, let&#39;s address the issue of the fuzz target not effectively invoking the function under test. One possible reason for this is that the `libusb_open_device_with_vid_pid` function might not be opening any device, leading to an early return. To improve the fuzzing effectiveness, we can add more interactions with the `libusb` library and ensure that the input data is being utilized in meaningful ways.

We will:
1. Add more interactions with the `libusb` library to increase code coverage.
2. Ensure that we are using the fuzz input data in a way that affects the behavior of the functions under test.

Here&#39;s the revised code:

```cpp
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

extern &#34;C&#34; {
#include &lt;libusb.h&gt;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    libusb_init(NULL);
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    FuzzedDataProvider dataProvider(data, size);

    libusb_device **devs;
    ssize_t cnt = libusb_get_device_list(NULL, &amp;devs);
    if (cnt &lt; 0) {
        return 0;
    }

    for (ssize_t i = 0; i &lt; cnt; ++i) {
        libusb_device *dev = devs[i];
        libusb_device_handle *dev_handle;
        int r = libusb_open(dev, &amp;dev_handle);
        if (r != 0) {
            continue;
        }

        uint8_t desc_index = dataProvider.ConsumeIntegral&lt;uint8_t&gt;();
        if (desc_index == 0) {
            desc_index = 1;
        }

        int length = dataProvider.ConsumeIntegralInRange&lt;int&gt;(1, 256);
        std::vector&lt;unsigned char&gt; buffer(length);

        libusb_get_string_descriptor_ascii(dev_handle, desc_index, buffer.data(), length);

        libusb_close(dev_handle);
    }

    libusb_free_device_list(devs, 1);
    return 0;
}
```

### Explanation:
1. **Device Enumeration**: We enumerate all USB devices using `libusb_get_device_list` and iterate over them.
2. **Device Handling**: For each device, we attempt to open it using `libusb_open`.
3. **Descriptor Fetching**: For each successfully opened device, we fetch a string descriptor using `libusb_get_string_descriptor_ascii`, utilizing the fuzz input data to determine the descriptor index and buffer length.
4. **Resource Management**: We ensure that resources are properly managed by closing each device handle and freeing the device list.

This should increase the code coverage by interacting with more parts of the `libusb` library and using the fuzz input data more effectively.
</pre>


<h2>Logs</h2>
<pre>
Fixing /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-libusb-libusb_get_string_descriptor_ascii/fixed_targets/04.cc with gpt-4o, attempt 1.
Fixing /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-libusb-libusb_get_string_descriptor_ascii/fixed_targets/04.cc with gpt-4o, attempt 2.
Fixing /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-libusb-libusb_get_string_descriptor_ascii/fixed_targets/04.cc with gpt-4o, attempt 3.
Successfully built /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-libusb-libusb_get_string_descriptor_ascii/fixed_targets/04.cc with gpt-4o in 3 iterations of fixing.
Result for libusb-libusb_get_string_descriptor_ascii-04: crashes=False, coverage=0.07860429447852761 (205/2608), coverage diff=0.2518189884649512 (1419/5635)

</pre>

<h2>Run logs</h2>
<pre>
INFO:__main__:Running: docker run --rm --privileged --shm-size=2g --platform linux/amd64 -e FUZZING_ENGINE=libfuzzer -e SANITIZER=address -e RUN_FUZZER_MODE=interactive -e HELPER=True -v /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-libusb-libusb_get_string_descriptor_ascii/corpora/04.cc:/tmp/libusb_fuzzer_corpus -v /tmp/tmpk31m_hoq/build/out/libusb-libusb_get_string_descriptor_ascii-04:/out -t gcr.io/oss-fuzz-base/base-runner run_fuzzer libusb_fuzzer -print_final_stats=1 -max_total_time=30 -len_control=0 -timeout=30.
vm.mmap_rnd_bits = 28
rm: cannot remove &#39;/tmp/libusb_fuzzer_corpus&#39;: Device or resource busy
/out/libusb_fuzzer -rss_limit_mb=2560 -timeout=25 -print_final_stats=1 -max_total_time=30 -len_control=0 -timeout=30 /tmp/libusb_fuzzer_corpus &lt; /dev/null
INFO: Running with entropic power schedule (0xFF, 100).
INFO: Seed: 2300348220
INFO: Loaded 1 modules   (2608 inline 8-bit counters): 2608 [0x55b609bbfe78, 0x55b609bc08a8), 
INFO: Loaded 1 PC tables (2608 PCs): 2608 [0x55b609bc08a8,0x55b609bcaba8), 
INFO:        0 files found in /tmp/libusb_fuzzer_corpus
INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes
INFO: A corpus is not provided, starting from an empty corpus
#2	INITED cov: 199 ft: 200 corp: 1/1b exec/s: 0 rss: 32Mb
#7	NEW    cov: 199 ft: 209 corp: 2/2b lim: 4096 exec/s: 0 rss: 33Mb L: 1/1 MS: 5 CopyPart-ChangeByte-ChangeBit-CrossOver-ChangeBinInt-
#12	NEW    cov: 201 ft: 213 corp: 3/11b lim: 4096 exec/s: 0 rss: 33Mb L: 9/9 MS: 5 ChangeBit-CrossOver-ShuffleBytes-ChangeBit-CMP- DE: &#34;\001\000\000\000\000\000\000\000&#34;-
#20	NEW    cov: 201 ft: 215 corp: 4/20b lim: 4096 exec/s: 0 rss: 33Mb L: 9/9 MS: 3 ShuffleBytes-ChangeByte-PersAutoDict- DE: &#34;\001\000\000\000\000\000\000\000&#34;-
#22	NEW    cov: 201 ft: 217 corp: 5/29b lim: 4096 exec/s: 0 rss: 33Mb L: 9/9 MS: 2 ChangeByte-ChangeBit-
#24	NEW    cov: 201 ft: 221 corp: 6/34b lim: 4096 exec/s: 24 rss: 33Mb L: 5/9 MS: 2 CrossOver-EraseBytes-
#26	NEW    cov: 203 ft: 223 corp: 7/51b lim: 4096 exec/s: 26 rss: 33Mb L: 17/17 MS: 2 PersAutoDict-ShuffleBytes- DE: &#34;\001\000\000\000\000\000\000\000&#34;-
#27	NEW    cov: 205 ft: 226 corp: 8/183b lim: 4096 exec/s: 27 rss: 33Mb L: 132/132 MS: 1 InsertRepeatedBytes-
#28	NEW    cov: 205 ft: 228 corp: 9/192b lim: 4096 exec/s: 28 rss: 33Mb L: 9/132 MS: 1 ChangeBit-
#29	NEW    cov: 205 ft: 230 corp: 10/198b lim: 4096 exec/s: 29 rss: 33Mb L: 6/132 MS: 1 InsertByte-
#56	NEW    cov: 205 ft: 232 corp: 11/200b lim: 4096 exec/s: 28 rss: 33Mb L: 2/132 MS: 2 ChangeByte-CopyPart-
#60	NEW    cov: 205 ft: 236 corp: 12/217b lim: 4096 exec/s: 30 rss: 33Mb L: 17/132 MS: 4 ShuffleBytes-ChangeByte-CopyPart-InsertRepeatedBytes-
#64	pulse  cov: 205 ft: 236 corp: 12/217b lim: 4096 exec/s: 32 rss: 33Mb
#91	NEW    cov: 205 ft: 238 corp: 13/221b lim: 4096 exec/s: 22 rss: 34Mb L: 4/132 MS: 1 EraseBytes-
#128	pulse  cov: 205 ft: 238 corp: 13/221b lim: 4096 exec/s: 25 rss: 34Mb
#138	REDUCE cov: 205 ft: 238 corp: 13/220b lim: 4096 exec/s: 23 rss: 34Mb L: 8/132 MS: 2 ChangeByte-EraseBytes-
#149	NEW    cov: 205 ft: 239 corp: 14/230b lim: 4096 exec/s: 24 rss: 34Mb L: 10/132 MS: 1 InsertByte-
#153	NEW    cov: 205 ft: 241 corp: 15/250b lim: 4096 exec/s: 25 rss: 34Mb L: 20/132 MS: 4 PersAutoDict-EraseBytes-ChangeBit-CrossOver- DE: &#34;\001\000\000\000\000\000\000\000&#34;-
#172	REDUCE cov: 205 ft: 241 corp: 15/197b lim: 4096 exec/s: 24 rss: 35Mb L: 79/79 MS: 4 ChangeBit-ChangeBinInt-CrossOver-EraseBytes-
#196	REDUCE cov: 205 ft: 241 corp: 15/195b lim: 4096 exec/s: 24 rss: 35Mb L: 7/79 MS: 4 CopyPart-EraseBytes-ChangeBinInt-EraseBytes-
#256	pulse  cov: 205 ft: 241 corp: 15/195b lim: 4096 exec/s: 23 rss: 35Mb
#304	REDUCE cov: 205 ft: 241 corp: 15/190b lim: 4096 exec/s: 23 rss: 36Mb L: 12/79 MS: 3 ChangeBinInt-InsertByte-EraseBytes-
#337	NEW    cov: 205 ft: 244 corp: 16/200b lim: 4096 exec/s: 22 rss: 36Mb L: 10/79 MS: 3 ChangeByte-ShuffleBytes-ChangeBinInt-
#347	NEW    cov: 205 ft: 246 corp: 17/225b lim: 4096 exec/s: 23 rss: 36Mb L: 25/79 MS: 5 CopyPart-CMP-ChangeBinInt-ChangeBit-ChangeBinInt- DE: &#34;\377\377\377\377\377\377\377\002&#34;-
#350	NEW    cov: 205 ft: 247 corp: 18/234b lim: 4096 exec/s: 23 rss: 36Mb L: 9/79 MS: 3 CMP-ShuffleBytes-ChangeBinInt- DE: &#34;\000\000&#34;-
#386	REDUCE cov: 205 ft: 247 corp: 18/206b lim: 4096 exec/s: 22 rss: 36Mb L: 51/51 MS: 1 EraseBytes-
#418	REDUCE cov: 205 ft: 247 corp: 18/204b lim: 4096 exec/s: 22 rss: 37Mb L: 7/51 MS: 2 CrossOver-EraseBytes-
#432	REDUCE cov: 205 ft: 247 corp: 18/203b lim: 4096 exec/s: 22 rss: 37Mb L: 8/51 MS: 4 PersAutoDict-EraseBytes-ChangeBit-ChangeBinInt- DE: &#34;\000\000&#34;-
#458	NEW    cov: 205 ft: 248 corp: 19/227b lim: 4096 exec/s: 22 rss: 37Mb L: 24/51 MS: 1 InsertRepeatedBytes-
#499	REDUCE cov: 205 ft: 248 corp: 19/226b lim: 4096 exec/s: 22 rss: 37Mb L: 8/51 MS: 1 EraseBytes-
#512	pulse  cov: 205 ft: 248 corp: 19/226b lim: 4096 exec/s: 22 rss: 38Mb
#555	REDUCE cov: 205 ft: 249 corp: 20/240b lim: 4096 exec/s: 22 rss: 38Mb L: 14/51 MS: 1 CopyPart-
#601	REDUCE cov: 205 ft: 249 corp: 20/224b lim: 4096 exec/s: 22 rss: 38Mb L: 35/35 MS: 1 EraseBytes-
#649	REDUCE cov: 205 ft: 249 corp: 20/221b lim: 4096 exec/s: 22 rss: 39Mb L: 9/35 MS: 3 ChangeBit-ChangeByte-EraseBytes-
#660	REDUCE cov: 205 ft: 249 corp: 20/218b lim: 4096 exec/s: 22 rss: 39Mb L: 14/35 MS: 1 EraseBytes-
#680	DONE   cov: 205 ft: 249 corp: 20/218b lim: 4096 exec/s: 21 rss: 39Mb
###### Recommended dictionary. ######
&#34;\001\000\000\000\000\000\000\000&#34; # Uses: 40
&#34;\377\377\377\377\377\377\377\002&#34; # Uses: 9
&#34;\000\000&#34; # Uses: 14
###### End of recommended dictionary. ######
Done 680 runs in 31 second(s)
stat::number_of_executed_units: 680
stat::average_exec_per_sec:     21
stat::new_units_added:          30
stat::slowest_unit_time_sec:    0
stat::peak_rss_mb:              39

</pre>

</body>