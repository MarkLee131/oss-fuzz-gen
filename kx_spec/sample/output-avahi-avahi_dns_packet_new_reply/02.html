<!doctype html>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Experiment results</title>
<style>
* {
    box-sizing: border-box;
}

html {
    line-height: 1.15;
}

body {
    font-family: sans-serif;
    font-size: 16px;
}

table {
    border-collapse: collapse;
    border-spacing: 0;
}

td, th {
    border-right: 1px #dedede solid;
    border-bottom: 1px #dedede solid;
    padding: 5px;
    text-align: left;
}
td:first-child, th:first-child {
    border-left: 1px #dedede solid;
}
th {
    border-top: 1px #dedede solid;
}

tbody tr:nth-child(odd) {
    background-color: #f4f5ff;
}
</style>
<body>
    LLM: 
    
<h1>output-avahi-avahi_dns_packet_new_reply / 02</h1>
Bug: True
<br>
Crash reason: NO_SEMANTIC_ERR
<br>
<br>




<h3>Final code</h3>

<pre>
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

extern &#34;C&#34; {
#include &#34;avahi-common/address.h&#34;
#include &#34;avahi-common/malloc.h&#34;
#include &#34;avahi-core/dns.h&#34;
#include &#34;avahi-core/log.h&#34;
#include &#34;avahi-core/rr.h&#34;
#include &#34;avahi-core/hashmap.h&#34;
#include &#34;avahi-common/strlst.h&#34;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    FuzzedDataProvider dataProvider(data, size);

    AvahiDnsPacket packet;
    packet.rindex = dataProvider.ConsumeIntegral&lt;unsigned&gt;();
    packet.data = static_cast&lt;uint8_t*&gt;(avahi_malloc(dataProvider.remaining_bytes()));
    if (!packet.data) {
        return 0;
    }
    dataProvider.ConsumeData(packet.data, dataProvider.remaining_bytes());

    unsigned mtu = dataProvider.ConsumeIntegral&lt;unsigned&gt;();
    int copy_queries = dataProvider.ConsumeIntegral&lt;int&gt;();
    int aa = dataProvider.ConsumeIntegral&lt;int&gt;();

    AvahiDnsPacket *new_packet = avahi_dns_packet_new_reply(&amp;packet, mtu, copy_queries, aa);

    if (new_packet) {
        avahi_dns_packet_free(new_packet);
    }

    avahi_free(packet.data);

    return 0;
}
</pre>


<h3>Fixer prompt #1</h3>
<pre>

Given the following C++ fuzz harness and its build error message, fix the code to make it build for fuzzing.

If there is undeclared identifier or unknown type name error, fix it by finding and including the related libraries.

You MUST wrap the headers with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; if they are C headers, especially the headers are from the project.

Note that some code may need to be wrapped with &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; as their source is C program.

MUST RETURN THE FULL CODE, INCLUDING UNCHANGED PARTS.
EXTREMELY IMPORTANT: AVOID USING &lt;code&gt;goto&lt;/code&gt;. If you have to write code using &lt;code&gt;goto&lt;/code&gt;, you MUST MUST also declare all variables BEFORE the &lt;code&gt;goto&lt;/code&gt;. Never introduce new variables after the &lt;code&gt;goto&lt;/code&gt;.

Below is the code needs to be built:
&lt;code&gt;
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

extern &#34;C&#34; {
#include &#34;avahi-common/address.h&#34;
#include &#34;avahi-common/malloc.h&#34;
#include &#34;avahi-core/dns.h&#34;
#include &#34;avahi-core/log.h&#34;
#include &#34;avahi-core/rr.h&#34;
#include &#34;avahi-core/hashmap.h&#34;
#include &#34;avahi-common/strlst.h&#34;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    FuzzedDataProvider dataProvider(data, size);

    AvahiDnsPacket packet;
    packet.rindex = dataProvider.ConsumeIntegral&lt;unsigned&gt;();
    packet.fields = static_cast&lt;uint8_t*&gt;(avahi_malloc(AVAHI_DNS_PACKET_HEADER_SIZE));
    if (!packet.fields) {
        return 0;
    }
    dataProvider.ConsumeData(packet.fields, AVAHI_DNS_PACKET_HEADER_SIZE);
    packet.data = static_cast&lt;uint8_t*&gt;(avahi_malloc(dataProvider.remaining_bytes()));
    if (!packet.data) {
        avahi_free(packet.fields);
        return 0;
    }
    dataProvider.ConsumeData(packet.data, dataProvider.remaining_bytes());

    unsigned mtu = dataProvider.ConsumeIntegral&lt;unsigned&gt;();
    int copy_queries = dataProvider.ConsumeIntegral&lt;int&gt;();
    int aa = dataProvider.ConsumeIntegral&lt;int&gt;();

    AvahiDnsPacket *new_packet = avahi_dns_packet_new_reply(&amp;packet, mtu, copy_queries, aa);

    if (new_packet) {
        avahi_dns_packet_free(new_packet);
    }

    avahi_free(packet.fields);
    avahi_free(packet.data);

    return 0;
}
&lt;/code&gt;

The code has the following build issues:
&lt;error&gt;
fuzz/fuzz-consume-record.cpp:33:12: error: no member named &#39;fields&#39; in &#39;AvahiDnsPacket&#39;
   33 |     packet.fields = static_cast&lt;uint8_t*&gt;(avahi_malloc(AVAHI_DNS_PACKET_HEADER_SIZE));
      |     ~~~~~~ ^
fuzz/fuzz-consume-record.cpp:34:17: error: no member named &#39;fields&#39; in &#39;AvahiDnsPacket&#39;
   34 |     if (!packet.fields) {
      |          ~~~~~~ ^
fuzz/fuzz-consume-record.cpp:37:37: error: no member named &#39;fields&#39; in &#39;AvahiDnsPacket&#39;
   37 |     dataProvider.ConsumeData(packet.fields, AVAHI_DNS_PACKET_HEADER_SIZE);
      |                              ~~~~~~ ^
fuzz/fuzz-consume-record.cpp:40:27: error: no member named &#39;fields&#39; in &#39;AvahiDnsPacket&#39;
   40 |         avahi_free(packet.fields);
      |                    ~~~~~~ ^
fuzz/fuzz-consume-record.cpp:55:23: error: no member named &#39;fields&#39; in &#39;AvahiDnsPacket&#39;
   55 |     avahi_free(packet.fields);
      |                ~~~~~~ ^
&lt;/error&gt;

Fix code:
1. Consider possible solutions for the issues listed above.
2. Choose a solution that can maximize fuzzing result, which is utilizing the function under test and feeding it not null input.
3. Apply the solutions to the original code.
It&#39;s important to show the complete code, not only the fixed line.
&lt;solution&gt;
</pre>



<h3>Code #1</h3>

<pre>
Here is the fixed code with the necessary changes to address the build issues:

```cpp
#include &lt;fuzzer/FuzzedDataProvider.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;

extern &#34;C&#34; {
#include &#34;avahi-common/address.h&#34;
#include &#34;avahi-common/malloc.h&#34;
#include &#34;avahi-core/dns.h&#34;
#include &#34;avahi-core/log.h&#34;
#include &#34;avahi-core/rr.h&#34;
#include &#34;avahi-core/hashmap.h&#34;
#include &#34;avahi-common/strlst.h&#34;
}

extern &#34;C&#34; int LLVMFuzzerInitialize(int *argc, char ***argv) {
    return 0;
}

extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    FuzzedDataProvider dataProvider(data, size);

    AvahiDnsPacket packet;
    packet.rindex = dataProvider.ConsumeIntegral&lt;unsigned&gt;();
    packet.data = static_cast&lt;uint8_t*&gt;(avahi_malloc(dataProvider.remaining_bytes()));
    if (!packet.data) {
        return 0;
    }
    dataProvider.ConsumeData(packet.data, dataProvider.remaining_bytes());

    unsigned mtu = dataProvider.ConsumeIntegral&lt;unsigned&gt;();
    int copy_queries = dataProvider.ConsumeIntegral&lt;int&gt;();
    int aa = dataProvider.ConsumeIntegral&lt;int&gt;();

    AvahiDnsPacket *new_packet = avahi_dns_packet_new_reply(&amp;packet, mtu, copy_queries, aa);

    if (new_packet) {
        avahi_dns_packet_free(new_packet);
    }

    avahi_free(packet.data);

    return 0;
}
```

Changes made:
1. Removed the references to the `fields` member of `AvahiDnsPacket` as it does not exist according to the error messages.
2. Allocated and populated only the `data` member of `AvahiDnsPacket`.

This should resolve the build issues and allow the code to be compiled for fuzzing.
</pre>


<h2>Logs</h2>
<pre>
Fixing /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-avahi-avahi_dns_packet_new_reply/fixed_targets/02.c with gpt-4o, attempt 1.
Successfully built /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-avahi-avahi_dns_packet_new_reply/fixed_targets/02.c with gpt-4o in 1 iterations of fixing.
Result for avahi-avahi_dns_packet_new_reply-02: crashes=True, coverage=0.02024070021881838 (37/1828), coverage diff=0.009651844191658049 (28/2901)

</pre>

<h2>Run logs</h2>
<pre>
INFO:__main__:Running: docker run --rm --privileged --shm-size=2g --platform linux/amd64 -e FUZZING_ENGINE=libfuzzer -e SANITIZER=address -e RUN_FUZZER_MODE=interactive -e HELPER=True -v /home/kaixuan/FDG_LLM/oss-fuzz-gen/results/output-avahi-avahi_dns_packet_new_reply/corpora/02.c:/tmp/fuzz-consume-record_corpus -v /tmp/tmpk31m_hoq/build/out/avahi-avahi_dns_packet_new_reply-02:/out -t gcr.io/oss-fuzz-base/base-runner run_fuzzer fuzz-consume-record -print_final_stats=1 -max_total_time=30 -len_control=0 -timeout=30.
vm.mmap_rnd_bits = 28
rm: cannot remove &#39;/tmp/fuzz-consume-record_corpus&#39;: Device or resource busy
/out/fuzz-consume-record -rss_limit_mb=2560 -timeout=25 -print_final_stats=1 -max_total_time=30 -len_control=0 -timeout=30 /tmp/fuzz-consume-record_corpus &lt; /dev/null
INFO: Running with entropic power schedule (0xFF, 100).
INFO: Seed: 3280600358
INFO: Loaded 1 modules   (1828 inline 8-bit counters): 1828 [0x55d0fde851b0, 0x55d0fde858d4), 
INFO: Loaded 1 PC tables (1828 PCs): 1828 [0x55d0fde858d8,0x55d0fde8cb18), 
INFO:        0 files found in /tmp/fuzz-consume-record_corpus
INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes
INFO: A corpus is not provided, starting from an empty corpus
#2	INITED cov: 6 ft: 7 corp: 1/1b exec/s: 0 rss: 30Mb
	NEW_FUNC[1/5]: 0x55d0fddf4370 in avahi_dns_packet_new_reply /src/avahi/avahi-core/dns.c:86
	NEW_FUNC[2/5]: 0x55d0fddf4c30 in avahi_dns_packet_consume_key /src/avahi/avahi-core/dns.c:661
#3	NEW    cov: 35 ft: 40 corp: 2/44b lim: 4096 exec/s: 0 rss: 31Mb L: 43/43 MS: 1 InsertRepeatedBytes-
#4	NEW    cov: 37 ft: 42 corp: 3/87b lim: 4096 exec/s: 0 rss: 31Mb L: 43/43 MS: 1 ChangeByte-
=================================================================
[1m[31m==13==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x5020000004bc at pc 0x55d0fddf782d bp 0x7fffa210f910 sp 0x7fffa210f908
[1m[0m[1m[34mREAD of size 1 at 0x5020000004bc thread T0[1m[0m
SCARINESS: 12 (1-byte-read-heap-buffer-overflow)
    #0 0x55d0fddf782c in consume_labels /src/avahi/avahi-core/dns.c:360:13
    #1 0x55d0fddf782c in avahi_dns_packet_consume_name /src/avahi/avahi-core/dns.c:425:14
    #2 0x55d0fddf4d44 in avahi_dns_packet_consume_key /src/avahi/avahi-core/dns.c:668:9
    #3 0x55d0fddf46d5 in avahi_dns_packet_new_reply /src/avahi/avahi-core/dns.c:104:22
    #4 0x55d0fddf3ca8 in LLVMFuzzerTestOneInput /src/avahi/fuzz/fuzz-consume-record.cpp:43:34
    #5 0x55d0fdca64a0 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13
    #6 0x55d0fdca5cc5 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool, bool*) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:516:7
    #7 0x55d0fdca7495 in fuzzer::Fuzzer::MutateAndTestOne() /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:760:19
    #8 0x55d0fdca8285 in fuzzer::Fuzzer::Loop(std::__Fuzzer::vector&lt;fuzzer::SizedFile, std::__Fuzzer::allocator&lt;fuzzer::SizedFile&gt;&gt;&amp;) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:905:5
    #9 0x55d0fdc96596 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:914:6
    #10 0x55d0fdcc2ac2 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10
    #11 0x7f5595857082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 0702430aef5fa3dda43986563e9ffcc47efbd75e)
    #12 0x55d0fdc8770d in _start (/out/fuzz-consume-record+0x4d70d)

DEDUP_TOKEN: consume_labels--avahi_dns_packet_consume_name--avahi_dns_packet_consume_key
[1m[32m0x5020000004bc is located 5 bytes after 7-byte region [0x5020000004b0,0x5020000004b7)
[1m[0m[1m[35mallocated by thread T0 here:[1m[0m
    #0 0x55d0fddb4a3e in malloc /src/llvm-project/compiler-rt/lib/asan/asan_malloc_linux.cpp:69:3
    #1 0x55d0fde064d6 in xmalloc /src/avahi/avahi-common/malloc.c:68:15
    #2 0x55d0fde064d6 in avahi_malloc /src/avahi/avahi-common/malloc.c:107:16
    #3 0x55d0fddf3c62 in LLVMFuzzerTestOneInput /src/avahi/fuzz/fuzz-consume-record.cpp:33:41
    #4 0x55d0fdca64a0 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13
    #5 0x55d0fdca5cc5 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool, bool*) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:516:7
    #6 0x55d0fdca7495 in fuzzer::Fuzzer::MutateAndTestOne() /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:760:19
    #7 0x55d0fdca8285 in fuzzer::Fuzzer::Loop(std::__Fuzzer::vector&lt;fuzzer::SizedFile, std::__Fuzzer::allocator&lt;fuzzer::SizedFile&gt;&gt;&amp;) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:905:5
    #8 0x55d0fdc96596 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:914:6
    #9 0x55d0fdcc2ac2 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10
    #10 0x7f5595857082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 0702430aef5fa3dda43986563e9ffcc47efbd75e)

DEDUP_TOKEN: __interceptor_malloc--xmalloc--avahi_malloc
SUMMARY: AddressSanitizer: heap-buffer-overflow /src/avahi/avahi-core/dns.c:360:13 in consume_labels
Shadow bytes around the buggy address:
  0x502000000200: [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m01[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[35mfd[1m[0m [1m[35mfd[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[35mfd[1m[0m [1m[35mfd[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[35mfd[1m[0m [1m[31mfa[1m[0m
  0x502000000280: [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[35mfd[1m[0m [1m[35mfd[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[35mfd[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[35mfd[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[35mfd[1m[0m [1m[31mfa[1m[0m
  0x502000000300: [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[35mfd[1m[0m [1m[35mfd[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[35mfd[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[35mfd[1m[0m [1m[35mfd[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[35mfd[1m[0m [1m[35mfd[1m[0m
  0x502000000380: [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[35mfd[1m[0m [1m[35mfd[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[35mfd[1m[0m [1m[35mfd[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[35mfd[1m[0m [1m[35mfd[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[35mfd[1m[0m [1m[35mfd[1m[0m
  0x502000000400: [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[35mfd[1m[0m [1m[35mfd[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[35mfd[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[35mfd[1m[0m [1m[35mfd[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m00[1m[0m [1m[31mfa[1m[0m
=&gt;0x502000000480: [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m00[1m[0m [1m[0m03[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[0m07[1m[0m[[1m[31mfa[1m[0m][1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m
  0x502000000500: [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m
  0x502000000580: [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m
  0x502000000600: [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m
  0x502000000680: [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m
  0x502000000700: [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m [1m[31mfa[1m[0m
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           [1m[0m00[1m[0m
  Partially addressable: [1m[0m01[1m[0m [1m[0m02[1m[0m [1m[0m03[1m[0m [1m[0m04[1m[0m [1m[0m05[1m[0m [1m[0m06[1m[0m [1m[0m07[1m[0m 
  Heap left redzone:       [1m[31mfa[1m[0m
  Freed heap region:       [1m[35mfd[1m[0m
  Stack left redzone:      [1m[31mf1[1m[0m
  Stack mid redzone:       [1m[31mf2[1m[0m
  Stack right redzone:     [1m[31mf3[1m[0m
  Stack after return:      [1m[35mf5[1m[0m
  Stack use after scope:   [1m[35mf8[1m[0m
  Global redzone:          [1m[31mf9[1m[0m
  Global init order:       [1m[36mf6[1m[0m
  Poisoned by user:        [1m[34mf7[1m[0m
  Container overflow:      [1m[34mfc[1m[0m
  Array cookie:            [1m[31mac[1m[0m
  Intra object redzone:    [1m[33mbb[1m[0m
  ASan internal:           [1m[33mfe[1m[0m
  Left alloca redzone:     [1m[34mca[1m[0m
  Right alloca redzone:    [1m[34mcb[1m[0m
==13==ABORTING
MS: 1 CrossOver-; base unit: adc83b19e793491b1c6ea0fd8b46cd9f32e592fc
0xba,0xba,0xba,0xba,0xba,0xba,0xba,0xba,0xba,0xba,0xa,
\272\272\272\272\272\272\272\272\272\272\012
artifact_prefix=&#39;./&#39;; Test unit written to ./crash-d4038d12eb08670b6e11e6f2e02b0cc10ae11030
Base64: urq6urq6urq6ugo=
stat::number_of_executed_units: 5
stat::average_exec_per_sec:     0
stat::new_units_added:          2
stat::slowest_unit_time_sec:    0
stat::peak_rss_mb:              31

</pre>

</body>