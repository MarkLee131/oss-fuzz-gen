{
    "samples": [

    {
        "benchmark": "output-tinyxml2-_znk8tinyxml210xmlelement12shallowcloneepns_11xmldocumente",
        "sample": "01",
        "status": "Done",
        "compiles": "True",
        "crashes": "False",
        "crash_reason": "NO_SEMANTIC_ERR",
        "bug": "True",
        "coverage": "7.28",
        "coverage_diff": "0.021252796420581657",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include <string>\\n#include <vector>\\n#include <cstdint>\\n#include <cstddef>\\n#include <cstdlib>\\n#include <cstring>\\n#include <iostream>\\n#include <sstream>\\n#include <algorithm>\\n#include <iterator>\\n#include <cctype>\\n#include <cassert>\\n#include \"tinyxml2.h\"\\n\\nusing namespace tinyxml2;\\n\\nextern \"C\" int LLVMFuzzerInitialize(int *argc, char ***argv) {\\n    return 0;\\n}\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\\n    FuzzedDataProvider dataProvider(data, size);\\n\\n    // Create a dummy XMLDocument for testing\\n    XMLDocument doc;\\n    const std::string elementNameStr = dataProvider.ConsumeRandomLengthString();\\n    const char* elementName = elementNameStr.c_str();\\n    XMLElement* originalElement = doc.NewElement(elementName);\\n\\n    // Add random attributes to the original element\\n    int numAttributes = dataProvider.ConsumeIntegralInRange<int>(0, 10);\\n    for (int i = 0; i < numAttributes; ++i) {\\n        const std::string attrNameStr = dataProvider.ConsumeRandomLengthString();\\n        const char* attrName = attrNameStr.c_str();\\n        const std::string attrValueStr = dataProvider.ConsumeRandomLengthString();\\n        const char* attrValue = attrValueStr.c_str();\\n        originalElement->SetAttribute(attrName, attrValue);\\n    }\\n\\n    // Always pass a valid document to maximize fuzzing result\\n    XMLDocument* docPtr = &doc;\\n\\n    // Call the function under test\\n    XMLNode* clonedNode = originalElement->ShallowClone(docPtr);\\n\\n    // Validate the result\\n    if (clonedNode) {\\n        XMLElement* clonedElement = clonedNode->ToElement();\\n        if (clonedElement) {\\n            // Check that the name matches\\n            assert(strcmp(clonedElement->Value(), originalElement->Value()) == 0);\\n\\n            // Check that the attributes match\\n            const XMLAttribute* originalAttr = originalElement->FirstAttribute();\\n            const XMLAttribute* clonedAttr = clonedElement->FirstAttribute();\\n            while (originalAttr && clonedAttr) {\\n                assert(strcmp(originalAttr->Name(), clonedAttr->Name()) == 0);\\n                assert(strcmp(originalAttr->Value(), clonedAttr->Value()) == 0);\\n                originalAttr = originalAttr->Next();\\n                clonedAttr = clonedAttr->Next();\\n            }\\n            assert(originalAttr == nullptr && clonedAttr == nullptr);\\n        }\\n    }\\n\\n    return 0;\\n}",
        "model": ""
    },

    {
        "benchmark": "output-tinyxml2-_znk8tinyxml210xmlelement12shallowcloneepns_11xmldocumente",
        "sample": "02",
        "status": "Done",
        "compiles": "True",
        "crashes": "False",
        "crash_reason": "NO_SEMANTIC_ERR",
        "bug": "True",
        "coverage": "7.57",
        "coverage_diff": "0.02162565249813572",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include <string>\\n#include <cstdint>\\n#include <cstdlib>\\n#include <cstring>\\n#include <cassert>\\n#include \"tinyxml2.h\"\\n\\nusing namespace tinyxml2;\\n\\nextern \"C\" int LLVMFuzzerInitialize(int *argc, char ***argv) {\\n    return 0;\\n}\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\\n    FuzzedDataProvider dataProvider(data, size);\\n\\n    // Create a dummy XMLDocument for testing\\n    XMLDocument doc;\\n    std::string elementName = dataProvider.ConsumeRandomLengthString();\\n    XMLElement* originalElement = doc.NewElement(elementName.c_str());\\n\\n    // Add random attributes to the original element\\n    int numAttributes = dataProvider.ConsumeIntegralInRange<int>(0, 10);\\n    for (int i = 0; i < numAttributes; ++i) {\\n        std::string attrName = dataProvider.ConsumeRandomLengthString();\\n        std::string attrValue = dataProvider.ConsumeRandomLengthString();\\n        originalElement->SetAttribute(attrName.c_str(), attrValue.c_str());\\n    }\\n\\n    // Randomly decide whether to pass a valid document or nullptr\\n    XMLDocument* docPtr = dataProvider.ConsumeBool() ? &doc : nullptr;\\n\\n    // Call the function under test\\n    XMLNode* clonedNode = originalElement->ShallowClone(docPtr);\\n\\n    // Validate the result\\n    if (clonedNode) {\\n        XMLElement* clonedElement = clonedNode->ToElement();\\n        if (clonedElement) {\\n            // Check that the name matches\\n            assert(strcmp(clonedElement->Value(), originalElement->Value()) == 0);\\n\\n            // Check that the attributes match\\n            const XMLAttribute* originalAttr = originalElement->FirstAttribute();\\n            const XMLAttribute* clonedAttr = clonedElement->FirstAttribute();\\n            while (originalAttr && clonedAttr) {\\n                assert(strcmp(originalAttr->Name(), clonedAttr->Name()) == 0);\\n                assert(strcmp(originalAttr->Value(), clonedAttr->Value()) == 0);\\n                originalAttr = originalAttr->Next();\\n                clonedAttr = clonedAttr->Next();\\n            }\\n            assert(originalAttr == nullptr && clonedAttr == nullptr);\\n        }\\n    }\\n\\n    return 0;\\n}",
        "model": ""
    }

    ]
}