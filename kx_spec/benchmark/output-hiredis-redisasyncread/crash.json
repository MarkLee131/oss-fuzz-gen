{
    "samples": [

    {
        "benchmark": "output-hiredis-redisasyncread",
        "sample": "01",
        "status": "Done",
        "compiles": "False",
        "crashes": "False",
        "crash_reason": "-",
        "bug": "True",
        "coverage": "0.00",
        "coverage_diff": "0.0",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include <string>\\n#include <vector>\\n#include <cstdint>\\n#include <cstddef>\\n#include <cstdlib>\\n#include <cstring>\\n#include <iostream>\\n#include <sstream>\\n#include <algorithm>\\n#include <iterator>\\n#include <cctype>\\n\\nextern \"C\" { \\n#include <hiredis/async.h>\\n#include <hiredis/read.h>\\n#include <hiredis/alloc.h>\\n#include <hiredis/hiredis.h>\\n}\\n\\nextern \"C\" int LLVMFuzzerInitialize(int *argc, char ***argv) {\\n    return 0;\\n}\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\\n    if (size == 0) {\\n        return 0;\\n    }\\n\\n    FuzzedDataProvider dataProvider(data, size);\\n\\n    redisAsyncContext *ac = (redisAsyncContext *)malloc(sizeof(redisAsyncContext));\\n    if (ac == nullptr) {\\n        return 0;\\n    }\\n    memset(ac, 0, sizeof(redisAsyncContext));\\n\\n    redisContext *c = &(ac->c);\\n    memset(c, 0, sizeof(redisContext));\\n\\n    // Initialize the redis context with some data to avoid null input\\n    c->obuf = (char *)malloc(size);\\n    if (c->obuf == nullptr) {\\n        free(ac);\\n        return 0;\\n    }\\n    memcpy(c->obuf, data, size);\\n    c->obuf_len = size;\\n\\n    // Initialize the read buffer\\n    redisReader *reader = redisReaderCreate();\\n    if (reader == nullptr) {\\n        free(c->obuf);\\n        free(ac);\\n        return 0;\\n    }\\n\\n    // Feed the data into the reader\\n    redisReaderFeed(reader, (const char*)data, size);\\n\\n    // Try to read a reply object\\n    void *reply = nullptr;\\n    redisReaderGetReply(reader, &reply);\\n\\n    // Call the target function\\n    redisAsyncRead(ac);\\n\\n    // Clean up\\n    if (reply != nullptr) {\\n        freeReplyObject(reply);\\n    }\\n    redisReaderFree(reader);\\n    free(c->obuf);\\n    free(ac);\\n\\n    return 0;\\n}",
        "model": ""
    },

    {
        "benchmark": "output-hiredis-redisasyncread",
        "sample": "02",
        "status": "Done",
        "compiles": "False",
        "crashes": "False",
        "crash_reason": "-",
        "bug": "True",
        "coverage": "0.00",
        "coverage_diff": "0.0",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include <string>\\n#include <vector>\\n#include <cstdint>\\n#include <cstddef>\\n#include <cstdlib>\\n#include <cstring>\\n#include <iostream>\\n#include <sstream>\\n#include <algorithm>\\n#include <iterator>\\n#include <cctype>\\n\\nextern \"C\" { \\n#include \"hiredis/async.h\"\\n#include \"hiredis/read.h\"\\n#include \"hiredis/alloc.h\"\\n#include \"hiredis/hiredis.h\"\\n}\\n\\nextern \"C\" int LLVMFuzzerInitialize(int *argc, char ***argv) {\\n    return 0;\\n}\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\\n    FuzzedDataProvider dataProvider(data, size);\\n\\n    redisAsyncContext *ac = (redisAsyncContext *)malloc(sizeof(redisAsyncContext));\\n    if (ac == nullptr) {\\n        return 0;\\n    }\\n    memset(ac, 0, sizeof(redisAsyncContext));\\n\\n    redisContext *c = &(ac->c);\\n    memset(c, 0, sizeof(redisContext));\\n\\n    // Simulate some realistic initialization\\n    c->err = dataProvider.ConsumeIntegral<int>();\\n    std::string errStr = dataProvider.ConsumeRandomLengthString(128);\\n    c->errstr = strdup(errStr.c_str());\\n\\n    // Ensure errstr is not null\\n    if (c->errstr == nullptr) {\\n        free(ac);\\n        return 0;\\n    }\\n\\n    redisAsyncRead(ac);\\n\\n    free(c->errstr);\\n    free(ac);\\n\\n    return 0;\\n}",
        "model": ""
    }

    ]
}