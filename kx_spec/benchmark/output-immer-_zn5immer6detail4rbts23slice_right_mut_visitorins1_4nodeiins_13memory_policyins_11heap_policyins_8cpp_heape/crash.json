{
    "samples": [

    {
        "benchmark": "output-immer-_zn5immer6detail4rbts23slice_right_mut_visitorins1_4nodeiins_13memory_policyins_11heap_policyins_8cpp_heape",
        "sample": "01",
        "status": "Done",
        "compiles": "False",
        "crashes": "False",
        "crash_reason": "-",
        "bug": "True",
        "coverage": "0.00",
        "coverage_diff": "0.0",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include <tuple>\\n#include \"immer/detail/rbts/node.hpp\"\\n#include \"immer/detail/rbts/visitor.hpp\"\\n#include \"immer/memory_policy.hpp\"\\n\\nextern \"C\" int LLVMFuzzerInitialize(int *argc, char ***argv) {\\n    return 0;\\n}\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\\n    FuzzedDataProvider data_provider(data, size);\\n\\n    using node_t = immer::detail::rbts::node<int, immer::memory_policy<\\n        immer::heap_policy<immer::cpp_heap>, \\n        immer::unsafe_refcount_policy, \\n        immer::no_lock_policy, \\n        immer::no_transience_policy, \\n        true, \\n        true>, \\n        3U, 3U>;\\n\\n    // Allocate a node to avoid dereferencing a null pointer\\n    node_t regular_sub_pos;\\n\\n    size_t index = data_provider.ConsumeIntegral<size_t>();\\n\\n    using edit_t = int;  // Placeholder type, replace with actual type if different.\\n    edit_t edit_token = data_provider.ConsumeIntegral<edit_t>();\\n\\n    // Correct the function call to the appropriate function in the namespace\\n    // Assuming the correct function is `visit_leaf`\\n    auto result = immer::detail::rbts::visit_leaf(\\n        regular_sub_pos, index, edit_token);\\n\\n    return 0;\\n}",
        "model": ""
    },

    {
        "benchmark": "output-immer-_zn5immer6detail4rbts23slice_right_mut_visitorins1_4nodeiins_13memory_policyins_11heap_policyins_8cpp_heape",
        "sample": "02",
        "status": "Done",
        "compiles": "False",
        "crashes": "False",
        "crash_reason": "-",
        "bug": "True",
        "coverage": "0.00",
        "coverage_diff": "0.0",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include <tuple>\\n#include \"immer/detail/rbts/node.hpp\"\\n#include \"immer/detail/rbts/visitor.hpp\"\\n#include \"immer/memory_policy.hpp\"\\n#include \"immer/detail/rbts/algorithms.hpp\" // Include for slice_right_mut_visitor\\n\\nextern \"C\" int LLVMFuzzerInitialize(int *argc, char ***argv) {\\n    return 0;\\n}\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\\n    FuzzedDataProvider data_provider(data, size);\\n\\n    // Use the correct type for regular_sub_pos\\n    immer::detail::rbts::node<int, immer::memory_policy<\\n        immer::heap_policy<immer::cpp_heap>, \\n        immer::unsafe_refcount_policy, \\n        immer::no_lock_policy, \\n        immer::no_transience_policy, \\n        true, true>, 3U, 3U> node;\\n\\n    size_t index = data_provider.ConsumeIntegral<size_t>();\\n\\n    // Use the correct type for edit_token\\n    immer::detail::rbts::edit_t edit_token;\\n\\n    // Use the correct visitor type\\n    auto result = immer::detail::rbts::slice_right_mut_visitor<\\n        immer::detail::rbts::node<int, immer::memory_policy<\\n        immer::heap_policy<immer::cpp_heap>, \\n        immer::unsafe_refcount_policy, \\n        immer::no_lock_policy, \\n        immer::no_transience_policy, \\n        false, true>, 2u, 2u>, \\n        true, true>::visit_regular(node, index, edit_token);\\n\\n    return 0;\\n}",
        "model": ""
    }

    ]
}