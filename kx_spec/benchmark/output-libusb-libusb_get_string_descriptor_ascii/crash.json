{
    "samples": [

    {
        "benchmark": "output-libusb-libusb_get_string_descriptor_ascii",
        "sample": "01",
        "status": "Done",
        "compiles": "True",
        "crashes": "False",
        "crash_reason": "NO_COV_INCREASE",
        "bug": "False",
        "coverage": "0.00",
        "coverage_diff": "0.0",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include <string>\\n#include <vector>\\n#include <cstdint>\\n#include <cstddef>\\n#include <cstdlib>\\n#include <cstring>\\n#include <iostream>\\n#include <sstream>\\n#include <algorithm>\\n#include <iterator>\\n#include <cctype>\\n\\nextern \"C\" {\\n#include <libusb.h>\\n}\\n\\nextern \"C\" int LLVMFuzzerInitialize(int *argc, char ***argv) {\\n    libusb_init(NULL);\\n    return 0;\\n}\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\\n    if (size == 0) {\\n        return 0;\\n    }\\n\\n    FuzzedDataProvider dataProvider(data, size);\\n\\n    libusb_device **devs;\\n    ssize_t cnt = libusb_get_device_list(NULL, &devs);\\n    if (cnt < 0) {\\n        return 0;\\n    }\\n\\n    libusb_device_handle *dev_handle = libusb_open_device_with_vid_pid(NULL, 0x1234, 0x5678);\\n    if (!dev_handle) {\\n        libusb_free_device_list(devs, 1);\\n        return 0;\\n    }\\n\\n    uint8_t desc_index = dataProvider.ConsumeIntegral<uint8_t>();\\n    if (desc_index == 0) {\\n        desc_index = 1;\\n    }\\n\\n    int length = dataProvider.ConsumeIntegralInRange<int>(1, 256);\\n    std::vector<unsigned char> buffer(length);\\n\\n    int ret = libusb_get_string_descriptor_ascii(dev_handle, desc_index, buffer.data(), length);\\n\\n    // Use the buffer to simulate some processing\\n    if (ret > 0) {\\n        std::string result(buffer.begin(), buffer.begin() + ret);\\n        std::transform(result.begin(), result.end(), result.begin(), ::toupper);\\n        std::cout << \"Processed string: \" << result << std::endl;\\n    }\\n\\n    libusb_close(dev_handle);\\n    libusb_free_device_list(devs, 1);\\n    return 0;\\n}",
        "model": ""
    },

    {
        "benchmark": "output-libusb-libusb_get_string_descriptor_ascii",
        "sample": "02",
        "status": "Done",
        "compiles": "False",
        "crashes": "False",
        "crash_reason": "-",
        "bug": "True",
        "coverage": "0.00",
        "coverage_diff": "0.0",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include <string>\\n#include <vector>\\n#include <cstdint>\\n#include <cstddef>\\n#include <cstdlib>\\n#include <cstring>\\n#include <iostream>\\n#include <sstream>\\n#include <algorithm>\\n#include <iterator>\\n#include <cctype>\\n\\nextern \"C\" {\\n#include <libusb.h>\\n#include \"libusbi.h\"\\n}\\n\\nextern \"C\" int LLVMFuzzerInitialize(int *argc, char ***argv) {\\n    libusb_init(NULL);\\n    return 0;\\n}\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\\n    FuzzedDataProvider dataProvider(data, size);\\n\\n    // Simulate the presence of a USB device\\n    libusb_device_handle *dev_handle = libusb_open_device_with_vid_pid(NULL, 0x1234, 0x5678);\\n    if (!dev_handle) {\\n        // If no device is found, simulate a device for fuzzing purposes\\n        dev_handle = (libusb_device_handle *)malloc(sizeof(libusb_device_handle));\\n        if (!dev_handle) {\\n            return 0;\\n        }\\n        memset(dev_handle, 0, sizeof(libusb_device_handle));\\n        \\n        // Initialize the device handle to avoid undefined behavior\\n        dev_handle->dev = (libusb_device *)malloc(sizeof(libusb_device));\\n        if (!dev_handle->dev) {\\n            free(dev_handle);\\n            return 0;\\n        }\\n        memset(dev_handle->dev, 0, sizeof(libusb_device));\\n\\n        // Initialize the device descriptor to avoid undefined behavior\\n        libusb_device_descriptor *desc = (libusb_device_descriptor *)malloc(sizeof(libusb_device_descriptor));\\n        if (!desc) {\\n            free(dev_handle->dev);\\n            free(dev_handle);\\n            return 0;\\n        }\\n        memset(desc, 0, sizeof(libusb_device_descriptor));\\n        dev_handle->dev->descriptor = *desc;\\n        free(desc);\\n    }\\n\\n    uint8_t desc_index = dataProvider.ConsumeIntegral<uint8_t>();\\n    if (desc_index == 0) {\\n        desc_index = 1;\\n    }\\n\\n    int length = dataProvider.ConsumeIntegralInRange<int>(1, 256);\\n    std::vector<unsigned char> buffer(length);\\n\\n    libusb_get_string_descriptor_ascii(dev_handle, desc_index, buffer.data(), length);\\n\\n    // Clean up the simulated device\\n    if (dev_handle) {\\n        if (dev_handle->dev) {\\n            free(dev_handle->dev);\\n        }\\n        libusb_close(dev_handle);\\n        free(dev_handle);\\n    }\\n    return 0;\\n}",
        "model": ""
    },

    {
        "benchmark": "output-libusb-libusb_get_string_descriptor_ascii",
        "sample": "03",
        "status": "Done",
        "compiles": "True",
        "crashes": "False",
        "crash_reason": "NO_SEMANTIC_ERR",
        "bug": "True",
        "coverage": "1.76",
        "coverage_diff": "0.13203194321206743",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include <string>\\n#include <vector>\\n#include <cstdint>\\n#include <cstddef>\\n#include <cstdlib>\\n#include <cstring>\\n#include <iostream>\\n#include <sstream>\\n#include <algorithm>\\n#include <iterator>\\n#include <cctype>\\n\\n// Including the correct libusb header\\n#include <libusb.h>\\n\\nextern \"C\" {\\n#include \"libusbi.h\"\\n#include \"libusb.h\"\\n}\\n\\nextern \"C\" int LLVMFuzzerInitialize(int *argc, char ***argv) {\\n    if (libusb_init(NULL) != 0) {\\n        std::cerr << \"Failed to initialize libusb\" << std::endl;\\n        return -1;\\n    }\\n    return 0;\\n}\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\\n    if (size == 0) {\\n        return 0;\\n    }\\n\\n    FuzzedDataProvider dataProvider(data, size);\\n\\n    libusb_device_handle *dev_handle = libusb_open_device_with_vid_pid(NULL, 0x1234, 0x5678);\\n    if (!dev_handle) {\\n        std::cerr << \"Failed to open device\" << std::endl;\\n        return 0;\\n    }\\n\\n    uint8_t desc_index = dataProvider.ConsumeIntegral<uint8_t>();\\n    if (desc_index == 0) {\\n        desc_index = 1;\\n    }\\n\\n    int length = dataProvider.ConsumeIntegralInRange<int>(1, 256);\\n    std::vector<unsigned char> buffer(length);\\n\\n    int ret = libusb_get_string_descriptor_ascii(dev_handle, desc_index, buffer.data(), length);\\n\\n    // Check if the function call was successful to ensure code coverage\\n    if (ret >= 0) {\\n        std::cout << \"Descriptor: \";\\n        for (int i = 0; i < ret; ++i) {\\n            std::cout << std::hex << static_cast<int>(buffer[i]) << \" \";\\n        }\\n        std::cout << std::endl;\\n    } else {\\n        std::cerr << \"Failed to get string descriptor\" << std::endl;\\n    }\\n\\n    libusb_close(dev_handle);\\n    return 0;\\n}",
        "model": ""
    },

    {
        "benchmark": "output-libusb-libusb_get_string_descriptor_ascii",
        "sample": "04",
        "status": "Done",
        "compiles": "True",
        "crashes": "False",
        "crash_reason": "NO_SEMANTIC_ERR",
        "bug": "True",
        "coverage": "7.86",
        "coverage_diff": "0.2518189884649512",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include <string>\\n#include <vector>\\n#include <cstdint>\\n#include <cstddef>\\n#include <cstdlib>\\n#include <cstring>\\n#include <iostream>\\n#include <sstream>\\n#include <algorithm>\\n#include <iterator>\\n#include <cctype>\\n\\nextern \"C\" {\\n#include <libusb.h>\\n}\\n\\nextern \"C\" int LLVMFuzzerInitialize(int *argc, char ***argv) {\\n    libusb_init(NULL);\\n    return 0;\\n}\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\\n    FuzzedDataProvider dataProvider(data, size);\\n\\n    libusb_device **devs;\\n    ssize_t cnt = libusb_get_device_list(NULL, &devs);\\n    if (cnt < 0) {\\n        return 0;\\n    }\\n\\n    for (ssize_t i = 0; i < cnt; ++i) {\\n        libusb_device *dev = devs[i];\\n        libusb_device_handle *dev_handle;\\n        int r = libusb_open(dev, &dev_handle);\\n        if (r != 0) {\\n            continue;\\n        }\\n\\n        uint8_t desc_index = dataProvider.ConsumeIntegral<uint8_t>();\\n        if (desc_index == 0) {\\n            desc_index = 1;\\n        }\\n\\n        int length = dataProvider.ConsumeIntegralInRange<int>(1, 256);\\n        std::vector<unsigned char> buffer(length);\\n\\n        libusb_get_string_descriptor_ascii(dev_handle, desc_index, buffer.data(), length);\\n\\n        libusb_close(dev_handle);\\n    }\\n\\n    libusb_free_device_list(devs, 1);\\n    return 0;\\n}",
        "model": ""
    },

    {
        "benchmark": "output-libusb-libusb_get_string_descriptor_ascii",
        "sample": "05",
        "status": "Done",
        "compiles": "False",
        "crashes": "False",
        "crash_reason": "-",
        "bug": "True",
        "coverage": "0.00",
        "coverage_diff": "0.0",
        "coverage_report": "#",
        "stacktrace": "/stacktrace",
        "target_binary": "/target_binary",
        "reproducer": "/artifacts",
        "run_log": "run.log",
        "source_code": "#include <fuzzer/FuzzedDataProvider.h>\\n#include <string>\\n#include <vector>\\n#include <cstdint>\\n#include <cstddef>\\n#include <cstdlib>\\n#include <cstring>\\n#include <iostream>\\n#include <sstream>\\n#include <algorithm>\\n#include <iterator>\\n#include <cctype>\\n\\nextern \"C\" {\\n#include <libusb.h>\\n#include \"libusbi.h\"\\n}\\n\\nextern \"C\" int LLVMFuzzerInitialize(int *argc, char ***argv) {\\n    libusb_init(NULL);\\n    return 0;\\n}\\n\\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\\n    FuzzedDataProvider dataProvider(data, size);\\n\\n    // Simulate the presence of a USB device\\n    libusb_device_handle *dev_handle = libusb_open_device_with_vid_pid(NULL, 0x1234, 0x5678);\\n    if (!dev_handle) {\\n        // Simulate opening a device successfully\\n        dev_handle = libusb_alloc_transfer(0);\\n        if (!dev_handle) {\\n            return 0;\\n        }\\n    }\\n\\n    uint8_t desc_index = dataProvider.ConsumeIntegral<uint8_t>();\\n    if (desc_index == 0) {\\n        desc_index = 1;\\n    }\\n\\n    int length = dataProvider.ConsumeIntegralInRange<int>(1, 256);\\n    std::vector<unsigned char> buffer(length);\\n\\n    libusb_get_string_descriptor_ascii(dev_handle, desc_index, buffer.data(), length);\\n\\n    // Simulate closing the device\\n    if (dev_handle) {\\n        libusb_free_transfer((libusb_transfer*)dev_handle);\\n    }\\n    return 0;\\n}",
        "model": ""
    }

    ]
}